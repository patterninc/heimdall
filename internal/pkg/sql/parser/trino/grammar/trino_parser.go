// Code generated from TrinoParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package grammar // TrinoParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type TrinoParser struct {
	*antlr.BaseParser
}

var TrinoParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func trinoparserParserInit() {
	staticData := &TrinoParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'ABSENT'", "'ADD'", "'ADMIN'", "'AFTER'", "'ALL'", "'ALTER'", "'ANALYZE'",
		"'AND'", "'ANY'", "'ARRAY'", "'AS'", "'ASC'", "'AT'", "'AUTHORIZATION'",
		"'BEGIN'", "'BERNOULLI'", "'BETWEEN'", "'BOTH'", "'BY'", "'CALL'", "'CALLED'",
		"'CASCADE'", "'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'COLUMN'",
		"'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMMITTED'", "'CONDITIONAL'",
		"'CONSTRAINT'", "'COUNT'", "'COPARTITION'", "'CREATE'", "'CROSS'", "'CUBE'",
		"'CURRENT'", "'CURRENT_CATALOG'", "'CURRENT_DATE'", "'CURRENT_PATH'",
		"'CURRENT_ROLE'", "'CURRENT_SCHEMA'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'CURRENT_USER'", "'DATA'", "'DATE'", "'DAY'", "'DEALLOCATE'", "'DECLARE'",
		"'DEFAULT'", "'DEFINE'", "'DEFINER'", "'DELETE'", "'DENY'", "'DESC'",
		"'DESCRIBE'", "'DESCRIPTOR'", "'DETERMINISTIC'", "'DISTINCT'", "'DISTRIBUTED'",
		"'DO'", "'DOUBLE'", "'DROP'", "'ELSE'", "'EMPTY'", "'ELSEIF'", "'ENCODING'",
		"'END'", "'ERROR'", "'ESCAPE'", "'EXCEPT'", "'EXCLUDING'", "'EXECUTE'",
		"'EXISTS'", "'EXPLAIN'", "'EXTRACT'", "'FALSE'", "'FETCH'", "'FILTER'",
		"'FINAL'", "'FIRST'", "'FOLLOWING'", "'FOR'", "'FORMAT'", "'FROM'",
		"'FULL'", "'FUNCTION'", "'FUNCTIONS'", "'GRACE'", "'GRANT'", "'GRANTED'",
		"'GRANTS'", "'GRAPHVIZ'", "'GROUP'", "'GROUPING'", "'GROUPS'", "'HAVING'",
		"'HOUR'", "'IF'", "'IGNORE'", "'IMMEDIATE'", "'IN'", "'INCLUDING'",
		"'INITIAL'", "'INNER'", "'INPUT'", "'INSERT'", "'INTERSECT'", "'INTERVAL'",
		"'INTO'", "'INVOKER'", "'IO'", "'IS'", "'ISOLATION'", "'ITERATE'", "'JOIN'",
		"'JSON'", "'JSON_ARRAY'", "'JSON_EXISTS'", "'JSON_OBJECT'", "'JSON_QUERY'",
		"'JSON_TABLE'", "'JSON_VALUE'", "'KEEP'", "'KEY'", "'KEYS'", "'LANGUAGE'",
		"'LAST'", "'LATERAL'", "'LEADING'", "'LEAVE'", "'LEFT'", "'LEVEL'",
		"'LIKE'", "'LIMIT'", "'LISTAGG'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'",
		"'LOGICAL'", "'LOOP'", "'MAP'", "'MATCH'", "'MATCHED'", "'MATCHES'",
		"'MATCH_RECOGNIZE'", "'MATERIALIZED'", "'MEASURES'", "'MERGE'", "'MINUTE'",
		"'MONTH'", "'NATURAL'", "'NESTED'", "'NEXT'", "'NFC'", "'NFD'", "'NFKC'",
		"'NFKD'", "'NO'", "'NONE'", "'NORMALIZE'", "'NOT'", "'NULL'", "'NULLIF'",
		"'NULLS'", "'OBJECT'", "'OF'", "'OFFSET'", "'OMIT'", "'ON'", "'ONE'",
		"'ONLY'", "'OPTION'", "'OR'", "'ORDER'", "'ORDINALITY'", "'OUTER'",
		"'OUTPUT'", "'OVER'", "'OVERFLOW'", "'PARTITION'", "'PARTITIONS'", "'PASSING'",
		"'PAST'", "'PATH'", "'PATTERN'", "'PER'", "'PERIOD'", "'PERMUTE'", "'PLAN'",
		"'POSITION'", "'PRECEDING'", "'PRECISION'", "'PREPARE'", "'PRIVILEGES'",
		"'PROPERTIES'", "'PRUNE'", "'QUOTES'", "'RANGE'", "'READ'", "'RECURSIVE'",
		"'REFRESH'", "'RENAME'", "'REPEAT'", "'REPEATABLE'", "'REPLACE'", "'RESET'",
		"'RESPECT'", "'RESTRICT'", "'RETURN'", "'RETURNING'", "'RETURNS'", "'REVOKE'",
		"'RIGHT'", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'",
		"'RUNNING'", "'SCALAR'", "'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SECURITY'",
		"'SEEK'", "'SELECT'", "'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'",
		"'SHOW'", "'SKIP'", "'SOME'", "'START'", "'STATS'", "'SUBSET'", "'SUBSTRING'",
		"'SYSTEM'", "'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TEXT'", "'STRING'",
		"'THEN'", "'TIES'", "'TIME'", "'TIMESTAMP'", "'TO'", "'TRAILING'", "'TRANSACTION'",
		"'TRIM'", "'TRUE'", "'TRUNCATE'", "'TRY_CAST'", "'TYPE'", "'UESCAPE'",
		"'UNBOUNDED'", "'UNCOMMITTED'", "'UNCONDITIONAL'", "'UNION'", "'UNIQUE'",
		"'UNKNOWN'", "'UNMATCHED'", "'UNNEST'", "'UNTIL'", "'UPDATE'", "'USE'",
		"'USER'", "'USING'", "'UTF16'", "'UTF32'", "'UTF8'", "'VALIDATE'", "'VALUE'",
		"'VALUES'", "'VERBOSE'", "'VERSION'", "'VIEW'", "'WHEN'", "'WHERE'",
		"'WHILE'", "'WINDOW'", "'WITH'", "'WITHIN'", "'WITHOUT'", "'WORK'",
		"'WRAPPER'", "'WRITE'", "'YEAR'", "'ZONE'", "'='", "", "'<'", "'<='",
		"'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'", "'?'", "';'",
		"'.'", "'_:'", "','", "'('", "')'", "'['", "']'", "'{'", "'}'", "'{-'",
		"'-}'", "'<-'", "'->'", "'=>'", "'|'", "'$'", "'^'",
	}
	staticData.SymbolicNames = []string{
		"", "ABSENT_", "ADD_", "ADMIN_", "AFTER_", "ALL_", "ALTER_", "ANALYZE_",
		"AND_", "ANY_", "ARRAY_", "AS_", "ASC_", "AT_", "AUTHORIZATION_", "BEGIN_",
		"BERNOULLI_", "BETWEEN_", "BOTH_", "BY_", "CALL_", "CALLED_", "CASCADE_",
		"CASE_", "CAST_", "CATALOG_", "CATALOGS_", "COLUMN_", "COLUMNS_", "COMMENT_",
		"COMMIT_", "COMMITTED_", "CONDITIONAL_", "CONSTRAINT_", "COUNT_", "COPARTITION_",
		"CREATE_", "CROSS_", "CUBE_", "CURRENT_", "CURRENT_CATALOG_", "CURRENT_DATE_",
		"CURRENT_PATH_", "CURRENT_ROLE_", "CURRENT_SCHEMA_", "CURRENT_TIME_",
		"CURRENT_TIMESTAMP_", "CURRENT_USER_", "DATA_", "DATE_", "DAY_", "DEALLOCATE_",
		"DECLARE_", "DEFAULT_", "DEFINE_", "DEFINER_", "DELETE_", "DENY_", "DESC_",
		"DESCRIBE_", "DESCRIPTOR_", "DETERMINISTIC_", "DISTINCT_", "DISTRIBUTED_",
		"DO_", "DOUBLE_", "DROP_", "ELSE_", "EMPTY_", "ELSEIF_", "ENCODING_",
		"END_", "ERROR_", "ESCAPE_", "EXCEPT_", "EXCLUDING_", "EXECUTE_", "EXISTS_",
		"EXPLAIN_", "EXTRACT_", "FALSE_", "FETCH_", "FILTER_", "FINAL_", "FIRST_",
		"FOLLOWING_", "FOR_", "FORMAT_", "FROM_", "FULL_", "FUNCTION_", "FUNCTIONS_",
		"GRACE_", "GRANT_", "GRANTED_", "GRANTS_", "GRAPHVIZ_", "GROUP_", "GROUPING_",
		"GROUPS_", "HAVING_", "HOUR_", "IF_", "IGNORE_", "IMMEDIATE_", "IN_",
		"INCLUDING_", "INITIAL_", "INNER_", "INPUT_", "INSERT_", "INTERSECT_",
		"INTERVAL_", "INTO_", "INVOKER_", "IO_", "IS_", "ISOLATION_", "ITERATE_",
		"JOIN_", "JSON_", "JSON_ARRAY_", "JSON_EXISTS_", "JSON_OBJECT_", "JSON_QUERY_",
		"JSON_TABLE_", "JSON_VALUE_", "KEEP_", "KEY_", "KEYS_", "LANGUAGE_",
		"LAST_", "LATERAL_", "LEADING_", "LEAVE_", "LEFT_", "LEVEL_", "LIKE_",
		"LIMIT_", "LISTAGG_", "LOCAL_", "LOCALTIME_", "LOCALTIMESTAMP_", "LOGICAL_",
		"LOOP_", "MAP_", "MATCH_", "MATCHED_", "MATCHES_", "MATCH_RECOGNIZE_",
		"MATERIALIZED_", "MEASURES_", "MERGE_", "MINUTE_", "MONTH_", "NATURAL_",
		"NESTED_", "NEXT_", "NFC_", "NFD_", "NFKC_", "NFKD_", "NO_", "NONE_",
		"NORMALIZE_", "NOT_", "NULL_", "NULLIF_", "NULLS_", "OBJECT_", "OF_",
		"OFFSET_", "OMIT_", "ON_", "ONE_", "ONLY_", "OPTION_", "OR_", "ORDER_",
		"ORDINALITY_", "OUTER_", "OUTPUT_", "OVER_", "OVERFLOW_", "PARTITION_",
		"PARTITIONS_", "PASSING_", "PAST_", "PATH_", "PATTERN_", "PER_", "PERIOD_",
		"PERMUTE_", "PLAN_", "POSITION_", "PRECEDING_", "PRECISION_", "PREPARE_",
		"PRIVILEGES_", "PROPERTIES_", "PRUNE_", "QUOTES_", "RANGE_", "READ_",
		"RECURSIVE_", "REFRESH_", "RENAME_", "REPEAT_", "REPEATABLE_", "REPLACE_",
		"RESET_", "RESPECT_", "RESTRICT_", "RETURN_", "RETURNING_", "RETURNS_",
		"REVOKE_", "RIGHT_", "ROLE_", "ROLES_", "ROLLBACK_", "ROLLUP_", "ROW_",
		"ROWS_", "RUNNING_", "SCALAR_", "SCHEMA_", "SCHEMAS_", "SECOND_", "SECURITY_",
		"SEEK_", "SELECT_", "SERIALIZABLE_", "SESSION_", "SET_", "SETS_", "SHOW_",
		"SKIP_", "SOME_", "START_", "STATS_", "SUBSET_", "SUBSTRING_", "SYSTEM_",
		"TABLE_", "TABLES_", "TABLESAMPLE_", "TEXT_", "TEXT_STRING_", "THEN_",
		"TIES_", "TIME_", "TIMESTAMP_", "TO_", "TRAILING_", "TRANSACTION_",
		"TRIM_", "TRUE_", "TRUNCATE_", "TRY_CAST_", "TYPE_", "UESCAPE_", "UNBOUNDED_",
		"UNCOMMITTED_", "UNCONDITIONAL_", "UNION_", "UNIQUE_", "UNKNOWN_", "UNMATCHED_",
		"UNNEST_", "UNTIL_", "UPDATE_", "USE_", "USER_", "USING_", "UTF16_",
		"UTF32_", "UTF8_", "VALIDATE_", "VALUE_", "VALUES_", "VERBOSE_", "VERSION_",
		"VIEW_", "WHEN_", "WHERE_", "WHILE_", "WINDOW_", "WITH_", "WITHIN_",
		"WITHOUT_", "WORK_", "WRAPPER_", "WRITE_", "YEAR_", "ZONE_", "EQ_",
		"NEQ_", "LT_", "LTE_", "GT_", "GTE_", "PLUS_", "MINUS_", "ASTERISK_",
		"SLASH_", "PERCENT_", "CONCAT_", "QUESTION_MARK_", "SEMICOLON_", "DOT_",
		"COLON_", "COMMA_", "LPAREN_", "RPAREN_", "LSQUARE_", "RSQUARE_", "LCURLY_",
		"RCURLY_", "LCURLYHYPHEN_", "RCURLYHYPHEN_", "LARROW_", "RARROW_", "RDOUBLEARROW_",
		"VBAR_", "DOLLAR_", "CARET_", "STRING_", "UNICODE_STRING_", "BINARY_LITERAL_",
		"INTEGER_VALUE_", "DECIMAL_VALUE_", "DOUBLE_VALUE_", "IDENTIFIER_",
		"DIGIT_IDENTIFIER_", "QUOTED_IDENTIFIER_", "BACKQUOTED_IDENTIFIER_",
		"SIMPLE_COMMENT_", "BRACKETED_COMMENT_", "WS_", "UNRECOGNIZED_",
	}
	staticData.RuleNames = []string{
		"parse", "statements", "singleStatement", "standaloneExpression", "standalonePathSpecification",
		"standaloneType", "standaloneRowPattern", "standaloneFunctionSpecification",
		"statement", "rootQuery", "withFunction", "query", "with", "tableElement",
		"columnDefinition", "likeClause", "properties", "propertyAssignments",
		"property", "propertyValue", "queryNoWith", "limitRowCount", "rowCount",
		"queryTerm", "queryPrimary", "sortItem", "querySpecification", "groupBy",
		"groupingElement", "groupingSet", "windowDefinition", "windowSpecification",
		"namedQuery", "setQuantifier", "selectItem", "relation", "joinType",
		"joinCriteria", "sampledRelation", "sampleType", "trimsSpecification",
		"listAggOverflowBehavior", "listaggCountIndication", "patternRecognition",
		"measureDefinition", "rowsPerMatch", "emptyMatchHandling", "skipTo",
		"subsetDefinition", "variableDefinition", "aliasedRelation", "columnAliases",
		"relationPrimary", "tableFunctionCall", "tableFunctionArgument", "tableArgument",
		"tableArgumentRelation", "descriptorArgument", "descriptorField", "copartitionTables",
		"expression", "booleanExpression", "predicate_", "valueExpression",
		"primaryExpression", "jsonPathInvocation", "jsonValueExpression", "jsonRepresentation",
		"jsonArgument", "jsonExistsErrorBehavior", "jsonValueBehavior", "jsonQueryWrapperBehavior",
		"jsonQueryBehavior", "jsonObjectMember", "processingMode", "nullTreatment",
		"string_", "timeZoneSpecifier", "comparisonOperator", "comparisonQuantifier",
		"booleanValue", "interval", "intervalField", "normalForm", "type", "rowField",
		"typeParameter", "whenClause", "filter", "mergeCase", "over", "windowFrame",
		"frameExtent", "frameBound", "rowPattern", "patternPrimary", "patternQuantifier",
		"updateAssignment", "explainOption", "transactionMode", "levelOfIsolation",
		"callArgument", "pathElement", "pathSpecification", "functionSpecification",
		"functionDeclaration", "parameterDeclaration", "returnsClause", "routineCharacteristic",
		"controlStatement", "caseStatementWhenClause", "elseIfClause", "elseClause",
		"variableDeclaration", "sqlStatementList", "privilege", "qualifiedName",
		"queryPeriod", "rangeType", "grantor", "principal", "roles", "identifier",
		"number", "authorizationUser", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 340, 3278, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 1, 0, 5, 0,
		254, 8, 0, 10, 0, 12, 0, 257, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 3, 1, 267, 8, 1, 1, 1, 3, 1, 270, 8, 1, 1, 2, 1, 2, 1, 2, 1,
		3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1,
		7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 303, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3,
		8, 310, 8, 8, 1, 8, 1, 8, 3, 8, 314, 8, 8, 1, 8, 1, 8, 3, 8, 318, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 324, 8, 8, 1, 8, 1, 8, 3, 8, 328, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 335, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 340,
		8, 8, 1, 8, 1, 8, 3, 8, 344, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 350, 8,
		8, 1, 8, 1, 8, 3, 8, 354, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 373,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 379, 8, 8, 1, 8, 1, 8, 3, 8, 383, 8,
		8, 1, 8, 1, 8, 3, 8, 387, 8, 8, 1, 8, 1, 8, 3, 8, 391, 8, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 399, 8, 8, 1, 8, 1, 8, 3, 8, 403, 8, 8, 1,
		8, 3, 8, 406, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 411, 8, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 417, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 424, 8, 8, 10,
		8, 12, 8, 427, 9, 8, 1, 8, 1, 8, 1, 8, 3, 8, 432, 8, 8, 1, 8, 1, 8, 3,
		8, 436, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 442, 8, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 449, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 458, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 470, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8,
		479, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 488, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 494, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 505, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 513, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 521, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 528, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 538, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 545, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 553, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 587, 8, 8, 10, 8, 12,
		8, 590, 9, 8, 3, 8, 592, 8, 8, 1, 8, 3, 8, 595, 8, 8, 1, 8, 1, 8, 3, 8,
		599, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 605, 8, 8, 1, 8, 1, 8, 1, 8, 3,
		8, 610, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 617, 8, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 623, 8, 8, 1, 8, 1, 8, 3, 8, 627, 8, 8, 1, 8, 1, 8, 3,
		8, 631, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 639, 8, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 3, 8, 645, 8, 8, 1, 8, 1, 8, 3, 8, 649, 8, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 663,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 671, 8, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 3, 8, 690, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 5, 8, 713, 8, 8, 10, 8, 12, 8, 716, 9, 8, 3, 8, 718,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 725, 8, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 732, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 741, 8, 8, 1, 8, 1, 8, 3, 8, 745, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 752, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 760, 8, 8,
		10, 8, 12, 8, 763, 9, 8, 1, 8, 1, 8, 1, 8, 3, 8, 768, 8, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 773, 8, 8, 1, 8, 1, 8, 3, 8, 777, 8, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 783, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 790, 8, 8, 10,
		8, 12, 8, 793, 9, 8, 1, 8, 1, 8, 1, 8, 3, 8, 798, 8, 8, 1, 8, 1, 8, 3,
		8, 802, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 809, 8, 8, 1, 8, 1, 8,
		3, 8, 813, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 819, 8, 8, 10, 8, 12, 8,
		822, 9, 8, 1, 8, 1, 8, 3, 8, 826, 8, 8, 1, 8, 1, 8, 3, 8, 830, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 838, 8, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 5, 8, 844, 8, 8, 10, 8, 12, 8, 847, 9, 8, 1, 8, 1, 8, 3, 8, 851, 8,
		8, 1, 8, 1, 8, 3, 8, 855, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 3, 8, 865, 8, 8, 1, 8, 1, 8, 1, 8, 5, 8, 870, 8, 8, 10, 8, 12,
		8, 873, 9, 8, 1, 8, 1, 8, 3, 8, 877, 8, 8, 1, 8, 1, 8, 3, 8, 881, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 891, 8, 8, 1, 8,
		3, 8, 894, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 901, 8, 8, 10, 8,
		12, 8, 904, 9, 8, 1, 8, 1, 8, 3, 8, 908, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 914, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 938, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 944, 8, 8, 3, 8, 946,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 952, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 958, 8, 8, 3, 8, 960, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3,
		8, 968, 8, 8, 3, 8, 970, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 976, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 982, 8, 8, 3, 8, 984, 8, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 999,
		8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1004, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 1011, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8,
		1021, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1027, 8, 8, 3, 8, 1029, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1037, 8, 8, 3, 8, 1039, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 1062, 8, 8,
		10, 8, 12, 8, 1065, 9, 8, 3, 8, 1067, 8, 8, 1, 8, 1, 8, 3, 8, 1071, 8,
		8, 1, 8, 1, 8, 3, 8, 1075, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 1091, 8, 8, 10, 8, 12,
		8, 1094, 9, 8, 3, 8, 1096, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 5, 8, 1105, 8, 8, 10, 8, 12, 8, 1108, 9, 8, 3, 8, 1110, 8, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 1126, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 1134,
		8, 8, 10, 8, 12, 8, 1137, 9, 8, 1, 8, 1, 8, 3, 8, 1141, 8, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 3, 8, 1147, 8, 8, 1, 8, 3, 8, 1150, 8, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 4, 8, 1157, 8, 8, 11, 8, 12, 8, 1158, 3, 8, 1161, 8, 8,
		1, 9, 3, 9, 1164, 8, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10,
		1172, 8, 10, 10, 10, 12, 10, 1175, 9, 10, 1, 11, 3, 11, 1178, 8, 11, 1,
		11, 1, 11, 1, 12, 1, 12, 3, 12, 1184, 8, 12, 1, 12, 1, 12, 1, 12, 5, 12,
		1189, 8, 12, 10, 12, 12, 12, 1192, 9, 12, 1, 13, 1, 13, 3, 13, 1196, 8,
		13, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1202, 8, 14, 1, 14, 1, 14, 3, 14,
		1206, 8, 14, 1, 14, 1, 14, 3, 14, 1210, 8, 14, 1, 15, 1, 15, 1, 15, 1,
		15, 3, 15, 1216, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17,
		5, 17, 1225, 8, 17, 10, 17, 12, 17, 1228, 9, 17, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 19, 1, 19, 3, 19, 1236, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 5, 20, 1244, 8, 20, 10, 20, 12, 20, 1247, 9, 20, 3, 20, 1249, 8,
		20, 1, 20, 1, 20, 1, 20, 3, 20, 1254, 8, 20, 3, 20, 1256, 8, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1263, 8, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 3, 20, 1269, 8, 20, 3, 20, 1271, 8, 20, 1, 21, 1, 21, 3, 21, 1275,
		8, 21, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 1285,
		8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 1291, 8, 23, 1, 23, 5, 23, 1294,
		8, 23, 10, 23, 12, 23, 1297, 9, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 5, 24, 1306, 8, 24, 10, 24, 12, 24, 1309, 9, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 3, 24, 1315, 8, 24, 1, 25, 1, 25, 3, 25, 1319, 8, 25,
		1, 25, 1, 25, 3, 25, 1323, 8, 25, 1, 26, 1, 26, 3, 26, 1327, 8, 26, 1,
		26, 1, 26, 1, 26, 5, 26, 1332, 8, 26, 10, 26, 12, 26, 1335, 9, 26, 1, 26,
		1, 26, 1, 26, 1, 26, 5, 26, 1341, 8, 26, 10, 26, 12, 26, 1344, 9, 26, 3,
		26, 1346, 8, 26, 1, 26, 1, 26, 3, 26, 1350, 8, 26, 1, 26, 1, 26, 1, 26,
		3, 26, 1355, 8, 26, 1, 26, 1, 26, 3, 26, 1359, 8, 26, 1, 26, 1, 26, 1,
		26, 1, 26, 5, 26, 1365, 8, 26, 10, 26, 12, 26, 1368, 9, 26, 3, 26, 1370,
		8, 26, 1, 27, 3, 27, 1373, 8, 27, 1, 27, 1, 27, 1, 27, 5, 27, 1378, 8,
		27, 10, 27, 12, 27, 1381, 9, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 5, 28, 1389, 8, 28, 10, 28, 12, 28, 1392, 9, 28, 3, 28, 1394, 8, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 5, 28, 1402, 8, 28, 10, 28, 12,
		28, 1405, 9, 28, 3, 28, 1407, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 5, 28, 1416, 8, 28, 10, 28, 12, 28, 1419, 9, 28, 1, 28, 1,
		28, 3, 28, 1423, 8, 28, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 1429, 8, 29,
		10, 29, 12, 29, 1432, 9, 29, 3, 29, 1434, 8, 29, 1, 29, 1, 29, 3, 29, 1438,
		8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 31, 3, 31, 1447, 8,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 1454, 8, 31, 10, 31, 12,
		31, 1457, 9, 31, 3, 31, 1459, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		5, 31, 1466, 8, 31, 10, 31, 12, 31, 1469, 9, 31, 3, 31, 1471, 8, 31, 1,
		31, 3, 31, 1474, 8, 31, 1, 32, 1, 32, 3, 32, 1478, 8, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 3, 34, 1489, 8, 34, 1,
		34, 3, 34, 1492, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 1499,
		8, 34, 1, 34, 3, 34, 1502, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 3, 35, 1521, 8, 35, 5, 35, 1523, 8, 35, 10, 35, 12, 35, 1526, 9,
		35, 1, 36, 3, 36, 1529, 8, 36, 1, 36, 1, 36, 3, 36, 1533, 8, 36, 3, 36,
		1535, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 1544,
		8, 37, 10, 37, 12, 37, 1547, 9, 37, 1, 37, 1, 37, 3, 37, 1551, 8, 37, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1560, 8, 38, 1, 39,
		1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 3, 41, 1569, 8, 41, 1, 41, 3,
		41, 1572, 8, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 5, 43, 1585, 8, 43, 10, 43, 12, 43, 1588, 9, 43, 3,
		43, 1590, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 1597, 8, 43,
		10, 43, 12, 43, 1600, 9, 43, 3, 43, 1602, 8, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 5, 43, 1608, 8, 43, 10, 43, 12, 43, 1611, 9, 43, 3, 43, 1613, 8, 43,
		1, 43, 3, 43, 1616, 8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1621, 8, 43, 1,
		43, 3, 43, 1624, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 5, 43, 1634, 8, 43, 10, 43, 12, 43, 1637, 9, 43, 3, 43, 1639, 8,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 1645, 8, 43, 10, 43, 12, 43, 1648,
		9, 43, 1, 43, 1, 43, 3, 43, 1652, 8, 43, 1, 43, 1, 43, 3, 43, 1656, 8,
		43, 3, 43, 1658, 8, 43, 3, 43, 1660, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1675,
		8, 45, 3, 45, 1677, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 3, 46, 1688, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		3, 47, 1695, 8, 47, 1, 47, 3, 47, 1698, 8, 47, 1, 47, 1, 47, 1, 47, 3,
		47, 1703, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 1711,
		8, 48, 10, 48, 12, 48, 1714, 9, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 50, 1, 50, 3, 50, 1724, 8, 50, 1, 50, 1, 50, 3, 50, 1728, 8,
		50, 3, 50, 1730, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 1736, 8, 51,
		10, 51, 12, 51, 1739, 9, 51, 1, 51, 1, 51, 1, 52, 1, 52, 3, 52, 1745, 8,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52,
		1756, 8, 52, 10, 52, 12, 52, 1759, 9, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1764,
		8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1780, 8, 52, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 5, 53, 1787, 8, 53, 10, 53, 12, 53, 1790, 9, 53, 3, 53, 1792,
		8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 1798, 8, 53, 10, 53, 12, 53,
		1801, 9, 53, 3, 53, 1803, 8, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 3,
		54, 1810, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1815, 8, 54, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 5, 55, 1824, 8, 55, 10, 55, 12, 55,
		1827, 9, 55, 3, 55, 1829, 8, 55, 1, 55, 1, 55, 3, 55, 1833, 8, 55, 3, 55,
		1835, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1843, 8,
		55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 5, 55, 1851, 8, 55, 10, 55,
		12, 55, 1854, 9, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1859, 8, 55, 3, 55, 1861,
		8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1868, 8, 56, 1, 56, 1,
		56, 3, 56, 1872, 8, 56, 3, 56, 1874, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 1881, 8, 56, 1, 56, 1, 56, 3, 56, 1885, 8, 56, 3, 56, 1887,
		8, 56, 3, 56, 1889, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57, 1896,
		8, 57, 10, 57, 12, 57, 1899, 9, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 3, 57, 1909, 8, 57, 1, 58, 1, 58, 3, 58, 1913, 8,
		58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 1921, 8, 59, 10, 59,
		12, 59, 1924, 9, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 3,
		61, 1933, 8, 61, 1, 61, 1, 61, 3, 61, 1937, 8, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 5, 61, 1945, 8, 61, 10, 61, 12, 61, 1948, 9, 61, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62,
		1960, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1968, 8,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 1975, 8, 62, 10, 62, 12,
		62, 1978, 9, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1983, 8, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1991, 8, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 3, 62, 1997, 8, 62, 1, 62, 1, 62, 3, 62, 2001, 8, 62, 1, 62, 1, 62,
		1, 62, 3, 62, 2006, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2011, 8, 62, 1,
		63, 1, 63, 1, 63, 1, 63, 3, 63, 2017, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63, 2031, 8,
		63, 10, 63, 12, 63, 2034, 9, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 4, 64, 2061,
		8, 64, 11, 64, 12, 64, 2062, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 5, 64, 2072, 8, 64, 10, 64, 12, 64, 2075, 9, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 3, 64, 2082, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2087,
		8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2092, 8, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 2103, 8, 64, 10, 64, 12,
		64, 2106, 9, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2111, 8, 64, 1, 64, 3, 64,
		2114, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2121, 8, 64, 1,
		64, 1, 64, 1, 64, 3, 64, 2126, 8, 64, 1, 64, 3, 64, 2129, 8, 64, 1, 64,
		3, 64, 2132, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2137, 8, 64, 1, 64, 1,
		64, 1, 64, 5, 64, 2142, 8, 64, 10, 64, 12, 64, 2145, 9, 64, 3, 64, 2147,
		8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 2154, 8, 64, 10, 64, 12,
		64, 2157, 9, 64, 3, 64, 2159, 8, 64, 1, 64, 1, 64, 3, 64, 2163, 8, 64,
		1, 64, 3, 64, 2166, 8, 64, 1, 64, 3, 64, 2169, 8, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 2182,
		8, 64, 10, 64, 12, 64, 2185, 9, 64, 3, 64, 2187, 8, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 4, 64, 2204, 8, 64, 11, 64, 12, 64, 2205, 1, 64, 1, 64, 3,
		64, 2210, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 4, 64, 2216, 8, 64, 11, 64,
		12, 64, 2217, 1, 64, 1, 64, 3, 64, 2222, 8, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 2245, 8, 64, 10,
		64, 12, 64, 2248, 9, 64, 3, 64, 2250, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 3, 64, 2259, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3,
		64, 2265, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2271, 8, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 3, 64, 2277, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 3, 64, 2286, 8, 64, 1, 64, 3, 64, 2289, 8, 64, 1, 64,
		3, 64, 2292, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64,
		2311, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2320,
		8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 2340,
		8, 64, 10, 64, 12, 64, 2343, 9, 64, 3, 64, 2345, 8, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2355, 8, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2364, 8, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 3, 64, 2370, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2376,
		8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3,
		64, 2387, 8, 64, 3, 64, 2389, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2394,
		8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2401, 8, 64, 3, 64, 2403,
		8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2409, 8, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 3, 64, 2415, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 5, 64, 2424, 8, 64, 10, 64, 12, 64, 2427, 9, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 3, 64, 2435, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64,
		2440, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2445, 8, 64, 3, 64, 2447, 8, 64,
		3, 64, 2449, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2455, 8, 64, 3,
		64, 2457, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 2465,
		8, 64, 10, 64, 12, 64, 2468, 9, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 3, 64, 2476, 8, 64, 3, 64, 2478, 8, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 3, 64, 2484, 8, 64, 3, 64, 2486, 8, 64, 1, 64, 3, 64, 2489, 8, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 2499, 8,
		64, 10, 64, 12, 64, 2502, 9, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 5, 65, 2511, 8, 65, 10, 65, 12, 65, 2514, 9, 65, 3, 65, 2516,
		8, 65, 1, 66, 1, 66, 1, 66, 3, 66, 2521, 8, 66, 1, 67, 1, 67, 1, 67, 3,
		67, 2526, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70,
		1, 70, 1, 70, 3, 70, 2538, 8, 70, 1, 71, 1, 71, 3, 71, 2542, 8, 71, 1,
		71, 1, 71, 3, 71, 2546, 8, 71, 1, 71, 3, 71, 2549, 8, 71, 3, 71, 2551,
		8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2557, 8, 72, 1, 73, 3, 73, 2560,
		8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2570,
		8, 73, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2578, 8, 75, 1,
		76, 1, 76, 1, 76, 1, 76, 3, 76, 2584, 8, 76, 3, 76, 2586, 8, 76, 1, 77,
		1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 2594, 8, 77, 1, 78, 1, 78, 1,
		79, 1, 79, 1, 80, 1, 80, 1, 81, 1, 81, 3, 81, 2604, 8, 81, 1, 81, 1, 81,
		1, 81, 1, 81, 3, 81, 2610, 8, 81, 1, 82, 1, 82, 1, 83, 1, 83, 1, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 2622, 8, 84, 10, 84, 12, 84, 2625,
		9, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 2633, 8, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 2640, 8, 84, 1, 84, 1, 84, 1, 84,
		3, 84, 2645, 8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 2652, 8,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 2662,
		8, 84, 1, 84, 1, 84, 1, 84, 3, 84, 2667, 8, 84, 1, 84, 1, 84, 1, 84, 1,
		84, 1, 84, 3, 84, 2674, 8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 2698, 8, 84, 10, 84, 12,
		84, 2701, 9, 84, 1, 84, 1, 84, 3, 84, 2705, 8, 84, 3, 84, 2707, 8, 84,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 2714, 8, 84, 5, 84, 2716, 8,
		84, 10, 84, 12, 84, 2719, 9, 84, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 2725,
		8, 85, 1, 86, 1, 86, 3, 86, 2729, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1,
		87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89,
		3, 89, 2746, 8, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 5, 89, 2759, 8, 89, 10, 89, 12, 89, 2762, 9, 89,
		1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 2768, 8, 89, 1, 89, 1, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 3, 89, 2777, 8, 89, 1, 89, 1, 89, 1, 89, 1, 89,
		1, 89, 1, 89, 5, 89, 2785, 8, 89, 10, 89, 12, 89, 2788, 9, 89, 1, 89, 1,
		89, 3, 89, 2792, 8, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 2799,
		8, 89, 10, 89, 12, 89, 2802, 9, 89, 1, 89, 1, 89, 3, 89, 2806, 8, 89, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 2814, 8, 90, 1, 91, 1, 91,
		1, 91, 1, 91, 5, 91, 2820, 8, 91, 10, 91, 12, 91, 2823, 9, 91, 3, 91, 2825,
		8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 2831, 8, 91, 1, 91, 3, 91, 2834,
		8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 2841, 8, 91, 1, 91, 1,
		91, 1, 91, 1, 91, 5, 91, 2847, 8, 91, 10, 91, 12, 91, 2850, 9, 91, 3, 91,
		2852, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 5, 91, 2858, 8, 91, 10, 91, 12,
		91, 2861, 9, 91, 3, 91, 2863, 8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 2889,
		8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3,
		93, 2900, 8, 93, 1, 94, 1, 94, 1, 94, 3, 94, 2905, 8, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 5, 94, 2912, 8, 94, 10, 94, 12, 94, 2915, 9, 94, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 5, 95, 2925, 8, 95,
		10, 95, 12, 95, 2928, 9, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95,
		1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 2942, 8, 95, 1, 96, 1,
		96, 3, 96, 2946, 8, 96, 1, 96, 1, 96, 3, 96, 2950, 8, 96, 1, 96, 1, 96,
		3, 96, 2954, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 2960, 8, 96, 1,
		96, 1, 96, 3, 96, 2964, 8, 96, 1, 96, 1, 96, 3, 96, 2968, 8, 96, 1, 96,
		1, 96, 3, 96, 2972, 8, 96, 3, 96, 2974, 8, 96, 1, 97, 1, 97, 1, 97, 1,
		97, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 2984, 8, 98, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 3, 99, 2991, 8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 3, 100, 3000, 8, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 3, 101, 3007, 8, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102,
		3014, 8, 102, 1, 103, 1, 103, 1, 103, 5, 103, 3019, 8, 103, 10, 103, 12,
		103, 3022, 9, 103, 1, 104, 1, 104, 1, 104, 1, 104, 5, 104, 3028, 8, 104,
		10, 104, 12, 104, 3031, 9, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 5, 105, 3040, 8, 105, 10, 105, 12, 105, 3043, 9, 105, 3,
		105, 3045, 8, 105, 1, 105, 1, 105, 1, 106, 3, 106, 3050, 8, 106, 1, 106,
		1, 106, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 3, 108, 3060, 8,
		108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1,
		108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3076, 8, 108, 1, 109,
		1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109,
		4, 109, 3088, 8, 109, 11, 109, 12, 109, 3089, 1, 109, 3, 109, 3093, 8,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 4, 109, 3100, 8, 109, 11,
		109, 12, 109, 3101, 1, 109, 3, 109, 3105, 8, 109, 1, 109, 1, 109, 1, 109,
		1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 5, 109, 3115, 8, 109, 10, 109,
		12, 109, 3118, 9, 109, 1, 109, 3, 109, 3121, 8, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 5,
		109, 3134, 8, 109, 10, 109, 12, 109, 3137, 9, 109, 1, 109, 3, 109, 3140,
		8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 3146, 8, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 3156, 8, 109,
		1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109,
		1, 109, 3, 109, 3168, 8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 3, 109, 3177, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110,
		1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 1, 113,
		1, 113, 1, 113, 1, 113, 5, 113, 3196, 8, 113, 10, 113, 12, 113, 3199, 9,
		113, 1, 113, 1, 113, 1, 113, 3, 113, 3204, 8, 113, 1, 114, 1, 114, 1, 114,
		4, 114, 3209, 8, 114, 11, 114, 12, 114, 3210, 1, 115, 1, 115, 1, 116, 1,
		116, 1, 116, 5, 116, 3218, 8, 116, 10, 116, 12, 116, 3221, 9, 116, 1, 117,
		1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 119, 1, 119,
		1, 119, 3, 119, 3234, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3,
		120, 3241, 8, 120, 1, 121, 1, 121, 1, 121, 5, 121, 3246, 8, 121, 10, 121,
		12, 121, 3249, 9, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122,
		3256, 8, 122, 1, 123, 3, 123, 3259, 8, 123, 1, 123, 1, 123, 3, 123, 3263,
		8, 123, 1, 123, 1, 123, 3, 123, 3267, 8, 123, 1, 123, 3, 123, 3270, 8,
		123, 1, 124, 1, 124, 3, 124, 3274, 8, 124, 1, 125, 1, 125, 1, 125, 0, 7,
		46, 70, 122, 126, 128, 168, 188, 126, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,
		20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
		56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
		92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
		212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
		242, 244, 246, 248, 250, 0, 37, 2, 0, 22, 22, 212, 212, 2, 0, 55, 55, 114,
		114, 2, 0, 226, 226, 244, 244, 2, 0, 88, 88, 105, 105, 2, 0, 75, 75, 106,
		106, 1, 0, 222, 223, 2, 0, 84, 84, 157, 157, 2, 0, 308, 308, 330, 330,
		2, 0, 74, 74, 265, 265, 2, 0, 12, 12, 58, 58, 2, 0, 84, 84, 131, 131, 2,
		0, 5, 5, 62, 62, 3, 0, 89, 89, 135, 135, 217, 217, 2, 0, 16, 16, 243, 243,
		3, 0, 18, 18, 133, 133, 254, 254, 2, 0, 288, 288, 290, 290, 2, 0, 107,
		107, 230, 230, 1, 0, 302, 303, 1, 0, 304, 306, 2, 0, 127, 127, 172, 172,
		1, 0, 275, 277, 4, 0, 72, 72, 80, 80, 257, 257, 267, 267, 2, 0, 32, 32,
		264, 264, 2, 0, 10, 10, 169, 169, 2, 0, 83, 83, 224, 224, 1, 0, 296, 301,
		3, 0, 5, 5, 9, 9, 238, 238, 2, 0, 80, 80, 257, 257, 5, 0, 50, 50, 101,
		101, 153, 154, 228, 228, 294, 294, 1, 0, 158, 161, 2, 0, 85, 85, 195, 195,
		3, 0, 96, 96, 120, 120, 247, 247, 4, 0, 63, 63, 115, 115, 143, 143, 278,
		278, 2, 0, 175, 175, 293, 293, 5, 0, 36, 36, 56, 56, 110, 110, 231, 231,
		271, 271, 2, 0, 252, 252, 282, 282, 55, 0, 1, 5, 7, 7, 9, 10, 12, 16, 18,
		18, 20, 22, 25, 32, 34, 35, 39, 39, 48, 50, 52, 55, 57, 58, 60, 61, 63,
		65, 68, 70, 72, 72, 75, 75, 78, 78, 81, 85, 87, 87, 90, 96, 99, 99, 101,
		104, 106, 107, 109, 109, 112, 112, 114, 115, 117, 118, 120, 120, 127, 134,
		136, 136, 138, 138, 140, 140, 143, 154, 156, 163, 167, 172, 174, 176, 179,
		179, 181, 196, 198, 203, 205, 216, 218, 220, 222, 230, 232, 236, 238, 243,
		245, 248, 250, 255, 258, 260, 262, 264, 266, 268, 270, 273, 275, 279, 281,
		283, 286, 287, 289, 295, 3787, 0, 255, 1, 0, 0, 0, 2, 269, 1, 0, 0, 0,
		4, 271, 1, 0, 0, 0, 6, 274, 1, 0, 0, 0, 8, 277, 1, 0, 0, 0, 10, 280, 1,
		0, 0, 0, 12, 283, 1, 0, 0, 0, 14, 286, 1, 0, 0, 0, 16, 1160, 1, 0, 0, 0,
		18, 1163, 1, 0, 0, 0, 20, 1167, 1, 0, 0, 0, 22, 1177, 1, 0, 0, 0, 24, 1181,
		1, 0, 0, 0, 26, 1195, 1, 0, 0, 0, 28, 1197, 1, 0, 0, 0, 30, 1211, 1, 0,
		0, 0, 32, 1217, 1, 0, 0, 0, 34, 1221, 1, 0, 0, 0, 36, 1229, 1, 0, 0, 0,
		38, 1235, 1, 0, 0, 0, 40, 1237, 1, 0, 0, 0, 42, 1274, 1, 0, 0, 0, 44, 1276,
		1, 0, 0, 0, 46, 1278, 1, 0, 0, 0, 48, 1314, 1, 0, 0, 0, 50, 1316, 1, 0,
		0, 0, 52, 1324, 1, 0, 0, 0, 54, 1372, 1, 0, 0, 0, 56, 1422, 1, 0, 0, 0,
		58, 1437, 1, 0, 0, 0, 60, 1439, 1, 0, 0, 0, 62, 1446, 1, 0, 0, 0, 64, 1475,
		1, 0, 0, 0, 66, 1484, 1, 0, 0, 0, 68, 1501, 1, 0, 0, 0, 70, 1503, 1, 0,
		0, 0, 72, 1534, 1, 0, 0, 0, 74, 1550, 1, 0, 0, 0, 76, 1552, 1, 0, 0, 0,
		78, 1561, 1, 0, 0, 0, 80, 1563, 1, 0, 0, 0, 82, 1571, 1, 0, 0, 0, 84, 1573,
		1, 0, 0, 0, 86, 1576, 1, 0, 0, 0, 88, 1661, 1, 0, 0, 0, 90, 1676, 1, 0,
		0, 0, 92, 1687, 1, 0, 0, 0, 94, 1689, 1, 0, 0, 0, 96, 1704, 1, 0, 0, 0,
		98, 1717, 1, 0, 0, 0, 100, 1721, 1, 0, 0, 0, 102, 1731, 1, 0, 0, 0, 104,
		1779, 1, 0, 0, 0, 106, 1781, 1, 0, 0, 0, 108, 1809, 1, 0, 0, 0, 110, 1816,
		1, 0, 0, 0, 112, 1888, 1, 0, 0, 0, 114, 1908, 1, 0, 0, 0, 116, 1910, 1,
		0, 0, 0, 118, 1914, 1, 0, 0, 0, 120, 1927, 1, 0, 0, 0, 122, 1936, 1, 0,
		0, 0, 124, 2010, 1, 0, 0, 0, 126, 2016, 1, 0, 0, 0, 128, 2488, 1, 0, 0,
		0, 130, 2503, 1, 0, 0, 0, 132, 2517, 1, 0, 0, 0, 134, 2522, 1, 0, 0, 0,
		136, 2527, 1, 0, 0, 0, 138, 2531, 1, 0, 0, 0, 140, 2537, 1, 0, 0, 0, 142,
		2550, 1, 0, 0, 0, 144, 2556, 1, 0, 0, 0, 146, 2569, 1, 0, 0, 0, 148, 2571,
		1, 0, 0, 0, 150, 2577, 1, 0, 0, 0, 152, 2585, 1, 0, 0, 0, 154, 2593, 1,
		0, 0, 0, 156, 2595, 1, 0, 0, 0, 158, 2597, 1, 0, 0, 0, 160, 2599, 1, 0,
		0, 0, 162, 2601, 1, 0, 0, 0, 164, 2611, 1, 0, 0, 0, 166, 2613, 1, 0, 0,
		0, 168, 2706, 1, 0, 0, 0, 170, 2724, 1, 0, 0, 0, 172, 2728, 1, 0, 0, 0,
		174, 2730, 1, 0, 0, 0, 176, 2735, 1, 0, 0, 0, 178, 2805, 1, 0, 0, 0, 180,
		2807, 1, 0, 0, 0, 182, 2824, 1, 0, 0, 0, 184, 2888, 1, 0, 0, 0, 186, 2899,
		1, 0, 0, 0, 188, 2901, 1, 0, 0, 0, 190, 2941, 1, 0, 0, 0, 192, 2973, 1,
		0, 0, 0, 194, 2975, 1, 0, 0, 0, 196, 2983, 1, 0, 0, 0, 198, 2990, 1, 0,
		0, 0, 200, 2999, 1, 0, 0, 0, 202, 3006, 1, 0, 0, 0, 204, 3013, 1, 0, 0,
		0, 206, 3015, 1, 0, 0, 0, 208, 3023, 1, 0, 0, 0, 210, 3034, 1, 0, 0, 0,
		212, 3049, 1, 0, 0, 0, 214, 3053, 1, 0, 0, 0, 216, 3075, 1, 0, 0, 0, 218,
		3176, 1, 0, 0, 0, 220, 3178, 1, 0, 0, 0, 222, 3183, 1, 0, 0, 0, 224, 3188,
		1, 0, 0, 0, 226, 3191, 1, 0, 0, 0, 228, 3208, 1, 0, 0, 0, 230, 3212, 1,
		0, 0, 0, 232, 3214, 1, 0, 0, 0, 234, 3222, 1, 0, 0, 0, 236, 3228, 1, 0,
		0, 0, 238, 3233, 1, 0, 0, 0, 240, 3240, 1, 0, 0, 0, 242, 3242, 1, 0, 0,
		0, 244, 3255, 1, 0, 0, 0, 246, 3269, 1, 0, 0, 0, 248, 3273, 1, 0, 0, 0,
		250, 3275, 1, 0, 0, 0, 252, 254, 3, 2, 1, 0, 253, 252, 1, 0, 0, 0, 254,
		257, 1, 0, 0, 0, 255, 253, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0, 256, 258,
		1, 0, 0, 0, 257, 255, 1, 0, 0, 0, 258, 259, 5, 0, 0, 1, 259, 1, 1, 0, 0,
		0, 260, 270, 3, 4, 2, 0, 261, 270, 3, 6, 3, 0, 262, 270, 3, 8, 4, 0, 263,
		270, 3, 10, 5, 0, 264, 266, 3, 12, 6, 0, 265, 267, 5, 309, 0, 0, 266, 265,
		1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 270, 1, 0, 0, 0, 268, 270, 3, 14,
		7, 0, 269, 260, 1, 0, 0, 0, 269, 261, 1, 0, 0, 0, 269, 262, 1, 0, 0, 0,
		269, 263, 1, 0, 0, 0, 269, 264, 1, 0, 0, 0, 269, 268, 1, 0, 0, 0, 270,
		3, 1, 0, 0, 0, 271, 272, 3, 16, 8, 0, 272, 273, 5, 309, 0, 0, 273, 5, 1,
		0, 0, 0, 274, 275, 3, 120, 60, 0, 275, 276, 5, 309, 0, 0, 276, 7, 1, 0,
		0, 0, 277, 278, 3, 206, 103, 0, 278, 279, 5, 309, 0, 0, 279, 9, 1, 0, 0,
		0, 280, 281, 3, 168, 84, 0, 281, 282, 5, 309, 0, 0, 282, 11, 1, 0, 0, 0,
		283, 284, 3, 188, 94, 0, 284, 285, 5, 309, 0, 0, 285, 13, 1, 0, 0, 0, 286,
		287, 3, 208, 104, 0, 287, 288, 5, 309, 0, 0, 288, 15, 1, 0, 0, 0, 289,
		1161, 3, 18, 9, 0, 290, 291, 5, 272, 0, 0, 291, 1161, 3, 244, 122, 0, 292,
		293, 5, 272, 0, 0, 293, 294, 3, 244, 122, 0, 294, 295, 5, 310, 0, 0, 295,
		296, 3, 244, 122, 0, 296, 1161, 1, 0, 0, 0, 297, 298, 5, 36, 0, 0, 298,
		302, 5, 25, 0, 0, 299, 300, 5, 102, 0, 0, 300, 301, 5, 165, 0, 0, 301,
		303, 5, 77, 0, 0, 302, 299, 1, 0, 0, 0, 302, 303, 1, 0, 0, 0, 303, 304,
		1, 0, 0, 0, 304, 305, 3, 244, 122, 0, 305, 306, 5, 274, 0, 0, 306, 309,
		3, 244, 122, 0, 307, 308, 5, 29, 0, 0, 308, 310, 3, 152, 76, 0, 309, 307,
		1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310, 313, 1, 0, 0, 0, 311, 312, 5, 14,
		0, 0, 312, 314, 3, 240, 120, 0, 313, 311, 1, 0, 0, 0, 313, 314, 1, 0, 0,
		0, 314, 317, 1, 0, 0, 0, 315, 316, 5, 288, 0, 0, 316, 318, 3, 32, 16, 0,
		317, 315, 1, 0, 0, 0, 317, 318, 1, 0, 0, 0, 318, 1161, 1, 0, 0, 0, 319,
		320, 5, 66, 0, 0, 320, 323, 5, 25, 0, 0, 321, 322, 5, 102, 0, 0, 322, 324,
		5, 77, 0, 0, 323, 321, 1, 0, 0, 0, 323, 324, 1, 0, 0, 0, 324, 325, 1, 0,
		0, 0, 325, 327, 3, 244, 122, 0, 326, 328, 7, 0, 0, 0, 327, 326, 1, 0, 0,
		0, 327, 328, 1, 0, 0, 0, 328, 1161, 1, 0, 0, 0, 329, 330, 5, 36, 0, 0,
		330, 334, 5, 226, 0, 0, 331, 332, 5, 102, 0, 0, 332, 333, 5, 165, 0, 0,
		333, 335, 5, 77, 0, 0, 334, 331, 1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335,
		336, 1, 0, 0, 0, 336, 339, 3, 232, 116, 0, 337, 338, 5, 14, 0, 0, 338,
		340, 3, 240, 120, 0, 339, 337, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 343,
		1, 0, 0, 0, 341, 342, 5, 288, 0, 0, 342, 344, 3, 32, 16, 0, 343, 341, 1,
		0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 1161, 1, 0, 0, 0, 345, 346, 5, 66,
		0, 0, 346, 349, 5, 226, 0, 0, 347, 348, 5, 102, 0, 0, 348, 350, 5, 77,
		0, 0, 349, 347, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0,
		351, 353, 3, 232, 116, 0, 352, 354, 7, 0, 0, 0, 353, 352, 1, 0, 0, 0, 353,
		354, 1, 0, 0, 0, 354, 1161, 1, 0, 0, 0, 355, 356, 5, 6, 0, 0, 356, 357,
		5, 226, 0, 0, 357, 358, 3, 232, 116, 0, 358, 359, 5, 206, 0, 0, 359, 360,
		5, 253, 0, 0, 360, 361, 3, 244, 122, 0, 361, 1161, 1, 0, 0, 0, 362, 363,
		5, 6, 0, 0, 363, 364, 5, 226, 0, 0, 364, 365, 3, 232, 116, 0, 365, 366,
		5, 234, 0, 0, 366, 367, 5, 14, 0, 0, 367, 368, 3, 240, 120, 0, 368, 1161,
		1, 0, 0, 0, 369, 372, 5, 36, 0, 0, 370, 371, 5, 177, 0, 0, 371, 373, 5,
		209, 0, 0, 372, 370, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 374, 1, 0,
		0, 0, 374, 378, 5, 244, 0, 0, 375, 376, 5, 102, 0, 0, 376, 377, 5, 165,
		0, 0, 377, 379, 5, 77, 0, 0, 378, 375, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0,
		379, 380, 1, 0, 0, 0, 380, 382, 3, 232, 116, 0, 381, 383, 3, 102, 51, 0,
		382, 381, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 386, 1, 0, 0, 0, 384,
		385, 5, 29, 0, 0, 385, 387, 3, 152, 76, 0, 386, 384, 1, 0, 0, 0, 386, 387,
		1, 0, 0, 0, 387, 390, 1, 0, 0, 0, 388, 389, 5, 288, 0, 0, 389, 391, 3,
		32, 16, 0, 390, 388, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 392, 1, 0,
		0, 0, 392, 398, 5, 11, 0, 0, 393, 399, 3, 18, 9, 0, 394, 395, 5, 313, 0,
		0, 395, 396, 3, 18, 9, 0, 396, 397, 5, 314, 0, 0, 397, 399, 1, 0, 0, 0,
		398, 393, 1, 0, 0, 0, 398, 394, 1, 0, 0, 0, 399, 405, 1, 0, 0, 0, 400,
		402, 5, 288, 0, 0, 401, 403, 5, 162, 0, 0, 402, 401, 1, 0, 0, 0, 402, 403,
		1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 406, 5, 48, 0, 0, 405, 400, 1, 0,
		0, 0, 405, 406, 1, 0, 0, 0, 406, 1161, 1, 0, 0, 0, 407, 410, 5, 36, 0,
		0, 408, 409, 5, 177, 0, 0, 409, 411, 5, 209, 0, 0, 410, 408, 1, 0, 0, 0,
		410, 411, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 416, 5, 244, 0, 0, 413,
		414, 5, 102, 0, 0, 414, 415, 5, 165, 0, 0, 415, 417, 5, 77, 0, 0, 416,
		413, 1, 0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 419,
		3, 232, 116, 0, 419, 420, 5, 313, 0, 0, 420, 425, 3, 26, 13, 0, 421, 422,
		5, 312, 0, 0, 422, 424, 3, 26, 13, 0, 423, 421, 1, 0, 0, 0, 424, 427, 1,
		0, 0, 0, 425, 423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 428, 1, 0, 0,
		0, 427, 425, 1, 0, 0, 0, 428, 431, 5, 314, 0, 0, 429, 430, 5, 29, 0, 0,
		430, 432, 3, 152, 76, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432,
		435, 1, 0, 0, 0, 433, 434, 5, 288, 0, 0, 434, 436, 3, 32, 16, 0, 435, 433,
		1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 1161, 1, 0, 0, 0, 437, 438, 5, 66,
		0, 0, 438, 441, 5, 244, 0, 0, 439, 440, 5, 102, 0, 0, 440, 442, 5, 77,
		0, 0, 441, 439, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 443, 1, 0, 0, 0,
		443, 1161, 3, 232, 116, 0, 444, 445, 5, 110, 0, 0, 445, 446, 5, 113, 0,
		0, 446, 448, 3, 232, 116, 0, 447, 449, 3, 102, 51, 0, 448, 447, 1, 0, 0,
		0, 448, 449, 1, 0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 451, 3, 18, 9, 0, 451,
		1161, 1, 0, 0, 0, 452, 453, 5, 56, 0, 0, 453, 454, 5, 88, 0, 0, 454, 457,
		3, 232, 116, 0, 455, 456, 5, 285, 0, 0, 456, 458, 3, 122, 61, 0, 457, 455,
		1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 1161, 1, 0, 0, 0, 459, 460, 5, 258,
		0, 0, 460, 461, 5, 244, 0, 0, 461, 1161, 3, 232, 116, 0, 462, 463, 5, 29,
		0, 0, 463, 464, 5, 173, 0, 0, 464, 465, 5, 244, 0, 0, 465, 466, 3, 232,
		116, 0, 466, 469, 5, 116, 0, 0, 467, 470, 3, 152, 76, 0, 468, 470, 5, 166,
		0, 0, 469, 467, 1, 0, 0, 0, 469, 468, 1, 0, 0, 0, 470, 1161, 1, 0, 0, 0,
		471, 472, 5, 29, 0, 0, 472, 473, 5, 173, 0, 0, 473, 474, 5, 283, 0, 0,
		474, 475, 3, 232, 116, 0, 475, 478, 5, 116, 0, 0, 476, 479, 3, 152, 76,
		0, 477, 479, 5, 166, 0, 0, 478, 476, 1, 0, 0, 0, 478, 477, 1, 0, 0, 0,
		479, 1161, 1, 0, 0, 0, 480, 481, 5, 29, 0, 0, 481, 482, 5, 173, 0, 0, 482,
		483, 5, 27, 0, 0, 483, 484, 3, 232, 116, 0, 484, 487, 5, 116, 0, 0, 485,
		488, 3, 152, 76, 0, 486, 488, 5, 166, 0, 0, 487, 485, 1, 0, 0, 0, 487,
		486, 1, 0, 0, 0, 488, 1161, 1, 0, 0, 0, 489, 490, 5, 6, 0, 0, 490, 493,
		5, 244, 0, 0, 491, 492, 5, 102, 0, 0, 492, 494, 5, 77, 0, 0, 493, 491,
		1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495, 496, 3, 232,
		116, 0, 496, 497, 5, 206, 0, 0, 497, 498, 5, 253, 0, 0, 498, 499, 3, 232,
		116, 0, 499, 1161, 1, 0, 0, 0, 500, 501, 5, 6, 0, 0, 501, 504, 5, 244,
		0, 0, 502, 503, 5, 102, 0, 0, 503, 505, 5, 77, 0, 0, 504, 502, 1, 0, 0,
		0, 504, 505, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 507, 3, 232, 116, 0,
		507, 508, 5, 2, 0, 0, 508, 512, 5, 27, 0, 0, 509, 510, 5, 102, 0, 0, 510,
		511, 5, 165, 0, 0, 511, 513, 5, 77, 0, 0, 512, 509, 1, 0, 0, 0, 512, 513,
		1, 0, 0, 0, 513, 514, 1, 0, 0, 0, 514, 515, 3, 28, 14, 0, 515, 1161, 1,
		0, 0, 0, 516, 517, 5, 6, 0, 0, 517, 520, 5, 244, 0, 0, 518, 519, 5, 102,
		0, 0, 519, 521, 5, 77, 0, 0, 520, 518, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0,
		521, 522, 1, 0, 0, 0, 522, 523, 3, 232, 116, 0, 523, 524, 5, 206, 0, 0,
		524, 527, 5, 27, 0, 0, 525, 526, 5, 102, 0, 0, 526, 528, 5, 77, 0, 0, 527,
		525, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 530,
		3, 232, 116, 0, 530, 531, 5, 253, 0, 0, 531, 532, 3, 244, 122, 0, 532,
		1161, 1, 0, 0, 0, 533, 534, 5, 6, 0, 0, 534, 537, 5, 244, 0, 0, 535, 536,
		5, 102, 0, 0, 536, 538, 5, 77, 0, 0, 537, 535, 1, 0, 0, 0, 537, 538, 1,
		0, 0, 0, 538, 539, 1, 0, 0, 0, 539, 540, 3, 232, 116, 0, 540, 541, 5, 66,
		0, 0, 541, 544, 5, 27, 0, 0, 542, 543, 5, 102, 0, 0, 543, 545, 5, 77, 0,
		0, 544, 542, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546,
		547, 3, 232, 116, 0, 547, 1161, 1, 0, 0, 0, 548, 549, 5, 6, 0, 0, 549,
		552, 5, 244, 0, 0, 550, 551, 5, 102, 0, 0, 551, 553, 5, 77, 0, 0, 552,
		550, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 555,
		3, 232, 116, 0, 555, 556, 5, 6, 0, 0, 556, 557, 5, 27, 0, 0, 557, 558,
		3, 232, 116, 0, 558, 559, 5, 234, 0, 0, 559, 560, 5, 48, 0, 0, 560, 561,
		5, 260, 0, 0, 561, 562, 3, 168, 84, 0, 562, 1161, 1, 0, 0, 0, 563, 564,
		5, 6, 0, 0, 564, 565, 5, 244, 0, 0, 565, 566, 3, 232, 116, 0, 566, 567,
		5, 234, 0, 0, 567, 568, 5, 14, 0, 0, 568, 569, 3, 240, 120, 0, 569, 1161,
		1, 0, 0, 0, 570, 571, 5, 6, 0, 0, 571, 572, 5, 244, 0, 0, 572, 573, 3,
		232, 116, 0, 573, 574, 5, 234, 0, 0, 574, 575, 5, 199, 0, 0, 575, 576,
		3, 34, 17, 0, 576, 1161, 1, 0, 0, 0, 577, 578, 5, 6, 0, 0, 578, 579, 5,
		244, 0, 0, 579, 580, 3, 232, 116, 0, 580, 581, 5, 76, 0, 0, 581, 594, 3,
		244, 122, 0, 582, 591, 5, 313, 0, 0, 583, 588, 3, 202, 101, 0, 584, 585,
		5, 312, 0, 0, 585, 587, 3, 202, 101, 0, 586, 584, 1, 0, 0, 0, 587, 590,
		1, 0, 0, 0, 588, 586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 592, 1, 0,
		0, 0, 590, 588, 1, 0, 0, 0, 591, 583, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0,
		592, 593, 1, 0, 0, 0, 593, 595, 5, 314, 0, 0, 594, 582, 1, 0, 0, 0, 594,
		595, 1, 0, 0, 0, 595, 598, 1, 0, 0, 0, 596, 597, 5, 285, 0, 0, 597, 599,
		3, 122, 61, 0, 598, 596, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 1161, 1,
		0, 0, 0, 600, 601, 5, 7, 0, 0, 601, 604, 3, 232, 116, 0, 602, 603, 5, 288,
		0, 0, 603, 605, 3, 32, 16, 0, 604, 602, 1, 0, 0, 0, 604, 605, 1, 0, 0,
		0, 605, 1161, 1, 0, 0, 0, 606, 609, 5, 36, 0, 0, 607, 608, 5, 177, 0, 0,
		608, 610, 5, 209, 0, 0, 609, 607, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0, 610,
		611, 1, 0, 0, 0, 611, 612, 5, 150, 0, 0, 612, 616, 5, 283, 0, 0, 613, 614,
		5, 102, 0, 0, 614, 615, 5, 165, 0, 0, 615, 617, 5, 77, 0, 0, 616, 613,
		1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 622, 3, 232,
		116, 0, 619, 620, 5, 92, 0, 0, 620, 621, 5, 191, 0, 0, 621, 623, 3, 162,
		81, 0, 622, 619, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 626, 1, 0, 0, 0,
		624, 625, 5, 29, 0, 0, 625, 627, 3, 152, 76, 0, 626, 624, 1, 0, 0, 0, 626,
		627, 1, 0, 0, 0, 627, 630, 1, 0, 0, 0, 628, 629, 5, 288, 0, 0, 629, 631,
		3, 32, 16, 0, 630, 628, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 632, 1,
		0, 0, 0, 632, 633, 5, 11, 0, 0, 633, 634, 3, 18, 9, 0, 634, 1161, 1, 0,
		0, 0, 635, 638, 5, 36, 0, 0, 636, 637, 5, 177, 0, 0, 637, 639, 5, 209,
		0, 0, 638, 636, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0,
		640, 641, 5, 283, 0, 0, 641, 644, 3, 232, 116, 0, 642, 643, 5, 29, 0, 0,
		643, 645, 3, 152, 76, 0, 644, 642, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645,
		648, 1, 0, 0, 0, 646, 647, 5, 229, 0, 0, 647, 649, 7, 1, 0, 0, 648, 646,
		1, 0, 0, 0, 648, 649, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 651, 5, 11,
		0, 0, 651, 652, 3, 18, 9, 0, 652, 1161, 1, 0, 0, 0, 653, 654, 5, 205, 0,
		0, 654, 655, 5, 150, 0, 0, 655, 656, 5, 283, 0, 0, 656, 1161, 3, 232, 116,
		0, 657, 658, 5, 66, 0, 0, 658, 659, 5, 150, 0, 0, 659, 662, 5, 283, 0,
		0, 660, 661, 5, 102, 0, 0, 661, 663, 5, 77, 0, 0, 662, 660, 1, 0, 0, 0,
		662, 663, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 1161, 3, 232, 116, 0,
		665, 666, 5, 6, 0, 0, 666, 667, 5, 150, 0, 0, 667, 670, 5, 283, 0, 0, 668,
		669, 5, 102, 0, 0, 669, 671, 5, 77, 0, 0, 670, 668, 1, 0, 0, 0, 670, 671,
		1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 3, 232, 116, 0, 673, 674, 5,
		206, 0, 0, 674, 675, 5, 253, 0, 0, 675, 676, 3, 232, 116, 0, 676, 1161,
		1, 0, 0, 0, 677, 678, 5, 6, 0, 0, 678, 679, 5, 150, 0, 0, 679, 680, 5,
		283, 0, 0, 680, 681, 3, 232, 116, 0, 681, 682, 5, 234, 0, 0, 682, 683,
		5, 199, 0, 0, 683, 684, 3, 34, 17, 0, 684, 1161, 1, 0, 0, 0, 685, 686,
		5, 66, 0, 0, 686, 689, 5, 283, 0, 0, 687, 688, 5, 102, 0, 0, 688, 690,
		5, 77, 0, 0, 689, 687, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 691, 1, 0,
		0, 0, 691, 1161, 3, 232, 116, 0, 692, 693, 5, 6, 0, 0, 693, 694, 5, 283,
		0, 0, 694, 695, 3, 232, 116, 0, 695, 696, 5, 206, 0, 0, 696, 697, 5, 253,
		0, 0, 697, 698, 3, 232, 116, 0, 698, 1161, 1, 0, 0, 0, 699, 700, 5, 6,
		0, 0, 700, 701, 5, 283, 0, 0, 701, 702, 3, 232, 116, 0, 702, 703, 5, 234,
		0, 0, 703, 704, 5, 14, 0, 0, 704, 705, 3, 240, 120, 0, 705, 1161, 1, 0,
		0, 0, 706, 707, 5, 20, 0, 0, 707, 708, 3, 232, 116, 0, 708, 717, 5, 313,
		0, 0, 709, 714, 3, 202, 101, 0, 710, 711, 5, 312, 0, 0, 711, 713, 3, 202,
		101, 0, 712, 710, 1, 0, 0, 0, 713, 716, 1, 0, 0, 0, 714, 712, 1, 0, 0,
		0, 714, 715, 1, 0, 0, 0, 715, 718, 1, 0, 0, 0, 716, 714, 1, 0, 0, 0, 717,
		709, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 720,
		5, 314, 0, 0, 720, 1161, 1, 0, 0, 0, 721, 724, 5, 36, 0, 0, 722, 723, 5,
		177, 0, 0, 723, 725, 5, 209, 0, 0, 724, 722, 1, 0, 0, 0, 724, 725, 1, 0,
		0, 0, 725, 726, 1, 0, 0, 0, 726, 1161, 3, 208, 104, 0, 727, 728, 5, 66,
		0, 0, 728, 731, 5, 90, 0, 0, 729, 730, 5, 102, 0, 0, 730, 732, 5, 77, 0,
		0, 731, 729, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733,
		1161, 3, 210, 105, 0, 734, 735, 5, 36, 0, 0, 735, 736, 5, 218, 0, 0, 736,
		740, 3, 244, 122, 0, 737, 738, 5, 288, 0, 0, 738, 739, 5, 3, 0, 0, 739,
		741, 3, 238, 119, 0, 740, 737, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 744,
		1, 0, 0, 0, 742, 743, 5, 105, 0, 0, 743, 745, 3, 244, 122, 0, 744, 742,
		1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 1161, 1, 0, 0, 0, 746, 747, 5, 66,
		0, 0, 747, 748, 5, 218, 0, 0, 748, 751, 3, 244, 122, 0, 749, 750, 5, 105,
		0, 0, 750, 752, 3, 244, 122, 0, 751, 749, 1, 0, 0, 0, 751, 752, 1, 0, 0,
		0, 752, 1161, 1, 0, 0, 0, 753, 754, 5, 93, 0, 0, 754, 755, 3, 242, 121,
		0, 755, 756, 5, 253, 0, 0, 756, 761, 3, 240, 120, 0, 757, 758, 5, 312,
		0, 0, 758, 760, 3, 240, 120, 0, 759, 757, 1, 0, 0, 0, 760, 763, 1, 0, 0,
		0, 761, 759, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 767, 1, 0, 0, 0, 763,
		761, 1, 0, 0, 0, 764, 765, 5, 288, 0, 0, 765, 766, 5, 3, 0, 0, 766, 768,
		5, 176, 0, 0, 767, 764, 1, 0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 772, 1,
		0, 0, 0, 769, 770, 5, 94, 0, 0, 770, 771, 5, 19, 0, 0, 771, 773, 3, 238,
		119, 0, 772, 769, 1, 0, 0, 0, 772, 773, 1, 0, 0, 0, 773, 776, 1, 0, 0,
		0, 774, 775, 5, 105, 0, 0, 775, 777, 3, 244, 122, 0, 776, 774, 1, 0, 0,
		0, 776, 777, 1, 0, 0, 0, 777, 1161, 1, 0, 0, 0, 778, 782, 5, 216, 0, 0,
		779, 780, 5, 3, 0, 0, 780, 781, 5, 176, 0, 0, 781, 783, 5, 86, 0, 0, 782,
		779, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 785,
		3, 242, 121, 0, 785, 786, 5, 88, 0, 0, 786, 791, 3, 240, 120, 0, 787, 788,
		5, 312, 0, 0, 788, 790, 3, 240, 120, 0, 789, 787, 1, 0, 0, 0, 790, 793,
		1, 0, 0, 0, 791, 789, 1, 0, 0, 0, 791, 792, 1, 0, 0, 0, 792, 797, 1, 0,
		0, 0, 793, 791, 1, 0, 0, 0, 794, 795, 5, 94, 0, 0, 795, 796, 5, 19, 0,
		0, 796, 798, 3, 238, 119, 0, 797, 794, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0,
		798, 801, 1, 0, 0, 0, 799, 800, 5, 105, 0, 0, 800, 802, 3, 244, 122, 0,
		801, 799, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802, 1161, 1, 0, 0, 0, 803,
		804, 5, 234, 0, 0, 804, 808, 5, 218, 0, 0, 805, 809, 5, 5, 0, 0, 806, 809,
		5, 163, 0, 0, 807, 809, 3, 244, 122, 0, 808, 805, 1, 0, 0, 0, 808, 806,
		1, 0, 0, 0, 808, 807, 1, 0, 0, 0, 809, 812, 1, 0, 0, 0, 810, 811, 5, 105,
		0, 0, 811, 813, 3, 244, 122, 0, 812, 810, 1, 0, 0, 0, 812, 813, 1, 0, 0,
		0, 813, 1161, 1, 0, 0, 0, 814, 825, 5, 93, 0, 0, 815, 820, 3, 230, 115,
		0, 816, 817, 5, 312, 0, 0, 817, 819, 3, 230, 115, 0, 818, 816, 1, 0, 0,
		0, 819, 822, 1, 0, 0, 0, 820, 818, 1, 0, 0, 0, 820, 821, 1, 0, 0, 0, 821,
		826, 1, 0, 0, 0, 822, 820, 1, 0, 0, 0, 823, 824, 5, 5, 0, 0, 824, 826,
		5, 198, 0, 0, 825, 815, 1, 0, 0, 0, 825, 823, 1, 0, 0, 0, 826, 827, 1,
		0, 0, 0, 827, 829, 5, 173, 0, 0, 828, 830, 7, 2, 0, 0, 829, 828, 1, 0,
		0, 0, 829, 830, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 832, 3, 232, 116,
		0, 832, 833, 5, 253, 0, 0, 833, 837, 3, 240, 120, 0, 834, 835, 5, 288,
		0, 0, 835, 836, 5, 93, 0, 0, 836, 838, 5, 176, 0, 0, 837, 834, 1, 0, 0,
		0, 837, 838, 1, 0, 0, 0, 838, 1161, 1, 0, 0, 0, 839, 850, 5, 57, 0, 0,
		840, 845, 3, 230, 115, 0, 841, 842, 5, 312, 0, 0, 842, 844, 3, 230, 115,
		0, 843, 841, 1, 0, 0, 0, 844, 847, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 845,
		846, 1, 0, 0, 0, 846, 851, 1, 0, 0, 0, 847, 845, 1, 0, 0, 0, 848, 849,
		5, 5, 0, 0, 849, 851, 5, 198, 0, 0, 850, 840, 1, 0, 0, 0, 850, 848, 1,
		0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 854, 5, 173, 0, 0, 853, 855, 7, 2,
		0, 0, 854, 853, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0,
		856, 857, 3, 232, 116, 0, 857, 858, 5, 253, 0, 0, 858, 859, 3, 240, 120,
		0, 859, 1161, 1, 0, 0, 0, 860, 864, 5, 216, 0, 0, 861, 862, 5, 93, 0, 0,
		862, 863, 5, 176, 0, 0, 863, 865, 5, 86, 0, 0, 864, 861, 1, 0, 0, 0, 864,
		865, 1, 0, 0, 0, 865, 876, 1, 0, 0, 0, 866, 871, 3, 230, 115, 0, 867, 868,
		5, 312, 0, 0, 868, 870, 3, 230, 115, 0, 869, 867, 1, 0, 0, 0, 870, 873,
		1, 0, 0, 0, 871, 869, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 877, 1, 0,
		0, 0, 873, 871, 1, 0, 0, 0, 874, 875, 5, 5, 0, 0, 875, 877, 5, 198, 0,
		0, 876, 866, 1, 0, 0, 0, 876, 874, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878,
		880, 5, 173, 0, 0, 879, 881, 7, 2, 0, 0, 880, 879, 1, 0, 0, 0, 880, 881,
		1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 883, 3, 232, 116, 0, 883, 884, 5,
		88, 0, 0, 884, 885, 3, 240, 120, 0, 885, 1161, 1, 0, 0, 0, 886, 887, 5,
		236, 0, 0, 887, 893, 5, 95, 0, 0, 888, 890, 5, 173, 0, 0, 889, 891, 5,
		244, 0, 0, 890, 889, 1, 0, 0, 0, 890, 891, 1, 0, 0, 0, 891, 892, 1, 0,
		0, 0, 892, 894, 3, 232, 116, 0, 893, 888, 1, 0, 0, 0, 893, 894, 1, 0, 0,
		0, 894, 1161, 1, 0, 0, 0, 895, 907, 5, 78, 0, 0, 896, 897, 5, 313, 0, 0,
		897, 902, 3, 196, 98, 0, 898, 899, 5, 312, 0, 0, 899, 901, 3, 196, 98,
		0, 900, 898, 1, 0, 0, 0, 901, 904, 1, 0, 0, 0, 902, 900, 1, 0, 0, 0, 902,
		903, 1, 0, 0, 0, 903, 905, 1, 0, 0, 0, 904, 902, 1, 0, 0, 0, 905, 906,
		5, 314, 0, 0, 906, 908, 1, 0, 0, 0, 907, 896, 1, 0, 0, 0, 907, 908, 1,
		0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 1161, 3, 16, 8, 0, 910, 911, 5, 78,
		0, 0, 911, 913, 5, 7, 0, 0, 912, 914, 5, 281, 0, 0, 913, 912, 1, 0, 0,
		0, 913, 914, 1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915, 1161, 3, 16, 8, 0,
		916, 917, 5, 236, 0, 0, 917, 918, 5, 36, 0, 0, 918, 919, 5, 244, 0, 0,
		919, 1161, 3, 232, 116, 0, 920, 921, 5, 236, 0, 0, 921, 922, 5, 36, 0,
		0, 922, 923, 5, 226, 0, 0, 923, 1161, 3, 232, 116, 0, 924, 925, 5, 236,
		0, 0, 925, 926, 5, 36, 0, 0, 926, 927, 5, 283, 0, 0, 927, 1161, 3, 232,
		116, 0, 928, 929, 5, 236, 0, 0, 929, 930, 5, 36, 0, 0, 930, 931, 5, 150,
		0, 0, 931, 932, 5, 283, 0, 0, 932, 1161, 3, 232, 116, 0, 933, 934, 5, 236,
		0, 0, 934, 937, 5, 245, 0, 0, 935, 936, 7, 3, 0, 0, 936, 938, 3, 232, 116,
		0, 937, 935, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 945, 1, 0, 0, 0, 939,
		940, 5, 137, 0, 0, 940, 943, 3, 152, 76, 0, 941, 942, 5, 73, 0, 0, 942,
		944, 3, 152, 76, 0, 943, 941, 1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 946,
		1, 0, 0, 0, 945, 939, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 1161, 1, 0,
		0, 0, 947, 948, 5, 236, 0, 0, 948, 951, 5, 227, 0, 0, 949, 950, 7, 3, 0,
		0, 950, 952, 3, 244, 122, 0, 951, 949, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0,
		952, 959, 1, 0, 0, 0, 953, 954, 5, 137, 0, 0, 954, 957, 3, 152, 76, 0,
		955, 956, 5, 73, 0, 0, 956, 958, 3, 152, 76, 0, 957, 955, 1, 0, 0, 0, 957,
		958, 1, 0, 0, 0, 958, 960, 1, 0, 0, 0, 959, 953, 1, 0, 0, 0, 959, 960,
		1, 0, 0, 0, 960, 1161, 1, 0, 0, 0, 961, 962, 5, 236, 0, 0, 962, 969, 5,
		26, 0, 0, 963, 964, 5, 137, 0, 0, 964, 967, 3, 152, 76, 0, 965, 966, 5,
		73, 0, 0, 966, 968, 3, 152, 76, 0, 967, 965, 1, 0, 0, 0, 967, 968, 1, 0,
		0, 0, 968, 970, 1, 0, 0, 0, 969, 963, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0,
		970, 1161, 1, 0, 0, 0, 971, 972, 5, 236, 0, 0, 972, 973, 5, 28, 0, 0, 973,
		975, 7, 3, 0, 0, 974, 976, 3, 232, 116, 0, 975, 974, 1, 0, 0, 0, 975, 976,
		1, 0, 0, 0, 976, 983, 1, 0, 0, 0, 977, 978, 5, 137, 0, 0, 978, 981, 3,
		152, 76, 0, 979, 980, 5, 73, 0, 0, 980, 982, 3, 152, 76, 0, 981, 979, 1,
		0, 0, 0, 981, 982, 1, 0, 0, 0, 982, 984, 1, 0, 0, 0, 983, 977, 1, 0, 0,
		0, 983, 984, 1, 0, 0, 0, 984, 1161, 1, 0, 0, 0, 985, 986, 5, 236, 0, 0,
		986, 987, 5, 240, 0, 0, 987, 988, 5, 86, 0, 0, 988, 1161, 3, 232, 116,
		0, 989, 990, 5, 236, 0, 0, 990, 991, 5, 240, 0, 0, 991, 992, 5, 86, 0,
		0, 992, 993, 5, 313, 0, 0, 993, 994, 3, 18, 9, 0, 994, 995, 5, 314, 0,
		0, 995, 1161, 1, 0, 0, 0, 996, 998, 5, 236, 0, 0, 997, 999, 5, 39, 0, 0,
		998, 997, 1, 0, 0, 0, 998, 999, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000,
		1003, 5, 219, 0, 0, 1001, 1002, 7, 3, 0, 0, 1002, 1004, 3, 244, 122, 0,
		1003, 1001, 1, 0, 0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1161, 1, 0, 0, 0,
		1005, 1006, 5, 236, 0, 0, 1006, 1007, 5, 218, 0, 0, 1007, 1010, 5, 95,
		0, 0, 1008, 1009, 7, 3, 0, 0, 1009, 1011, 3, 244, 122, 0, 1010, 1008, 1,
		0, 0, 0, 1010, 1011, 1, 0, 0, 0, 1011, 1161, 1, 0, 0, 0, 1012, 1013, 5,
		59, 0, 0, 1013, 1161, 3, 232, 116, 0, 1014, 1015, 5, 58, 0, 0, 1015, 1161,
		3, 232, 116, 0, 1016, 1017, 5, 236, 0, 0, 1017, 1020, 5, 91, 0, 0, 1018,
		1019, 7, 3, 0, 0, 1019, 1021, 3, 232, 116, 0, 1020, 1018, 1, 0, 0, 0, 1020,
		1021, 1, 0, 0, 0, 1021, 1028, 1, 0, 0, 0, 1022, 1023, 5, 137, 0, 0, 1023,
		1026, 3, 152, 76, 0, 1024, 1025, 5, 73, 0, 0, 1025, 1027, 3, 152, 76, 0,
		1026, 1024, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1029, 1, 0, 0, 0,
		1028, 1022, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1161, 1, 0, 0, 0,
		1030, 1031, 5, 236, 0, 0, 1031, 1038, 5, 233, 0, 0, 1032, 1033, 5, 137,
		0, 0, 1033, 1036, 3, 152, 76, 0, 1034, 1035, 5, 73, 0, 0, 1035, 1037, 3,
		152, 76, 0, 1036, 1034, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 1039,
		1, 0, 0, 0, 1038, 1032, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1161,
		1, 0, 0, 0, 1040, 1041, 5, 234, 0, 0, 1041, 1042, 5, 233, 0, 0, 1042, 1043,
		5, 14, 0, 0, 1043, 1161, 3, 248, 124, 0, 1044, 1045, 5, 210, 0, 0, 1045,
		1046, 5, 233, 0, 0, 1046, 1161, 5, 14, 0, 0, 1047, 1048, 5, 234, 0, 0,
		1048, 1049, 5, 233, 0, 0, 1049, 1050, 3, 232, 116, 0, 1050, 1051, 5, 296,
		0, 0, 1051, 1052, 3, 120, 60, 0, 1052, 1161, 1, 0, 0, 0, 1053, 1054, 5,
		210, 0, 0, 1054, 1055, 5, 233, 0, 0, 1055, 1161, 3, 232, 116, 0, 1056,
		1057, 5, 239, 0, 0, 1057, 1066, 5, 255, 0, 0, 1058, 1063, 3, 198, 99, 0,
		1059, 1060, 5, 312, 0, 0, 1060, 1062, 3, 198, 99, 0, 1061, 1059, 1, 0,
		0, 0, 1062, 1065, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 1063, 1064, 1, 0,
		0, 0, 1064, 1067, 1, 0, 0, 0, 1065, 1063, 1, 0, 0, 0, 1066, 1058, 1, 0,
		0, 0, 1066, 1067, 1, 0, 0, 0, 1067, 1161, 1, 0, 0, 0, 1068, 1070, 5, 30,
		0, 0, 1069, 1071, 5, 291, 0, 0, 1070, 1069, 1, 0, 0, 0, 1070, 1071, 1,
		0, 0, 0, 1071, 1161, 1, 0, 0, 0, 1072, 1074, 5, 220, 0, 0, 1073, 1075,
		5, 291, 0, 0, 1074, 1073, 1, 0, 0, 0, 1074, 1075, 1, 0, 0, 0, 1075, 1161,
		1, 0, 0, 0, 1076, 1077, 5, 197, 0, 0, 1077, 1078, 3, 244, 122, 0, 1078,
		1079, 5, 88, 0, 0, 1079, 1080, 3, 16, 8, 0, 1080, 1161, 1, 0, 0, 0, 1081,
		1082, 5, 51, 0, 0, 1082, 1083, 5, 197, 0, 0, 1083, 1161, 3, 244, 122, 0,
		1084, 1085, 5, 76, 0, 0, 1085, 1095, 3, 244, 122, 0, 1086, 1087, 5, 274,
		0, 0, 1087, 1092, 3, 120, 60, 0, 1088, 1089, 5, 312, 0, 0, 1089, 1091,
		3, 120, 60, 0, 1090, 1088, 1, 0, 0, 0, 1091, 1094, 1, 0, 0, 0, 1092, 1090,
		1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093, 1096, 1, 0, 0, 0, 1094, 1092,
		1, 0, 0, 0, 1095, 1086, 1, 0, 0, 0, 1095, 1096, 1, 0, 0, 0, 1096, 1161,
		1, 0, 0, 0, 1097, 1098, 5, 76, 0, 0, 1098, 1099, 5, 104, 0, 0, 1099, 1109,
		3, 152, 76, 0, 1100, 1101, 5, 274, 0, 0, 1101, 1106, 3, 120, 60, 0, 1102,
		1103, 5, 312, 0, 0, 1103, 1105, 3, 120, 60, 0, 1104, 1102, 1, 0, 0, 0,
		1105, 1108, 1, 0, 0, 0, 1106, 1104, 1, 0, 0, 0, 1106, 1107, 1, 0, 0, 0,
		1107, 1110, 1, 0, 0, 0, 1108, 1106, 1, 0, 0, 0, 1109, 1100, 1, 0, 0, 0,
		1109, 1110, 1, 0, 0, 0, 1110, 1161, 1, 0, 0, 0, 1111, 1112, 5, 59, 0, 0,
		1112, 1113, 5, 109, 0, 0, 1113, 1161, 3, 244, 122, 0, 1114, 1115, 5, 59,
		0, 0, 1115, 1116, 5, 181, 0, 0, 1116, 1161, 3, 244, 122, 0, 1117, 1118,
		5, 234, 0, 0, 1118, 1119, 5, 188, 0, 0, 1119, 1161, 3, 206, 103, 0, 1120,
		1121, 5, 234, 0, 0, 1121, 1122, 5, 251, 0, 0, 1122, 1125, 5, 295, 0, 0,
		1123, 1126, 5, 140, 0, 0, 1124, 1126, 3, 120, 60, 0, 1125, 1123, 1, 0,
		0, 0, 1125, 1124, 1, 0, 0, 0, 1126, 1161, 1, 0, 0, 0, 1127, 1128, 5, 271,
		0, 0, 1128, 1129, 3, 232, 116, 0, 1129, 1130, 5, 234, 0, 0, 1130, 1135,
		3, 194, 97, 0, 1131, 1132, 5, 312, 0, 0, 1132, 1134, 3, 194, 97, 0, 1133,
		1131, 1, 0, 0, 0, 1134, 1137, 1, 0, 0, 0, 1135, 1133, 1, 0, 0, 0, 1135,
		1136, 1, 0, 0, 0, 1136, 1140, 1, 0, 0, 0, 1137, 1135, 1, 0, 0, 0, 1138,
		1139, 5, 285, 0, 0, 1139, 1141, 3, 122, 61, 0, 1140, 1138, 1, 0, 0, 0,
		1140, 1141, 1, 0, 0, 0, 1141, 1161, 1, 0, 0, 0, 1142, 1143, 5, 152, 0,
		0, 1143, 1144, 5, 113, 0, 0, 1144, 1149, 3, 232, 116, 0, 1145, 1147, 5,
		11, 0, 0, 1146, 1145, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 1148, 1,
		0, 0, 0, 1148, 1150, 3, 244, 122, 0, 1149, 1146, 1, 0, 0, 0, 1149, 1150,
		1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151, 1152, 5, 274, 0, 0, 1152, 1153,
		3, 70, 35, 0, 1153, 1154, 5, 173, 0, 0, 1154, 1156, 3, 120, 60, 0, 1155,
		1157, 3, 178, 89, 0, 1156, 1155, 1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158,
		1156, 1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1161, 1, 0, 0, 0, 1160,
		289, 1, 0, 0, 0, 1160, 290, 1, 0, 0, 0, 1160, 292, 1, 0, 0, 0, 1160, 297,
		1, 0, 0, 0, 1160, 319, 1, 0, 0, 0, 1160, 329, 1, 0, 0, 0, 1160, 345, 1,
		0, 0, 0, 1160, 355, 1, 0, 0, 0, 1160, 362, 1, 0, 0, 0, 1160, 369, 1, 0,
		0, 0, 1160, 407, 1, 0, 0, 0, 1160, 437, 1, 0, 0, 0, 1160, 444, 1, 0, 0,
		0, 1160, 452, 1, 0, 0, 0, 1160, 459, 1, 0, 0, 0, 1160, 462, 1, 0, 0, 0,
		1160, 471, 1, 0, 0, 0, 1160, 480, 1, 0, 0, 0, 1160, 489, 1, 0, 0, 0, 1160,
		500, 1, 0, 0, 0, 1160, 516, 1, 0, 0, 0, 1160, 533, 1, 0, 0, 0, 1160, 548,
		1, 0, 0, 0, 1160, 563, 1, 0, 0, 0, 1160, 570, 1, 0, 0, 0, 1160, 577, 1,
		0, 0, 0, 1160, 600, 1, 0, 0, 0, 1160, 606, 1, 0, 0, 0, 1160, 635, 1, 0,
		0, 0, 1160, 653, 1, 0, 0, 0, 1160, 657, 1, 0, 0, 0, 1160, 665, 1, 0, 0,
		0, 1160, 677, 1, 0, 0, 0, 1160, 685, 1, 0, 0, 0, 1160, 692, 1, 0, 0, 0,
		1160, 699, 1, 0, 0, 0, 1160, 706, 1, 0, 0, 0, 1160, 721, 1, 0, 0, 0, 1160,
		727, 1, 0, 0, 0, 1160, 734, 1, 0, 0, 0, 1160, 746, 1, 0, 0, 0, 1160, 753,
		1, 0, 0, 0, 1160, 778, 1, 0, 0, 0, 1160, 803, 1, 0, 0, 0, 1160, 814, 1,
		0, 0, 0, 1160, 839, 1, 0, 0, 0, 1160, 860, 1, 0, 0, 0, 1160, 886, 1, 0,
		0, 0, 1160, 895, 1, 0, 0, 0, 1160, 910, 1, 0, 0, 0, 1160, 916, 1, 0, 0,
		0, 1160, 920, 1, 0, 0, 0, 1160, 924, 1, 0, 0, 0, 1160, 928, 1, 0, 0, 0,
		1160, 933, 1, 0, 0, 0, 1160, 947, 1, 0, 0, 0, 1160, 961, 1, 0, 0, 0, 1160,
		971, 1, 0, 0, 0, 1160, 985, 1, 0, 0, 0, 1160, 989, 1, 0, 0, 0, 1160, 996,
		1, 0, 0, 0, 1160, 1005, 1, 0, 0, 0, 1160, 1012, 1, 0, 0, 0, 1160, 1014,
		1, 0, 0, 0, 1160, 1016, 1, 0, 0, 0, 1160, 1030, 1, 0, 0, 0, 1160, 1040,
		1, 0, 0, 0, 1160, 1044, 1, 0, 0, 0, 1160, 1047, 1, 0, 0, 0, 1160, 1053,
		1, 0, 0, 0, 1160, 1056, 1, 0, 0, 0, 1160, 1068, 1, 0, 0, 0, 1160, 1072,
		1, 0, 0, 0, 1160, 1076, 1, 0, 0, 0, 1160, 1081, 1, 0, 0, 0, 1160, 1084,
		1, 0, 0, 0, 1160, 1097, 1, 0, 0, 0, 1160, 1111, 1, 0, 0, 0, 1160, 1114,
		1, 0, 0, 0, 1160, 1117, 1, 0, 0, 0, 1160, 1120, 1, 0, 0, 0, 1160, 1127,
		1, 0, 0, 0, 1160, 1142, 1, 0, 0, 0, 1161, 17, 1, 0, 0, 0, 1162, 1164, 3,
		20, 10, 0, 1163, 1162, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164, 1165,
		1, 0, 0, 0, 1165, 1166, 3, 22, 11, 0, 1166, 19, 1, 0, 0, 0, 1167, 1168,
		5, 288, 0, 0, 1168, 1173, 3, 208, 104, 0, 1169, 1170, 5, 312, 0, 0, 1170,
		1172, 3, 208, 104, 0, 1171, 1169, 1, 0, 0, 0, 1172, 1175, 1, 0, 0, 0, 1173,
		1171, 1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174, 21, 1, 0, 0, 0, 1175, 1173,
		1, 0, 0, 0, 1176, 1178, 3, 24, 12, 0, 1177, 1176, 1, 0, 0, 0, 1177, 1178,
		1, 0, 0, 0, 1178, 1179, 1, 0, 0, 0, 1179, 1180, 3, 40, 20, 0, 1180, 23,
		1, 0, 0, 0, 1181, 1183, 5, 288, 0, 0, 1182, 1184, 5, 204, 0, 0, 1183, 1182,
		1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 1190,
		3, 64, 32, 0, 1186, 1187, 5, 312, 0, 0, 1187, 1189, 3, 64, 32, 0, 1188,
		1186, 1, 0, 0, 0, 1189, 1192, 1, 0, 0, 0, 1190, 1188, 1, 0, 0, 0, 1190,
		1191, 1, 0, 0, 0, 1191, 25, 1, 0, 0, 0, 1192, 1190, 1, 0, 0, 0, 1193, 1196,
		3, 28, 14, 0, 1194, 1196, 3, 30, 15, 0, 1195, 1193, 1, 0, 0, 0, 1195, 1194,
		1, 0, 0, 0, 1196, 27, 1, 0, 0, 0, 1197, 1198, 3, 244, 122, 0, 1198, 1201,
		3, 168, 84, 0, 1199, 1200, 5, 165, 0, 0, 1200, 1202, 5, 166, 0, 0, 1201,
		1199, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1205, 1, 0, 0, 0, 1203,
		1204, 5, 29, 0, 0, 1204, 1206, 3, 152, 76, 0, 1205, 1203, 1, 0, 0, 0, 1205,
		1206, 1, 0, 0, 0, 1206, 1209, 1, 0, 0, 0, 1207, 1208, 5, 288, 0, 0, 1208,
		1210, 3, 32, 16, 0, 1209, 1207, 1, 0, 0, 0, 1209, 1210, 1, 0, 0, 0, 1210,
		29, 1, 0, 0, 0, 1211, 1212, 5, 137, 0, 0, 1212, 1215, 3, 232, 116, 0, 1213,
		1214, 7, 4, 0, 0, 1214, 1216, 5, 199, 0, 0, 1215, 1213, 1, 0, 0, 0, 1215,
		1216, 1, 0, 0, 0, 1216, 31, 1, 0, 0, 0, 1217, 1218, 5, 313, 0, 0, 1218,
		1219, 3, 34, 17, 0, 1219, 1220, 5, 314, 0, 0, 1220, 33, 1, 0, 0, 0, 1221,
		1226, 3, 36, 18, 0, 1222, 1223, 5, 312, 0, 0, 1223, 1225, 3, 36, 18, 0,
		1224, 1222, 1, 0, 0, 0, 1225, 1228, 1, 0, 0, 0, 1226, 1224, 1, 0, 0, 0,
		1226, 1227, 1, 0, 0, 0, 1227, 35, 1, 0, 0, 0, 1228, 1226, 1, 0, 0, 0, 1229,
		1230, 3, 244, 122, 0, 1230, 1231, 5, 296, 0, 0, 1231, 1232, 3, 38, 19,
		0, 1232, 37, 1, 0, 0, 0, 1233, 1236, 5, 53, 0, 0, 1234, 1236, 3, 120, 60,
		0, 1235, 1233, 1, 0, 0, 0, 1235, 1234, 1, 0, 0, 0, 1236, 39, 1, 0, 0, 0,
		1237, 1248, 3, 46, 23, 0, 1238, 1239, 5, 178, 0, 0, 1239, 1240, 5, 19,
		0, 0, 1240, 1245, 3, 50, 25, 0, 1241, 1242, 5, 312, 0, 0, 1242, 1244, 3,
		50, 25, 0, 1243, 1241, 1, 0, 0, 0, 1244, 1247, 1, 0, 0, 0, 1245, 1243,
		1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1249, 1, 0, 0, 0, 1247, 1245,
		1, 0, 0, 0, 1248, 1238, 1, 0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249, 1255,
		1, 0, 0, 0, 1250, 1251, 5, 171, 0, 0, 1251, 1253, 3, 44, 22, 0, 1252, 1254,
		7, 5, 0, 0, 1253, 1252, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 1256,
		1, 0, 0, 0, 1255, 1250, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256, 1270,
		1, 0, 0, 0, 1257, 1258, 5, 138, 0, 0, 1258, 1271, 3, 42, 21, 0, 1259, 1260,
		5, 81, 0, 0, 1260, 1262, 7, 6, 0, 0, 1261, 1263, 3, 44, 22, 0, 1262, 1261,
		1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263, 1264, 1, 0, 0, 0, 1264, 1268,
		7, 5, 0, 0, 1265, 1269, 5, 175, 0, 0, 1266, 1267, 5, 288, 0, 0, 1267, 1269,
		5, 250, 0, 0, 1268, 1265, 1, 0, 0, 0, 1268, 1266, 1, 0, 0, 0, 1269, 1271,
		1, 0, 0, 0, 1270, 1257, 1, 0, 0, 0, 1270, 1259, 1, 0, 0, 0, 1270, 1271,
		1, 0, 0, 0, 1271, 41, 1, 0, 0, 0, 1272, 1275, 5, 5, 0, 0, 1273, 1275, 3,
		44, 22, 0, 1274, 1272, 1, 0, 0, 0, 1274, 1273, 1, 0, 0, 0, 1275, 43, 1,
		0, 0, 0, 1276, 1277, 7, 7, 0, 0, 1277, 45, 1, 0, 0, 0, 1278, 1279, 6, 23,
		-1, 0, 1279, 1280, 3, 48, 24, 0, 1280, 1295, 1, 0, 0, 0, 1281, 1282, 10,
		2, 0, 0, 1282, 1284, 5, 111, 0, 0, 1283, 1285, 3, 66, 33, 0, 1284, 1283,
		1, 0, 0, 0, 1284, 1285, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1294,
		3, 46, 23, 3, 1287, 1288, 10, 1, 0, 0, 1288, 1290, 7, 8, 0, 0, 1289, 1291,
		3, 66, 33, 0, 1290, 1289, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 1292,
		1, 0, 0, 0, 1292, 1294, 3, 46, 23, 2, 1293, 1281, 1, 0, 0, 0, 1293, 1287,
		1, 0, 0, 0, 1294, 1297, 1, 0, 0, 0, 1295, 1293, 1, 0, 0, 0, 1295, 1296,
		1, 0, 0, 0, 1296, 47, 1, 0, 0, 0, 1297, 1295, 1, 0, 0, 0, 1298, 1315, 3,
		52, 26, 0, 1299, 1300, 5, 244, 0, 0, 1300, 1315, 3, 232, 116, 0, 1301,
		1302, 5, 280, 0, 0, 1302, 1307, 3, 120, 60, 0, 1303, 1304, 5, 312, 0, 0,
		1304, 1306, 3, 120, 60, 0, 1305, 1303, 1, 0, 0, 0, 1306, 1309, 1, 0, 0,
		0, 1307, 1305, 1, 0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308, 1315, 1, 0, 0,
		0, 1309, 1307, 1, 0, 0, 0, 1310, 1311, 5, 313, 0, 0, 1311, 1312, 3, 40,
		20, 0, 1312, 1313, 5, 314, 0, 0, 1313, 1315, 1, 0, 0, 0, 1314, 1298, 1,
		0, 0, 0, 1314, 1299, 1, 0, 0, 0, 1314, 1301, 1, 0, 0, 0, 1314, 1310, 1,
		0, 0, 0, 1315, 49, 1, 0, 0, 0, 1316, 1318, 3, 120, 60, 0, 1317, 1319, 7,
		9, 0, 0, 1318, 1317, 1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1322, 1,
		0, 0, 0, 1320, 1321, 5, 168, 0, 0, 1321, 1323, 7, 10, 0, 0, 1322, 1320,
		1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 51, 1, 0, 0, 0, 1324, 1326, 5,
		231, 0, 0, 1325, 1327, 3, 66, 33, 0, 1326, 1325, 1, 0, 0, 0, 1326, 1327,
		1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328, 1333, 3, 68, 34, 0, 1329, 1330,
		5, 312, 0, 0, 1330, 1332, 3, 68, 34, 0, 1331, 1329, 1, 0, 0, 0, 1332, 1335,
		1, 0, 0, 0, 1333, 1331, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 0, 1334, 1345,
		1, 0, 0, 0, 1335, 1333, 1, 0, 0, 0, 1336, 1337, 5, 88, 0, 0, 1337, 1342,
		3, 70, 35, 0, 1338, 1339, 5, 312, 0, 0, 1339, 1341, 3, 70, 35, 0, 1340,
		1338, 1, 0, 0, 0, 1341, 1344, 1, 0, 0, 0, 1342, 1340, 1, 0, 0, 0, 1342,
		1343, 1, 0, 0, 0, 1343, 1346, 1, 0, 0, 0, 1344, 1342, 1, 0, 0, 0, 1345,
		1336, 1, 0, 0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1349, 1, 0, 0, 0, 1347,
		1348, 5, 285, 0, 0, 1348, 1350, 3, 122, 61, 0, 1349, 1347, 1, 0, 0, 0,
		1349, 1350, 1, 0, 0, 0, 1350, 1354, 1, 0, 0, 0, 1351, 1352, 5, 97, 0, 0,
		1352, 1353, 5, 19, 0, 0, 1353, 1355, 3, 54, 27, 0, 1354, 1351, 1, 0, 0,
		0, 1354, 1355, 1, 0, 0, 0, 1355, 1358, 1, 0, 0, 0, 1356, 1357, 5, 100,
		0, 0, 1357, 1359, 3, 122, 61, 0, 1358, 1356, 1, 0, 0, 0, 1358, 1359, 1,
		0, 0, 0, 1359, 1369, 1, 0, 0, 0, 1360, 1361, 5, 287, 0, 0, 1361, 1366,
		3, 60, 30, 0, 1362, 1363, 5, 312, 0, 0, 1363, 1365, 3, 60, 30, 0, 1364,
		1362, 1, 0, 0, 0, 1365, 1368, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1366,
		1367, 1, 0, 0, 0, 1367, 1370, 1, 0, 0, 0, 1368, 1366, 1, 0, 0, 0, 1369,
		1360, 1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 53, 1, 0, 0, 0, 1371, 1373,
		3, 66, 33, 0, 1372, 1371, 1, 0, 0, 0, 1372, 1373, 1, 0, 0, 0, 1373, 1374,
		1, 0, 0, 0, 1374, 1379, 3, 56, 28, 0, 1375, 1376, 5, 312, 0, 0, 1376, 1378,
		3, 56, 28, 0, 1377, 1375, 1, 0, 0, 0, 1378, 1381, 1, 0, 0, 0, 1379, 1377,
		1, 0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380, 55, 1, 0, 0, 0, 1381, 1379, 1,
		0, 0, 0, 1382, 1423, 3, 58, 29, 0, 1383, 1384, 5, 221, 0, 0, 1384, 1393,
		5, 313, 0, 0, 1385, 1390, 3, 120, 60, 0, 1386, 1387, 5, 312, 0, 0, 1387,
		1389, 3, 120, 60, 0, 1388, 1386, 1, 0, 0, 0, 1389, 1392, 1, 0, 0, 0, 1390,
		1388, 1, 0, 0, 0, 1390, 1391, 1, 0, 0, 0, 1391, 1394, 1, 0, 0, 0, 1392,
		1390, 1, 0, 0, 0, 1393, 1385, 1, 0, 0, 0, 1393, 1394, 1, 0, 0, 0, 1394,
		1395, 1, 0, 0, 0, 1395, 1423, 5, 314, 0, 0, 1396, 1397, 5, 38, 0, 0, 1397,
		1406, 5, 313, 0, 0, 1398, 1403, 3, 120, 60, 0, 1399, 1400, 5, 312, 0, 0,
		1400, 1402, 3, 120, 60, 0, 1401, 1399, 1, 0, 0, 0, 1402, 1405, 1, 0, 0,
		0, 1403, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1407, 1, 0, 0,
		0, 1405, 1403, 1, 0, 0, 0, 1406, 1398, 1, 0, 0, 0, 1406, 1407, 1, 0, 0,
		0, 1407, 1408, 1, 0, 0, 0, 1408, 1423, 5, 314, 0, 0, 1409, 1410, 5, 98,
		0, 0, 1410, 1411, 5, 235, 0, 0, 1411, 1412, 5, 313, 0, 0, 1412, 1417, 3,
		58, 29, 0, 1413, 1414, 5, 312, 0, 0, 1414, 1416, 3, 58, 29, 0, 1415, 1413,
		1, 0, 0, 0, 1416, 1419, 1, 0, 0, 0, 1417, 1415, 1, 0, 0, 0, 1417, 1418,
		1, 0, 0, 0, 1418, 1420, 1, 0, 0, 0, 1419, 1417, 1, 0, 0, 0, 1420, 1421,
		5, 314, 0, 0, 1421, 1423, 1, 0, 0, 0, 1422, 1382, 1, 0, 0, 0, 1422, 1383,
		1, 0, 0, 0, 1422, 1396, 1, 0, 0, 0, 1422, 1409, 1, 0, 0, 0, 1423, 57, 1,
		0, 0, 0, 1424, 1433, 5, 313, 0, 0, 1425, 1430, 3, 120, 60, 0, 1426, 1427,
		5, 312, 0, 0, 1427, 1429, 3, 120, 60, 0, 1428, 1426, 1, 0, 0, 0, 1429,
		1432, 1, 0, 0, 0, 1430, 1428, 1, 0, 0, 0, 1430, 1431, 1, 0, 0, 0, 1431,
		1434, 1, 0, 0, 0, 1432, 1430, 1, 0, 0, 0, 1433, 1425, 1, 0, 0, 0, 1433,
		1434, 1, 0, 0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1438, 5, 314, 0, 0, 1436,
		1438, 3, 120, 60, 0, 1437, 1424, 1, 0, 0, 0, 1437, 1436, 1, 0, 0, 0, 1438,
		59, 1, 0, 0, 0, 1439, 1440, 3, 244, 122, 0, 1440, 1441, 5, 11, 0, 0, 1441,
		1442, 5, 313, 0, 0, 1442, 1443, 3, 62, 31, 0, 1443, 1444, 5, 314, 0, 0,
		1444, 61, 1, 0, 0, 0, 1445, 1447, 3, 244, 122, 0, 1446, 1445, 1, 0, 0,
		0, 1446, 1447, 1, 0, 0, 0, 1447, 1458, 1, 0, 0, 0, 1448, 1449, 5, 184,
		0, 0, 1449, 1450, 5, 19, 0, 0, 1450, 1455, 3, 120, 60, 0, 1451, 1452, 5,
		312, 0, 0, 1452, 1454, 3, 120, 60, 0, 1453, 1451, 1, 0, 0, 0, 1454, 1457,
		1, 0, 0, 0, 1455, 1453, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1459,
		1, 0, 0, 0, 1457, 1455, 1, 0, 0, 0, 1458, 1448, 1, 0, 0, 0, 1458, 1459,
		1, 0, 0, 0, 1459, 1470, 1, 0, 0, 0, 1460, 1461, 5, 178, 0, 0, 1461, 1462,
		5, 19, 0, 0, 1462, 1467, 3, 50, 25, 0, 1463, 1464, 5, 312, 0, 0, 1464,
		1466, 3, 50, 25, 0, 1465, 1463, 1, 0, 0, 0, 1466, 1469, 1, 0, 0, 0, 1467,
		1465, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1471, 1, 0, 0, 0, 1469,
		1467, 1, 0, 0, 0, 1470, 1460, 1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471,
		1473, 1, 0, 0, 0, 1472, 1474, 3, 182, 91, 0, 1473, 1472, 1, 0, 0, 0, 1473,
		1474, 1, 0, 0, 0, 1474, 63, 1, 0, 0, 0, 1475, 1477, 3, 244, 122, 0, 1476,
		1478, 3, 102, 51, 0, 1477, 1476, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478,
		1479, 1, 0, 0, 0, 1479, 1480, 5, 11, 0, 0, 1480, 1481, 5, 313, 0, 0, 1481,
		1482, 3, 22, 11, 0, 1482, 1483, 5, 314, 0, 0, 1483, 65, 1, 0, 0, 0, 1484,
		1485, 7, 11, 0, 0, 1485, 67, 1, 0, 0, 0, 1486, 1491, 3, 120, 60, 0, 1487,
		1489, 5, 11, 0, 0, 1488, 1487, 1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489,
		1490, 1, 0, 0, 0, 1490, 1492, 3, 244, 122, 0, 1491, 1488, 1, 0, 0, 0, 1491,
		1492, 1, 0, 0, 0, 1492, 1502, 1, 0, 0, 0, 1493, 1494, 3, 128, 64, 0, 1494,
		1495, 5, 310, 0, 0, 1495, 1498, 5, 304, 0, 0, 1496, 1497, 5, 11, 0, 0,
		1497, 1499, 3, 102, 51, 0, 1498, 1496, 1, 0, 0, 0, 1498, 1499, 1, 0, 0,
		0, 1499, 1502, 1, 0, 0, 0, 1500, 1502, 5, 304, 0, 0, 1501, 1486, 1, 0,
		0, 0, 1501, 1493, 1, 0, 0, 0, 1501, 1500, 1, 0, 0, 0, 1502, 69, 1, 0, 0,
		0, 1503, 1504, 6, 35, -1, 0, 1504, 1505, 3, 76, 38, 0, 1505, 1524, 1, 0,
		0, 0, 1506, 1520, 10, 2, 0, 0, 1507, 1508, 5, 37, 0, 0, 1508, 1509, 5,
		119, 0, 0, 1509, 1521, 3, 76, 38, 0, 1510, 1511, 3, 72, 36, 0, 1511, 1512,
		5, 119, 0, 0, 1512, 1513, 3, 70, 35, 0, 1513, 1514, 3, 74, 37, 0, 1514,
		1521, 1, 0, 0, 0, 1515, 1516, 5, 155, 0, 0, 1516, 1517, 3, 72, 36, 0, 1517,
		1518, 5, 119, 0, 0, 1518, 1519, 3, 76, 38, 0, 1519, 1521, 1, 0, 0, 0, 1520,
		1507, 1, 0, 0, 0, 1520, 1510, 1, 0, 0, 0, 1520, 1515, 1, 0, 0, 0, 1521,
		1523, 1, 0, 0, 0, 1522, 1506, 1, 0, 0, 0, 1523, 1526, 1, 0, 0, 0, 1524,
		1522, 1, 0, 0, 0, 1524, 1525, 1, 0, 0, 0, 1525, 71, 1, 0, 0, 0, 1526, 1524,
		1, 0, 0, 0, 1527, 1529, 5, 108, 0, 0, 1528, 1527, 1, 0, 0, 0, 1528, 1529,
		1, 0, 0, 0, 1529, 1535, 1, 0, 0, 0, 1530, 1532, 7, 12, 0, 0, 1531, 1533,
		5, 180, 0, 0, 1532, 1531, 1, 0, 0, 0, 1532, 1533, 1, 0, 0, 0, 1533, 1535,
		1, 0, 0, 0, 1534, 1528, 1, 0, 0, 0, 1534, 1530, 1, 0, 0, 0, 1535, 73, 1,
		0, 0, 0, 1536, 1537, 5, 173, 0, 0, 1537, 1551, 3, 122, 61, 0, 1538, 1539,
		5, 274, 0, 0, 1539, 1540, 5, 313, 0, 0, 1540, 1545, 3, 244, 122, 0, 1541,
		1542, 5, 312, 0, 0, 1542, 1544, 3, 244, 122, 0, 1543, 1541, 1, 0, 0, 0,
		1544, 1547, 1, 0, 0, 0, 1545, 1543, 1, 0, 0, 0, 1545, 1546, 1, 0, 0, 0,
		1546, 1548, 1, 0, 0, 0, 1547, 1545, 1, 0, 0, 0, 1548, 1549, 5, 314, 0,
		0, 1549, 1551, 1, 0, 0, 0, 1550, 1536, 1, 0, 0, 0, 1550, 1538, 1, 0, 0,
		0, 1551, 75, 1, 0, 0, 0, 1552, 1559, 3, 86, 43, 0, 1553, 1554, 5, 246,
		0, 0, 1554, 1555, 3, 78, 39, 0, 1555, 1556, 5, 313, 0, 0, 1556, 1557, 3,
		120, 60, 0, 1557, 1558, 5, 314, 0, 0, 1558, 1560, 1, 0, 0, 0, 1559, 1553,
		1, 0, 0, 0, 1559, 1560, 1, 0, 0, 0, 1560, 77, 1, 0, 0, 0, 1561, 1562, 7,
		13, 0, 0, 1562, 79, 1, 0, 0, 0, 1563, 1564, 7, 14, 0, 0, 1564, 81, 1, 0,
		0, 0, 1565, 1572, 5, 72, 0, 0, 1566, 1568, 5, 258, 0, 0, 1567, 1569, 3,
		152, 76, 0, 1568, 1567, 1, 0, 0, 0, 1568, 1569, 1, 0, 0, 0, 1569, 1570,
		1, 0, 0, 0, 1570, 1572, 3, 84, 42, 0, 1571, 1565, 1, 0, 0, 0, 1571, 1566,
		1, 0, 0, 0, 1572, 83, 1, 0, 0, 0, 1573, 1574, 7, 15, 0, 0, 1574, 1575,
		5, 34, 0, 0, 1575, 85, 1, 0, 0, 0, 1576, 1659, 3, 100, 50, 0, 1577, 1578,
		5, 149, 0, 0, 1578, 1589, 5, 313, 0, 0, 1579, 1580, 5, 184, 0, 0, 1580,
		1581, 5, 19, 0, 0, 1581, 1586, 3, 120, 60, 0, 1582, 1583, 5, 312, 0, 0,
		1583, 1585, 3, 120, 60, 0, 1584, 1582, 1, 0, 0, 0, 1585, 1588, 1, 0, 0,
		0, 1586, 1584, 1, 0, 0, 0, 1586, 1587, 1, 0, 0, 0, 1587, 1590, 1, 0, 0,
		0, 1588, 1586, 1, 0, 0, 0, 1589, 1579, 1, 0, 0, 0, 1589, 1590, 1, 0, 0,
		0, 1590, 1601, 1, 0, 0, 0, 1591, 1592, 5, 178, 0, 0, 1592, 1593, 5, 19,
		0, 0, 1593, 1598, 3, 50, 25, 0, 1594, 1595, 5, 312, 0, 0, 1595, 1597, 3,
		50, 25, 0, 1596, 1594, 1, 0, 0, 0, 1597, 1600, 1, 0, 0, 0, 1598, 1596,
		1, 0, 0, 0, 1598, 1599, 1, 0, 0, 0, 1599, 1602, 1, 0, 0, 0, 1600, 1598,
		1, 0, 0, 0, 1601, 1591, 1, 0, 0, 0, 1601, 1602, 1, 0, 0, 0, 1602, 1612,
		1, 0, 0, 0, 1603, 1604, 5, 151, 0, 0, 1604, 1609, 3, 88, 44, 0, 1605, 1606,
		5, 312, 0, 0, 1606, 1608, 3, 88, 44, 0, 1607, 1605, 1, 0, 0, 0, 1608, 1611,
		1, 0, 0, 0, 1609, 1607, 1, 0, 0, 0, 1609, 1610, 1, 0, 0, 0, 1610, 1613,
		1, 0, 0, 0, 1611, 1609, 1, 0, 0, 0, 1612, 1603, 1, 0, 0, 0, 1612, 1613,
		1, 0, 0, 0, 1613, 1615, 1, 0, 0, 0, 1614, 1616, 3, 90, 45, 0, 1615, 1614,
		1, 0, 0, 0, 1615, 1616, 1, 0, 0, 0, 1616, 1620, 1, 0, 0, 0, 1617, 1618,
		5, 4, 0, 0, 1618, 1619, 5, 146, 0, 0, 1619, 1621, 3, 94, 47, 0, 1620, 1617,
		1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1623, 1, 0, 0, 0, 1622, 1624,
		7, 16, 0, 0, 1623, 1622, 1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1625,
		1, 0, 0, 0, 1625, 1626, 5, 189, 0, 0, 1626, 1627, 5, 313, 0, 0, 1627, 1628,
		3, 188, 94, 0, 1628, 1638, 5, 314, 0, 0, 1629, 1630, 5, 241, 0, 0, 1630,
		1635, 3, 96, 48, 0, 1631, 1632, 5, 312, 0, 0, 1632, 1634, 3, 96, 48, 0,
		1633, 1631, 1, 0, 0, 0, 1634, 1637, 1, 0, 0, 0, 1635, 1633, 1, 0, 0, 0,
		1635, 1636, 1, 0, 0, 0, 1636, 1639, 1, 0, 0, 0, 1637, 1635, 1, 0, 0, 0,
		1638, 1629, 1, 0, 0, 0, 1638, 1639, 1, 0, 0, 0, 1639, 1640, 1, 0, 0, 0,
		1640, 1641, 5, 54, 0, 0, 1641, 1646, 3, 98, 49, 0, 1642, 1643, 5, 312,
		0, 0, 1643, 1645, 3, 98, 49, 0, 1644, 1642, 1, 0, 0, 0, 1645, 1648, 1,
		0, 0, 0, 1646, 1644, 1, 0, 0, 0, 1646, 1647, 1, 0, 0, 0, 1647, 1649, 1,
		0, 0, 0, 1648, 1646, 1, 0, 0, 0, 1649, 1657, 5, 314, 0, 0, 1650, 1652,
		5, 11, 0, 0, 1651, 1650, 1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1653,
		1, 0, 0, 0, 1653, 1655, 3, 244, 122, 0, 1654, 1656, 3, 102, 51, 0, 1655,
		1654, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 0, 1656, 1658, 1, 0, 0, 0, 1657,
		1651, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1660, 1, 0, 0, 0, 1659,
		1577, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 87, 1, 0, 0, 0, 1661, 1662,
		3, 120, 60, 0, 1662, 1663, 5, 11, 0, 0, 1663, 1664, 3, 244, 122, 0, 1664,
		89, 1, 0, 0, 0, 1665, 1666, 5, 174, 0, 0, 1666, 1667, 5, 222, 0, 0, 1667,
		1668, 5, 190, 0, 0, 1668, 1677, 5, 146, 0, 0, 1669, 1670, 5, 5, 0, 0, 1670,
		1671, 5, 223, 0, 0, 1671, 1672, 5, 190, 0, 0, 1672, 1674, 5, 146, 0, 0,
		1673, 1675, 3, 92, 46, 0, 1674, 1673, 1, 0, 0, 0, 1674, 1675, 1, 0, 0,
		0, 1675, 1677, 1, 0, 0, 0, 1676, 1665, 1, 0, 0, 0, 1676, 1669, 1, 0, 0,
		0, 1677, 91, 1, 0, 0, 0, 1678, 1679, 5, 236, 0, 0, 1679, 1680, 5, 68, 0,
		0, 1680, 1688, 5, 148, 0, 0, 1681, 1682, 5, 172, 0, 0, 1682, 1683, 5, 68,
		0, 0, 1683, 1688, 5, 148, 0, 0, 1684, 1685, 5, 288, 0, 0, 1685, 1686, 5,
		268, 0, 0, 1686, 1688, 5, 223, 0, 0, 1687, 1678, 1, 0, 0, 0, 1687, 1681,
		1, 0, 0, 0, 1687, 1684, 1, 0, 0, 0, 1688, 93, 1, 0, 0, 0, 1689, 1702, 5,
		237, 0, 0, 1690, 1697, 5, 253, 0, 0, 1691, 1692, 5, 157, 0, 0, 1692, 1698,
		5, 222, 0, 0, 1693, 1695, 7, 10, 0, 0, 1694, 1693, 1, 0, 0, 0, 1694, 1695,
		1, 0, 0, 0, 1695, 1696, 1, 0, 0, 0, 1696, 1698, 3, 244, 122, 0, 1697, 1691,
		1, 0, 0, 0, 1697, 1694, 1, 0, 0, 0, 1698, 1703, 1, 0, 0, 0, 1699, 1700,
		5, 187, 0, 0, 1700, 1701, 5, 131, 0, 0, 1701, 1703, 5, 222, 0, 0, 1702,
		1690, 1, 0, 0, 0, 1702, 1699, 1, 0, 0, 0, 1703, 95, 1, 0, 0, 0, 1704, 1705,
		3, 244, 122, 0, 1705, 1706, 5, 296, 0, 0, 1706, 1707, 5, 313, 0, 0, 1707,
		1712, 3, 244, 122, 0, 1708, 1709, 5, 312, 0, 0, 1709, 1711, 3, 244, 122,
		0, 1710, 1708, 1, 0, 0, 0, 1711, 1714, 1, 0, 0, 0, 1712, 1710, 1, 0, 0,
		0, 1712, 1713, 1, 0, 0, 0, 1713, 1715, 1, 0, 0, 0, 1714, 1712, 1, 0, 0,
		0, 1715, 1716, 5, 314, 0, 0, 1716, 97, 1, 0, 0, 0, 1717, 1718, 3, 244,
		122, 0, 1718, 1719, 5, 11, 0, 0, 1719, 1720, 3, 120, 60, 0, 1720, 99, 1,
		0, 0, 0, 1721, 1729, 3, 104, 52, 0, 1722, 1724, 5, 11, 0, 0, 1723, 1722,
		1, 0, 0, 0, 1723, 1724, 1, 0, 0, 0, 1724, 1725, 1, 0, 0, 0, 1725, 1727,
		3, 244, 122, 0, 1726, 1728, 3, 102, 51, 0, 1727, 1726, 1, 0, 0, 0, 1727,
		1728, 1, 0, 0, 0, 1728, 1730, 1, 0, 0, 0, 1729, 1723, 1, 0, 0, 0, 1729,
		1730, 1, 0, 0, 0, 1730, 101, 1, 0, 0, 0, 1731, 1732, 5, 313, 0, 0, 1732,
		1737, 3, 244, 122, 0, 1733, 1734, 5, 312, 0, 0, 1734, 1736, 3, 244, 122,
		0, 1735, 1733, 1, 0, 0, 0, 1736, 1739, 1, 0, 0, 0, 1737, 1735, 1, 0, 0,
		0, 1737, 1738, 1, 0, 0, 0, 1738, 1740, 1, 0, 0, 0, 1739, 1737, 1, 0, 0,
		0, 1740, 1741, 5, 314, 0, 0, 1741, 103, 1, 0, 0, 0, 1742, 1744, 3, 232,
		116, 0, 1743, 1745, 3, 234, 117, 0, 1744, 1743, 1, 0, 0, 0, 1744, 1745,
		1, 0, 0, 0, 1745, 1780, 1, 0, 0, 0, 1746, 1747, 5, 313, 0, 0, 1747, 1748,
		3, 22, 11, 0, 1748, 1749, 5, 314, 0, 0, 1749, 1780, 1, 0, 0, 0, 1750, 1751,
		5, 269, 0, 0, 1751, 1752, 5, 313, 0, 0, 1752, 1757, 3, 120, 60, 0, 1753,
		1754, 5, 312, 0, 0, 1754, 1756, 3, 120, 60, 0, 1755, 1753, 1, 0, 0, 0,
		1756, 1759, 1, 0, 0, 0, 1757, 1755, 1, 0, 0, 0, 1757, 1758, 1, 0, 0, 0,
		1758, 1760, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1760, 1763, 5, 314, 0,
		0, 1761, 1762, 5, 288, 0, 0, 1762, 1764, 5, 179, 0, 0, 1763, 1761, 1, 0,
		0, 0, 1763, 1764, 1, 0, 0, 0, 1764, 1780, 1, 0, 0, 0, 1765, 1766, 5, 132,
		0, 0, 1766, 1767, 5, 313, 0, 0, 1767, 1768, 3, 22, 11, 0, 1768, 1769, 5,
		314, 0, 0, 1769, 1780, 1, 0, 0, 0, 1770, 1771, 5, 244, 0, 0, 1771, 1772,
		5, 313, 0, 0, 1772, 1773, 3, 106, 53, 0, 1773, 1774, 5, 314, 0, 0, 1774,
		1780, 1, 0, 0, 0, 1775, 1776, 5, 313, 0, 0, 1776, 1777, 3, 70, 35, 0, 1777,
		1778, 5, 314, 0, 0, 1778, 1780, 1, 0, 0, 0, 1779, 1742, 1, 0, 0, 0, 1779,
		1746, 1, 0, 0, 0, 1779, 1750, 1, 0, 0, 0, 1779, 1765, 1, 0, 0, 0, 1779,
		1770, 1, 0, 0, 0, 1779, 1775, 1, 0, 0, 0, 1780, 105, 1, 0, 0, 0, 1781,
		1782, 3, 232, 116, 0, 1782, 1791, 5, 313, 0, 0, 1783, 1788, 3, 108, 54,
		0, 1784, 1785, 5, 312, 0, 0, 1785, 1787, 3, 108, 54, 0, 1786, 1784, 1,
		0, 0, 0, 1787, 1790, 1, 0, 0, 0, 1788, 1786, 1, 0, 0, 0, 1788, 1789, 1,
		0, 0, 0, 1789, 1792, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1791, 1783, 1,
		0, 0, 0, 1791, 1792, 1, 0, 0, 0, 1792, 1802, 1, 0, 0, 0, 1793, 1794, 5,
		35, 0, 0, 1794, 1799, 3, 118, 59, 0, 1795, 1796, 5, 312, 0, 0, 1796, 1798,
		3, 118, 59, 0, 1797, 1795, 1, 0, 0, 0, 1798, 1801, 1, 0, 0, 0, 1799, 1797,
		1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 1803, 1, 0, 0, 0, 1801, 1799,
		1, 0, 0, 0, 1802, 1793, 1, 0, 0, 0, 1802, 1803, 1, 0, 0, 0, 1803, 1804,
		1, 0, 0, 0, 1804, 1805, 5, 314, 0, 0, 1805, 107, 1, 0, 0, 0, 1806, 1807,
		3, 244, 122, 0, 1807, 1808, 5, 323, 0, 0, 1808, 1810, 1, 0, 0, 0, 1809,
		1806, 1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0, 1810, 1814, 1, 0, 0, 0, 1811,
		1815, 3, 110, 55, 0, 1812, 1815, 3, 114, 57, 0, 1813, 1815, 3, 120, 60,
		0, 1814, 1811, 1, 0, 0, 0, 1814, 1812, 1, 0, 0, 0, 1814, 1813, 1, 0, 0,
		0, 1815, 109, 1, 0, 0, 0, 1816, 1834, 3, 112, 56, 0, 1817, 1818, 5, 184,
		0, 0, 1818, 1832, 5, 19, 0, 0, 1819, 1828, 5, 313, 0, 0, 1820, 1825, 3,
		120, 60, 0, 1821, 1822, 5, 312, 0, 0, 1822, 1824, 3, 120, 60, 0, 1823,
		1821, 1, 0, 0, 0, 1824, 1827, 1, 0, 0, 0, 1825, 1823, 1, 0, 0, 0, 1825,
		1826, 1, 0, 0, 0, 1826, 1829, 1, 0, 0, 0, 1827, 1825, 1, 0, 0, 0, 1828,
		1820, 1, 0, 0, 0, 1828, 1829, 1, 0, 0, 0, 1829, 1830, 1, 0, 0, 0, 1830,
		1833, 5, 314, 0, 0, 1831, 1833, 3, 120, 60, 0, 1832, 1819, 1, 0, 0, 0,
		1832, 1831, 1, 0, 0, 0, 1833, 1835, 1, 0, 0, 0, 1834, 1817, 1, 0, 0, 0,
		1834, 1835, 1, 0, 0, 0, 1835, 1842, 1, 0, 0, 0, 1836, 1837, 5, 200, 0,
		0, 1837, 1838, 5, 284, 0, 0, 1838, 1843, 5, 68, 0, 0, 1839, 1840, 5, 127,
		0, 0, 1840, 1841, 5, 284, 0, 0, 1841, 1843, 5, 68, 0, 0, 1842, 1836, 1,
		0, 0, 0, 1842, 1839, 1, 0, 0, 0, 1842, 1843, 1, 0, 0, 0, 1843, 1860, 1,
		0, 0, 0, 1844, 1845, 5, 178, 0, 0, 1845, 1858, 5, 19, 0, 0, 1846, 1847,
		5, 313, 0, 0, 1847, 1852, 3, 50, 25, 0, 1848, 1849, 5, 312, 0, 0, 1849,
		1851, 3, 50, 25, 0, 1850, 1848, 1, 0, 0, 0, 1851, 1854, 1, 0, 0, 0, 1852,
		1850, 1, 0, 0, 0, 1852, 1853, 1, 0, 0, 0, 1853, 1855, 1, 0, 0, 0, 1854,
		1852, 1, 0, 0, 0, 1855, 1856, 5, 314, 0, 0, 1856, 1859, 1, 0, 0, 0, 1857,
		1859, 3, 50, 25, 0, 1858, 1846, 1, 0, 0, 0, 1858, 1857, 1, 0, 0, 0, 1859,
		1861, 1, 0, 0, 0, 1860, 1844, 1, 0, 0, 0, 1860, 1861, 1, 0, 0, 0, 1861,
		111, 1, 0, 0, 0, 1862, 1863, 5, 244, 0, 0, 1863, 1864, 5, 313, 0, 0, 1864,
		1865, 3, 232, 116, 0, 1865, 1873, 5, 314, 0, 0, 1866, 1868, 5, 11, 0, 0,
		1867, 1866, 1, 0, 0, 0, 1867, 1868, 1, 0, 0, 0, 1868, 1869, 1, 0, 0, 0,
		1869, 1871, 3, 244, 122, 0, 1870, 1872, 3, 102, 51, 0, 1871, 1870, 1, 0,
		0, 0, 1871, 1872, 1, 0, 0, 0, 1872, 1874, 1, 0, 0, 0, 1873, 1867, 1, 0,
		0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 1889, 1, 0, 0, 0, 1875, 1876, 5, 244,
		0, 0, 1876, 1877, 5, 313, 0, 0, 1877, 1878, 3, 22, 11, 0, 1878, 1886, 5,
		314, 0, 0, 1879, 1881, 5, 11, 0, 0, 1880, 1879, 1, 0, 0, 0, 1880, 1881,
		1, 0, 0, 0, 1881, 1882, 1, 0, 0, 0, 1882, 1884, 3, 244, 122, 0, 1883, 1885,
		3, 102, 51, 0, 1884, 1883, 1, 0, 0, 0, 1884, 1885, 1, 0, 0, 0, 1885, 1887,
		1, 0, 0, 0, 1886, 1880, 1, 0, 0, 0, 1886, 1887, 1, 0, 0, 0, 1887, 1889,
		1, 0, 0, 0, 1888, 1862, 1, 0, 0, 0, 1888, 1875, 1, 0, 0, 0, 1889, 113,
		1, 0, 0, 0, 1890, 1891, 5, 60, 0, 0, 1891, 1892, 5, 313, 0, 0, 1892, 1897,
		3, 116, 58, 0, 1893, 1894, 5, 312, 0, 0, 1894, 1896, 3, 116, 58, 0, 1895,
		1893, 1, 0, 0, 0, 1896, 1899, 1, 0, 0, 0, 1897, 1895, 1, 0, 0, 0, 1897,
		1898, 1, 0, 0, 0, 1898, 1900, 1, 0, 0, 0, 1899, 1897, 1, 0, 0, 0, 1900,
		1901, 5, 314, 0, 0, 1901, 1909, 1, 0, 0, 0, 1902, 1903, 5, 24, 0, 0, 1903,
		1904, 5, 313, 0, 0, 1904, 1905, 5, 166, 0, 0, 1905, 1906, 5, 11, 0, 0,
		1906, 1907, 5, 60, 0, 0, 1907, 1909, 5, 314, 0, 0, 1908, 1890, 1, 0, 0,
		0, 1908, 1902, 1, 0, 0, 0, 1909, 115, 1, 0, 0, 0, 1910, 1912, 3, 244, 122,
		0, 1911, 1913, 3, 168, 84, 0, 1912, 1911, 1, 0, 0, 0, 1912, 1913, 1, 0,
		0, 0, 1913, 117, 1, 0, 0, 0, 1914, 1915, 5, 313, 0, 0, 1915, 1916, 3, 232,
		116, 0, 1916, 1917, 5, 312, 0, 0, 1917, 1922, 3, 232, 116, 0, 1918, 1919,
		5, 312, 0, 0, 1919, 1921, 3, 232, 116, 0, 1920, 1918, 1, 0, 0, 0, 1921,
		1924, 1, 0, 0, 0, 1922, 1920, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923,
		1925, 1, 0, 0, 0, 1924, 1922, 1, 0, 0, 0, 1925, 1926, 5, 314, 0, 0, 1926,
		119, 1, 0, 0, 0, 1927, 1928, 3, 122, 61, 0, 1928, 121, 1, 0, 0, 0, 1929,
		1930, 6, 61, -1, 0, 1930, 1932, 3, 126, 63, 0, 1931, 1933, 3, 124, 62,
		0, 1932, 1931, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933, 1937, 1, 0, 0,
		0, 1934, 1935, 5, 165, 0, 0, 1935, 1937, 3, 122, 61, 3, 1936, 1929, 1,
		0, 0, 0, 1936, 1934, 1, 0, 0, 0, 1937, 1946, 1, 0, 0, 0, 1938, 1939, 10,
		2, 0, 0, 1939, 1940, 5, 8, 0, 0, 1940, 1945, 3, 122, 61, 3, 1941, 1942,
		10, 1, 0, 0, 1942, 1943, 5, 177, 0, 0, 1943, 1945, 3, 122, 61, 2, 1944,
		1938, 1, 0, 0, 0, 1944, 1941, 1, 0, 0, 0, 1945, 1948, 1, 0, 0, 0, 1946,
		1944, 1, 0, 0, 0, 1946, 1947, 1, 0, 0, 0, 1947, 123, 1, 0, 0, 0, 1948,
		1946, 1, 0, 0, 0, 1949, 1950, 3, 156, 78, 0, 1950, 1951, 3, 126, 63, 0,
		1951, 2011, 1, 0, 0, 0, 1952, 1953, 3, 156, 78, 0, 1953, 1954, 3, 158,
		79, 0, 1954, 1955, 5, 313, 0, 0, 1955, 1956, 3, 22, 11, 0, 1956, 1957,
		5, 314, 0, 0, 1957, 2011, 1, 0, 0, 0, 1958, 1960, 5, 165, 0, 0, 1959, 1958,
		1, 0, 0, 0, 1959, 1960, 1, 0, 0, 0, 1960, 1961, 1, 0, 0, 0, 1961, 1962,
		5, 17, 0, 0, 1962, 1963, 3, 126, 63, 0, 1963, 1964, 5, 8, 0, 0, 1964, 1965,
		3, 126, 63, 0, 1965, 2011, 1, 0, 0, 0, 1966, 1968, 5, 165, 0, 0, 1967,
		1966, 1, 0, 0, 0, 1967, 1968, 1, 0, 0, 0, 1968, 1969, 1, 0, 0, 0, 1969,
		1970, 5, 105, 0, 0, 1970, 1971, 5, 313, 0, 0, 1971, 1976, 3, 120, 60, 0,
		1972, 1973, 5, 312, 0, 0, 1973, 1975, 3, 120, 60, 0, 1974, 1972, 1, 0,
		0, 0, 1975, 1978, 1, 0, 0, 0, 1976, 1974, 1, 0, 0, 0, 1976, 1977, 1, 0,
		0, 0, 1977, 1979, 1, 0, 0, 0, 1978, 1976, 1, 0, 0, 0, 1979, 1980, 5, 314,
		0, 0, 1980, 2011, 1, 0, 0, 0, 1981, 1983, 5, 165, 0, 0, 1982, 1981, 1,
		0, 0, 0, 1982, 1983, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 1985, 5,
		105, 0, 0, 1985, 1986, 5, 313, 0, 0, 1986, 1987, 3, 22, 11, 0, 1987, 1988,
		5, 314, 0, 0, 1988, 2011, 1, 0, 0, 0, 1989, 1991, 5, 165, 0, 0, 1990, 1989,
		1, 0, 0, 0, 1990, 1991, 1, 0, 0, 0, 1991, 1992, 1, 0, 0, 0, 1992, 1993,
		5, 137, 0, 0, 1993, 1996, 3, 126, 63, 0, 1994, 1995, 5, 73, 0, 0, 1995,
		1997, 3, 126, 63, 0, 1996, 1994, 1, 0, 0, 0, 1996, 1997, 1, 0, 0, 0, 1997,
		2011, 1, 0, 0, 0, 1998, 2000, 5, 116, 0, 0, 1999, 2001, 5, 165, 0, 0, 2000,
		1999, 1, 0, 0, 0, 2000, 2001, 1, 0, 0, 0, 2001, 2002, 1, 0, 0, 0, 2002,
		2011, 5, 166, 0, 0, 2003, 2005, 5, 116, 0, 0, 2004, 2006, 5, 165, 0, 0,
		2005, 2004, 1, 0, 0, 0, 2005, 2006, 1, 0, 0, 0, 2006, 2007, 1, 0, 0, 0,
		2007, 2008, 5, 62, 0, 0, 2008, 2009, 5, 88, 0, 0, 2009, 2011, 3, 126, 63,
		0, 2010, 1949, 1, 0, 0, 0, 2010, 1952, 1, 0, 0, 0, 2010, 1959, 1, 0, 0,
		0, 2010, 1967, 1, 0, 0, 0, 2010, 1982, 1, 0, 0, 0, 2010, 1990, 1, 0, 0,
		0, 2010, 1998, 1, 0, 0, 0, 2010, 2003, 1, 0, 0, 0, 2011, 125, 1, 0, 0,
		0, 2012, 2013, 6, 63, -1, 0, 2013, 2017, 3, 128, 64, 0, 2014, 2015, 7,
		17, 0, 0, 2015, 2017, 3, 126, 63, 4, 2016, 2012, 1, 0, 0, 0, 2016, 2014,
		1, 0, 0, 0, 2017, 2032, 1, 0, 0, 0, 2018, 2019, 10, 3, 0, 0, 2019, 2020,
		7, 18, 0, 0, 2020, 2031, 3, 126, 63, 4, 2021, 2022, 10, 2, 0, 0, 2022,
		2023, 7, 17, 0, 0, 2023, 2031, 3, 126, 63, 3, 2024, 2025, 10, 1, 0, 0,
		2025, 2026, 5, 307, 0, 0, 2026, 2031, 3, 126, 63, 2, 2027, 2028, 10, 5,
		0, 0, 2028, 2029, 5, 13, 0, 0, 2029, 2031, 3, 154, 77, 0, 2030, 2018, 1,
		0, 0, 0, 2030, 2021, 1, 0, 0, 0, 2030, 2024, 1, 0, 0, 0, 2030, 2027, 1,
		0, 0, 0, 2031, 2034, 1, 0, 0, 0, 2032, 2030, 1, 0, 0, 0, 2032, 2033, 1,
		0, 0, 0, 2033, 127, 1, 0, 0, 0, 2034, 2032, 1, 0, 0, 0, 2035, 2036, 6,
		64, -1, 0, 2036, 2489, 5, 166, 0, 0, 2037, 2489, 3, 162, 81, 0, 2038, 2039,
		3, 244, 122, 0, 2039, 2040, 3, 152, 76, 0, 2040, 2489, 1, 0, 0, 0, 2041,
		2042, 5, 65, 0, 0, 2042, 2043, 5, 196, 0, 0, 2043, 2489, 3, 152, 76, 0,
		2044, 2489, 3, 246, 123, 0, 2045, 2489, 3, 160, 80, 0, 2046, 2489, 3, 152,
		76, 0, 2047, 2489, 5, 329, 0, 0, 2048, 2489, 5, 308, 0, 0, 2049, 2050,
		5, 194, 0, 0, 2050, 2051, 5, 313, 0, 0, 2051, 2052, 3, 126, 63, 0, 2052,
		2053, 5, 105, 0, 0, 2053, 2054, 3, 126, 63, 0, 2054, 2055, 5, 314, 0, 0,
		2055, 2489, 1, 0, 0, 0, 2056, 2057, 5, 313, 0, 0, 2057, 2060, 3, 120, 60,
		0, 2058, 2059, 5, 312, 0, 0, 2059, 2061, 3, 120, 60, 0, 2060, 2058, 1,
		0, 0, 0, 2061, 2062, 1, 0, 0, 0, 2062, 2060, 1, 0, 0, 0, 2062, 2063, 1,
		0, 0, 0, 2063, 2064, 1, 0, 0, 0, 2064, 2065, 5, 314, 0, 0, 2065, 2489,
		1, 0, 0, 0, 2066, 2067, 5, 222, 0, 0, 2067, 2068, 5, 313, 0, 0, 2068, 2073,
		3, 120, 60, 0, 2069, 2070, 5, 312, 0, 0, 2070, 2072, 3, 120, 60, 0, 2071,
		2069, 1, 0, 0, 0, 2072, 2075, 1, 0, 0, 0, 2073, 2071, 1, 0, 0, 0, 2073,
		2074, 1, 0, 0, 0, 2074, 2076, 1, 0, 0, 0, 2075, 2073, 1, 0, 0, 0, 2076,
		2077, 5, 314, 0, 0, 2077, 2489, 1, 0, 0, 0, 2078, 2079, 5, 139, 0, 0, 2079,
		2081, 5, 313, 0, 0, 2080, 2082, 3, 66, 33, 0, 2081, 2080, 1, 0, 0, 0, 2081,
		2082, 1, 0, 0, 0, 2082, 2083, 1, 0, 0, 0, 2083, 2086, 3, 120, 60, 0, 2084,
		2085, 5, 312, 0, 0, 2085, 2087, 3, 152, 76, 0, 2086, 2084, 1, 0, 0, 0,
		2086, 2087, 1, 0, 0, 0, 2087, 2091, 1, 0, 0, 0, 2088, 2089, 5, 173, 0,
		0, 2089, 2090, 5, 183, 0, 0, 2090, 2092, 3, 82, 41, 0, 2091, 2088, 1, 0,
		0, 0, 2091, 2092, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 2094, 5, 314,
		0, 0, 2094, 2095, 5, 289, 0, 0, 2095, 2096, 5, 97, 0, 0, 2096, 2097, 5,
		313, 0, 0, 2097, 2098, 5, 178, 0, 0, 2098, 2099, 5, 19, 0, 0, 2099, 2104,
		3, 50, 25, 0, 2100, 2101, 5, 312, 0, 0, 2101, 2103, 3, 50, 25, 0, 2102,
		2100, 1, 0, 0, 0, 2103, 2106, 1, 0, 0, 0, 2104, 2102, 1, 0, 0, 0, 2104,
		2105, 1, 0, 0, 0, 2105, 2107, 1, 0, 0, 0, 2106, 2104, 1, 0, 0, 0, 2107,
		2108, 5, 314, 0, 0, 2108, 2110, 1, 0, 0, 0, 2109, 2111, 3, 176, 88, 0,
		2110, 2109, 1, 0, 0, 0, 2110, 2111, 1, 0, 0, 0, 2111, 2489, 1, 0, 0, 0,
		2112, 2114, 3, 148, 74, 0, 2113, 2112, 1, 0, 0, 0, 2113, 2114, 1, 0, 0,
		0, 2114, 2115, 1, 0, 0, 0, 2115, 2116, 3, 232, 116, 0, 2116, 2120, 5, 313,
		0, 0, 2117, 2118, 3, 244, 122, 0, 2118, 2119, 5, 310, 0, 0, 2119, 2121,
		1, 0, 0, 0, 2120, 2117, 1, 0, 0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2122,
		1, 0, 0, 0, 2122, 2123, 5, 304, 0, 0, 2123, 2125, 5, 314, 0, 0, 2124, 2126,
		3, 176, 88, 0, 2125, 2124, 1, 0, 0, 0, 2125, 2126, 1, 0, 0, 0, 2126, 2128,
		1, 0, 0, 0, 2127, 2129, 3, 180, 90, 0, 2128, 2127, 1, 0, 0, 0, 2128, 2129,
		1, 0, 0, 0, 2129, 2489, 1, 0, 0, 0, 2130, 2132, 3, 148, 74, 0, 2131, 2130,
		1, 0, 0, 0, 2131, 2132, 1, 0, 0, 0, 2132, 2133, 1, 0, 0, 0, 2133, 2134,
		3, 232, 116, 0, 2134, 2146, 5, 313, 0, 0, 2135, 2137, 3, 66, 33, 0, 2136,
		2135, 1, 0, 0, 0, 2136, 2137, 1, 0, 0, 0, 2137, 2138, 1, 0, 0, 0, 2138,
		2143, 3, 120, 60, 0, 2139, 2140, 5, 312, 0, 0, 2140, 2142, 3, 120, 60,
		0, 2141, 2139, 1, 0, 0, 0, 2142, 2145, 1, 0, 0, 0, 2143, 2141, 1, 0, 0,
		0, 2143, 2144, 1, 0, 0, 0, 2144, 2147, 1, 0, 0, 0, 2145, 2143, 1, 0, 0,
		0, 2146, 2136, 1, 0, 0, 0, 2146, 2147, 1, 0, 0, 0, 2147, 2158, 1, 0, 0,
		0, 2148, 2149, 5, 178, 0, 0, 2149, 2150, 5, 19, 0, 0, 2150, 2155, 3, 50,
		25, 0, 2151, 2152, 5, 312, 0, 0, 2152, 2154, 3, 50, 25, 0, 2153, 2151,
		1, 0, 0, 0, 2154, 2157, 1, 0, 0, 0, 2155, 2153, 1, 0, 0, 0, 2155, 2156,
		1, 0, 0, 0, 2156, 2159, 1, 0, 0, 0, 2157, 2155, 1, 0, 0, 0, 2158, 2148,
		1, 0, 0, 0, 2158, 2159, 1, 0, 0, 0, 2159, 2160, 1, 0, 0, 0, 2160, 2162,
		5, 314, 0, 0, 2161, 2163, 3, 176, 88, 0, 2162, 2161, 1, 0, 0, 0, 2162,
		2163, 1, 0, 0, 0, 2163, 2168, 1, 0, 0, 0, 2164, 2166, 3, 150, 75, 0, 2165,
		2164, 1, 0, 0, 0, 2165, 2166, 1, 0, 0, 0, 2166, 2167, 1, 0, 0, 0, 2167,
		2169, 3, 180, 90, 0, 2168, 2165, 1, 0, 0, 0, 2168, 2169, 1, 0, 0, 0, 2169,
		2489, 1, 0, 0, 0, 2170, 2171, 3, 244, 122, 0, 2171, 2172, 3, 180, 90, 0,
		2172, 2489, 1, 0, 0, 0, 2173, 2174, 3, 244, 122, 0, 2174, 2175, 5, 322,
		0, 0, 2175, 2176, 3, 120, 60, 0, 2176, 2489, 1, 0, 0, 0, 2177, 2186, 5,
		313, 0, 0, 2178, 2183, 3, 244, 122, 0, 2179, 2180, 5, 312, 0, 0, 2180,
		2182, 3, 244, 122, 0, 2181, 2179, 1, 0, 0, 0, 2182, 2185, 1, 0, 0, 0, 2183,
		2181, 1, 0, 0, 0, 2183, 2184, 1, 0, 0, 0, 2184, 2187, 1, 0, 0, 0, 2185,
		2183, 1, 0, 0, 0, 2186, 2178, 1, 0, 0, 0, 2186, 2187, 1, 0, 0, 0, 2187,
		2188, 1, 0, 0, 0, 2188, 2189, 5, 314, 0, 0, 2189, 2190, 5, 322, 0, 0, 2190,
		2489, 3, 120, 60, 0, 2191, 2192, 5, 313, 0, 0, 2192, 2193, 3, 22, 11, 0,
		2193, 2194, 5, 314, 0, 0, 2194, 2489, 1, 0, 0, 0, 2195, 2196, 5, 77, 0,
		0, 2196, 2197, 5, 313, 0, 0, 2197, 2198, 3, 22, 11, 0, 2198, 2199, 5, 314,
		0, 0, 2199, 2489, 1, 0, 0, 0, 2200, 2201, 5, 23, 0, 0, 2201, 2203, 3, 120,
		60, 0, 2202, 2204, 3, 174, 87, 0, 2203, 2202, 1, 0, 0, 0, 2204, 2205, 1,
		0, 0, 0, 2205, 2203, 1, 0, 0, 0, 2205, 2206, 1, 0, 0, 0, 2206, 2209, 1,
		0, 0, 0, 2207, 2208, 5, 67, 0, 0, 2208, 2210, 3, 120, 60, 0, 2209, 2207,
		1, 0, 0, 0, 2209, 2210, 1, 0, 0, 0, 2210, 2211, 1, 0, 0, 0, 2211, 2212,
		5, 71, 0, 0, 2212, 2489, 1, 0, 0, 0, 2213, 2215, 5, 23, 0, 0, 2214, 2216,
		3, 174, 87, 0, 2215, 2214, 1, 0, 0, 0, 2216, 2217, 1, 0, 0, 0, 2217, 2215,
		1, 0, 0, 0, 2217, 2218, 1, 0, 0, 0, 2218, 2221, 1, 0, 0, 0, 2219, 2220,
		5, 67, 0, 0, 2220, 2222, 3, 120, 60, 0, 2221, 2219, 1, 0, 0, 0, 2221, 2222,
		1, 0, 0, 0, 2222, 2223, 1, 0, 0, 0, 2223, 2224, 5, 71, 0, 0, 2224, 2489,
		1, 0, 0, 0, 2225, 2226, 5, 24, 0, 0, 2226, 2227, 5, 313, 0, 0, 2227, 2228,
		3, 120, 60, 0, 2228, 2229, 5, 11, 0, 0, 2229, 2230, 3, 168, 84, 0, 2230,
		2231, 5, 314, 0, 0, 2231, 2489, 1, 0, 0, 0, 2232, 2233, 5, 259, 0, 0, 2233,
		2234, 5, 313, 0, 0, 2234, 2235, 3, 120, 60, 0, 2235, 2236, 5, 11, 0, 0,
		2236, 2237, 3, 168, 84, 0, 2237, 2238, 5, 314, 0, 0, 2238, 2489, 1, 0,
		0, 0, 2239, 2240, 5, 10, 0, 0, 2240, 2249, 5, 315, 0, 0, 2241, 2246, 3,
		120, 60, 0, 2242, 2243, 5, 312, 0, 0, 2243, 2245, 3, 120, 60, 0, 2244,
		2242, 1, 0, 0, 0, 2245, 2248, 1, 0, 0, 0, 2246, 2244, 1, 0, 0, 0, 2246,
		2247, 1, 0, 0, 0, 2247, 2250, 1, 0, 0, 0, 2248, 2246, 1, 0, 0, 0, 2249,
		2241, 1, 0, 0, 0, 2249, 2250, 1, 0, 0, 0, 2250, 2251, 1, 0, 0, 0, 2251,
		2489, 5, 316, 0, 0, 2252, 2489, 3, 244, 122, 0, 2253, 2489, 5, 41, 0, 0,
		2254, 2258, 5, 45, 0, 0, 2255, 2256, 5, 313, 0, 0, 2256, 2257, 5, 330,
		0, 0, 2257, 2259, 5, 314, 0, 0, 2258, 2255, 1, 0, 0, 0, 2258, 2259, 1,
		0, 0, 0, 2259, 2489, 1, 0, 0, 0, 2260, 2264, 5, 46, 0, 0, 2261, 2262, 5,
		313, 0, 0, 2262, 2263, 5, 330, 0, 0, 2263, 2265, 5, 314, 0, 0, 2264, 2261,
		1, 0, 0, 0, 2264, 2265, 1, 0, 0, 0, 2265, 2489, 1, 0, 0, 0, 2266, 2270,
		5, 141, 0, 0, 2267, 2268, 5, 313, 0, 0, 2268, 2269, 5, 330, 0, 0, 2269,
		2271, 5, 314, 0, 0, 2270, 2267, 1, 0, 0, 0, 2270, 2271, 1, 0, 0, 0, 2271,
		2489, 1, 0, 0, 0, 2272, 2276, 5, 142, 0, 0, 2273, 2274, 5, 313, 0, 0, 2274,
		2275, 5, 330, 0, 0, 2275, 2277, 5, 314, 0, 0, 2276, 2273, 1, 0, 0, 0, 2276,
		2277, 1, 0, 0, 0, 2277, 2489, 1, 0, 0, 0, 2278, 2489, 5, 47, 0, 0, 2279,
		2489, 5, 40, 0, 0, 2280, 2489, 5, 44, 0, 0, 2281, 2489, 5, 42, 0, 0, 2282,
		2283, 5, 256, 0, 0, 2283, 2291, 5, 313, 0, 0, 2284, 2286, 3, 80, 40, 0,
		2285, 2284, 1, 0, 0, 0, 2285, 2286, 1, 0, 0, 0, 2286, 2288, 1, 0, 0, 0,
		2287, 2289, 3, 126, 63, 0, 2288, 2287, 1, 0, 0, 0, 2288, 2289, 1, 0, 0,
		0, 2289, 2290, 1, 0, 0, 0, 2290, 2292, 5, 88, 0, 0, 2291, 2285, 1, 0, 0,
		0, 2291, 2292, 1, 0, 0, 0, 2292, 2293, 1, 0, 0, 0, 2293, 2294, 3, 126,
		63, 0, 2294, 2295, 5, 314, 0, 0, 2295, 2489, 1, 0, 0, 0, 2296, 2297, 5,
		256, 0, 0, 2297, 2298, 5, 313, 0, 0, 2298, 2299, 3, 126, 63, 0, 2299, 2300,
		5, 312, 0, 0, 2300, 2301, 3, 126, 63, 0, 2301, 2302, 5, 314, 0, 0, 2302,
		2489, 1, 0, 0, 0, 2303, 2304, 5, 242, 0, 0, 2304, 2305, 5, 313, 0, 0, 2305,
		2306, 3, 126, 63, 0, 2306, 2307, 5, 88, 0, 0, 2307, 2310, 3, 126, 63, 0,
		2308, 2309, 5, 86, 0, 0, 2309, 2311, 3, 126, 63, 0, 2310, 2308, 1, 0, 0,
		0, 2310, 2311, 1, 0, 0, 0, 2311, 2312, 1, 0, 0, 0, 2312, 2313, 5, 314,
		0, 0, 2313, 2489, 1, 0, 0, 0, 2314, 2315, 5, 164, 0, 0, 2315, 2316, 5,
		313, 0, 0, 2316, 2319, 3, 126, 63, 0, 2317, 2318, 5, 312, 0, 0, 2318, 2320,
		3, 166, 83, 0, 2319, 2317, 1, 0, 0, 0, 2319, 2320, 1, 0, 0, 0, 2320, 2321,
		1, 0, 0, 0, 2321, 2322, 5, 314, 0, 0, 2322, 2489, 1, 0, 0, 0, 2323, 2324,
		5, 79, 0, 0, 2324, 2325, 5, 313, 0, 0, 2325, 2326, 3, 244, 122, 0, 2326,
		2327, 5, 88, 0, 0, 2327, 2328, 3, 126, 63, 0, 2328, 2329, 5, 314, 0, 0,
		2329, 2489, 1, 0, 0, 0, 2330, 2331, 5, 313, 0, 0, 2331, 2332, 3, 120, 60,
		0, 2332, 2333, 5, 314, 0, 0, 2333, 2489, 1, 0, 0, 0, 2334, 2335, 5, 98,
		0, 0, 2335, 2344, 5, 313, 0, 0, 2336, 2341, 3, 232, 116, 0, 2337, 2338,
		5, 312, 0, 0, 2338, 2340, 3, 232, 116, 0, 2339, 2337, 1, 0, 0, 0, 2340,
		2343, 1, 0, 0, 0, 2341, 2339, 1, 0, 0, 0, 2341, 2342, 1, 0, 0, 0, 2342,
		2345, 1, 0, 0, 0, 2343, 2341, 1, 0, 0, 0, 2344, 2336, 1, 0, 0, 0, 2344,
		2345, 1, 0, 0, 0, 2345, 2346, 1, 0, 0, 0, 2346, 2489, 5, 314, 0, 0, 2347,
		2348, 5, 122, 0, 0, 2348, 2349, 5, 313, 0, 0, 2349, 2354, 3, 130, 65, 0,
		2350, 2351, 3, 138, 69, 0, 2351, 2352, 5, 173, 0, 0, 2352, 2353, 5, 72,
		0, 0, 2353, 2355, 1, 0, 0, 0, 2354, 2350, 1, 0, 0, 0, 2354, 2355, 1, 0,
		0, 0, 2355, 2356, 1, 0, 0, 0, 2356, 2357, 5, 314, 0, 0, 2357, 2489, 1,
		0, 0, 0, 2358, 2359, 5, 126, 0, 0, 2359, 2360, 5, 313, 0, 0, 2360, 2363,
		3, 130, 65, 0, 2361, 2362, 5, 214, 0, 0, 2362, 2364, 3, 168, 84, 0, 2363,
		2361, 1, 0, 0, 0, 2363, 2364, 1, 0, 0, 0, 2364, 2369, 1, 0, 0, 0, 2365,
		2366, 3, 140, 70, 0, 2366, 2367, 5, 173, 0, 0, 2367, 2368, 5, 68, 0, 0,
		2368, 2370, 1, 0, 0, 0, 2369, 2365, 1, 0, 0, 0, 2369, 2370, 1, 0, 0, 0,
		2370, 2375, 1, 0, 0, 0, 2371, 2372, 3, 140, 70, 0, 2372, 2373, 5, 173,
		0, 0, 2373, 2374, 5, 72, 0, 0, 2374, 2376, 1, 0, 0, 0, 2375, 2371, 1, 0,
		0, 0, 2375, 2376, 1, 0, 0, 0, 2376, 2377, 1, 0, 0, 0, 2377, 2378, 5, 314,
		0, 0, 2378, 2489, 1, 0, 0, 0, 2379, 2380, 5, 124, 0, 0, 2380, 2381, 5,
		313, 0, 0, 2381, 2388, 3, 130, 65, 0, 2382, 2383, 5, 214, 0, 0, 2383, 2386,
		3, 168, 84, 0, 2384, 2385, 5, 87, 0, 0, 2385, 2387, 3, 134, 67, 0, 2386,
		2384, 1, 0, 0, 0, 2386, 2387, 1, 0, 0, 0, 2387, 2389, 1, 0, 0, 0, 2388,
		2382, 1, 0, 0, 0, 2388, 2389, 1, 0, 0, 0, 2389, 2393, 1, 0, 0, 0, 2390,
		2391, 3, 142, 71, 0, 2391, 2392, 5, 292, 0, 0, 2392, 2394, 1, 0, 0, 0,
		2393, 2390, 1, 0, 0, 0, 2393, 2394, 1, 0, 0, 0, 2394, 2402, 1, 0, 0, 0,
		2395, 2396, 7, 19, 0, 0, 2396, 2400, 5, 201, 0, 0, 2397, 2398, 5, 173,
		0, 0, 2398, 2399, 5, 225, 0, 0, 2399, 2401, 5, 248, 0, 0, 2400, 2397, 1,
		0, 0, 0, 2400, 2401, 1, 0, 0, 0, 2401, 2403, 1, 0, 0, 0, 2402, 2395, 1,
		0, 0, 0, 2402, 2403, 1, 0, 0, 0, 2403, 2408, 1, 0, 0, 0, 2404, 2405, 3,
		144, 72, 0, 2405, 2406, 5, 173, 0, 0, 2406, 2407, 5, 68, 0, 0, 2407, 2409,
		1, 0, 0, 0, 2408, 2404, 1, 0, 0, 0, 2408, 2409, 1, 0, 0, 0, 2409, 2414,
		1, 0, 0, 0, 2410, 2411, 3, 144, 72, 0, 2411, 2412, 5, 173, 0, 0, 2412,
		2413, 5, 72, 0, 0, 2413, 2415, 1, 0, 0, 0, 2414, 2410, 1, 0, 0, 0, 2414,
		2415, 1, 0, 0, 0, 2415, 2416, 1, 0, 0, 0, 2416, 2417, 5, 314, 0, 0, 2417,
		2489, 1, 0, 0, 0, 2418, 2419, 5, 123, 0, 0, 2419, 2448, 5, 313, 0, 0, 2420,
		2425, 3, 146, 73, 0, 2421, 2422, 5, 312, 0, 0, 2422, 2424, 3, 146, 73,
		0, 2423, 2421, 1, 0, 0, 0, 2424, 2427, 1, 0, 0, 0, 2425, 2423, 1, 0, 0,
		0, 2425, 2426, 1, 0, 0, 0, 2426, 2434, 1, 0, 0, 0, 2427, 2425, 1, 0, 0,
		0, 2428, 2429, 5, 166, 0, 0, 2429, 2430, 5, 173, 0, 0, 2430, 2435, 5, 166,
		0, 0, 2431, 2432, 5, 1, 0, 0, 2432, 2433, 5, 173, 0, 0, 2433, 2435, 5,
		166, 0, 0, 2434, 2428, 1, 0, 0, 0, 2434, 2431, 1, 0, 0, 0, 2434, 2435,
		1, 0, 0, 0, 2435, 2446, 1, 0, 0, 0, 2436, 2437, 5, 288, 0, 0, 2437, 2439,
		5, 266, 0, 0, 2438, 2440, 5, 129, 0, 0, 2439, 2438, 1, 0, 0, 0, 2439, 2440,
		1, 0, 0, 0, 2440, 2447, 1, 0, 0, 0, 2441, 2442, 5, 290, 0, 0, 2442, 2444,
		5, 266, 0, 0, 2443, 2445, 5, 129, 0, 0, 2444, 2443, 1, 0, 0, 0, 2444, 2445,
		1, 0, 0, 0, 2445, 2447, 1, 0, 0, 0, 2446, 2436, 1, 0, 0, 0, 2446, 2441,
		1, 0, 0, 0, 2446, 2447, 1, 0, 0, 0, 2447, 2449, 1, 0, 0, 0, 2448, 2420,
		1, 0, 0, 0, 2448, 2449, 1, 0, 0, 0, 2449, 2456, 1, 0, 0, 0, 2450, 2451,
		5, 214, 0, 0, 2451, 2454, 3, 168, 84, 0, 2452, 2453, 5, 87, 0, 0, 2453,
		2455, 3, 134, 67, 0, 2454, 2452, 1, 0, 0, 0, 2454, 2455, 1, 0, 0, 0, 2455,
		2457, 1, 0, 0, 0, 2456, 2450, 1, 0, 0, 0, 2456, 2457, 1, 0, 0, 0, 2457,
		2458, 1, 0, 0, 0, 2458, 2489, 5, 314, 0, 0, 2459, 2460, 5, 121, 0, 0, 2460,
		2477, 5, 313, 0, 0, 2461, 2466, 3, 132, 66, 0, 2462, 2463, 5, 312, 0, 0,
		2463, 2465, 3, 132, 66, 0, 2464, 2462, 1, 0, 0, 0, 2465, 2468, 1, 0, 0,
		0, 2466, 2464, 1, 0, 0, 0, 2466, 2467, 1, 0, 0, 0, 2467, 2475, 1, 0, 0,
		0, 2468, 2466, 1, 0, 0, 0, 2469, 2470, 5, 166, 0, 0, 2470, 2471, 5, 173,
		0, 0, 2471, 2476, 5, 166, 0, 0, 2472, 2473, 5, 1, 0, 0, 2473, 2474, 5,
		173, 0, 0, 2474, 2476, 5, 166, 0, 0, 2475, 2469, 1, 0, 0, 0, 2475, 2472,
		1, 0, 0, 0, 2475, 2476, 1, 0, 0, 0, 2476, 2478, 1, 0, 0, 0, 2477, 2461,
		1, 0, 0, 0, 2477, 2478, 1, 0, 0, 0, 2478, 2485, 1, 0, 0, 0, 2479, 2480,
		5, 214, 0, 0, 2480, 2483, 3, 168, 84, 0, 2481, 2482, 5, 87, 0, 0, 2482,
		2484, 3, 134, 67, 0, 2483, 2481, 1, 0, 0, 0, 2483, 2484, 1, 0, 0, 0, 2484,
		2486, 1, 0, 0, 0, 2485, 2479, 1, 0, 0, 0, 2485, 2486, 1, 0, 0, 0, 2486,
		2487, 1, 0, 0, 0, 2487, 2489, 5, 314, 0, 0, 2488, 2035, 1, 0, 0, 0, 2488,
		2037, 1, 0, 0, 0, 2488, 2038, 1, 0, 0, 0, 2488, 2041, 1, 0, 0, 0, 2488,
		2044, 1, 0, 0, 0, 2488, 2045, 1, 0, 0, 0, 2488, 2046, 1, 0, 0, 0, 2488,
		2047, 1, 0, 0, 0, 2488, 2048, 1, 0, 0, 0, 2488, 2049, 1, 0, 0, 0, 2488,
		2056, 1, 0, 0, 0, 2488, 2066, 1, 0, 0, 0, 2488, 2078, 1, 0, 0, 0, 2488,
		2113, 1, 0, 0, 0, 2488, 2131, 1, 0, 0, 0, 2488, 2170, 1, 0, 0, 0, 2488,
		2173, 1, 0, 0, 0, 2488, 2177, 1, 0, 0, 0, 2488, 2191, 1, 0, 0, 0, 2488,
		2195, 1, 0, 0, 0, 2488, 2200, 1, 0, 0, 0, 2488, 2213, 1, 0, 0, 0, 2488,
		2225, 1, 0, 0, 0, 2488, 2232, 1, 0, 0, 0, 2488, 2239, 1, 0, 0, 0, 2488,
		2252, 1, 0, 0, 0, 2488, 2253, 1, 0, 0, 0, 2488, 2254, 1, 0, 0, 0, 2488,
		2260, 1, 0, 0, 0, 2488, 2266, 1, 0, 0, 0, 2488, 2272, 1, 0, 0, 0, 2488,
		2278, 1, 0, 0, 0, 2488, 2279, 1, 0, 0, 0, 2488, 2280, 1, 0, 0, 0, 2488,
		2281, 1, 0, 0, 0, 2488, 2282, 1, 0, 0, 0, 2488, 2296, 1, 0, 0, 0, 2488,
		2303, 1, 0, 0, 0, 2488, 2314, 1, 0, 0, 0, 2488, 2323, 1, 0, 0, 0, 2488,
		2330, 1, 0, 0, 0, 2488, 2334, 1, 0, 0, 0, 2488, 2347, 1, 0, 0, 0, 2488,
		2358, 1, 0, 0, 0, 2488, 2379, 1, 0, 0, 0, 2488, 2418, 1, 0, 0, 0, 2488,
		2459, 1, 0, 0, 0, 2489, 2500, 1, 0, 0, 0, 2490, 2491, 10, 24, 0, 0, 2491,
		2492, 5, 315, 0, 0, 2492, 2493, 3, 126, 63, 0, 2493, 2494, 5, 316, 0, 0,
		2494, 2499, 1, 0, 0, 0, 2495, 2496, 10, 22, 0, 0, 2496, 2497, 5, 310, 0,
		0, 2497, 2499, 3, 244, 122, 0, 2498, 2490, 1, 0, 0, 0, 2498, 2495, 1, 0,
		0, 0, 2499, 2502, 1, 0, 0, 0, 2500, 2498, 1, 0, 0, 0, 2500, 2501, 1, 0,
		0, 0, 2501, 129, 1, 0, 0, 0, 2502, 2500, 1, 0, 0, 0, 2503, 2504, 3, 132,
		66, 0, 2504, 2505, 5, 312, 0, 0, 2505, 2515, 3, 152, 76, 0, 2506, 2507,
		5, 186, 0, 0, 2507, 2512, 3, 136, 68, 0, 2508, 2509, 5, 312, 0, 0, 2509,
		2511, 3, 136, 68, 0, 2510, 2508, 1, 0, 0, 0, 2511, 2514, 1, 0, 0, 0, 2512,
		2510, 1, 0, 0, 0, 2512, 2513, 1, 0, 0, 0, 2513, 2516, 1, 0, 0, 0, 2514,
		2512, 1, 0, 0, 0, 2515, 2506, 1, 0, 0, 0, 2515, 2516, 1, 0, 0, 0, 2516,
		131, 1, 0, 0, 0, 2517, 2520, 3, 120, 60, 0, 2518, 2519, 5, 87, 0, 0, 2519,
		2521, 3, 134, 67, 0, 2520, 2518, 1, 0, 0, 0, 2520, 2521, 1, 0, 0, 0, 2521,
		133, 1, 0, 0, 0, 2522, 2525, 5, 120, 0, 0, 2523, 2524, 5, 70, 0, 0, 2524,
		2526, 7, 20, 0, 0, 2525, 2523, 1, 0, 0, 0, 2525, 2526, 1, 0, 0, 0, 2526,
		135, 1, 0, 0, 0, 2527, 2528, 3, 132, 66, 0, 2528, 2529, 5, 11, 0, 0, 2529,
		2530, 3, 244, 122, 0, 2530, 137, 1, 0, 0, 0, 2531, 2532, 7, 21, 0, 0, 2532,
		139, 1, 0, 0, 0, 2533, 2538, 5, 72, 0, 0, 2534, 2538, 5, 166, 0, 0, 2535,
		2536, 5, 53, 0, 0, 2536, 2538, 3, 120, 60, 0, 2537, 2533, 1, 0, 0, 0, 2537,
		2534, 1, 0, 0, 0, 2537, 2535, 1, 0, 0, 0, 2538, 141, 1, 0, 0, 0, 2539,
		2541, 5, 290, 0, 0, 2540, 2542, 5, 10, 0, 0, 2541, 2540, 1, 0, 0, 0, 2541,
		2542, 1, 0, 0, 0, 2542, 2551, 1, 0, 0, 0, 2543, 2545, 5, 288, 0, 0, 2544,
		2546, 7, 22, 0, 0, 2545, 2544, 1, 0, 0, 0, 2545, 2546, 1, 0, 0, 0, 2546,
		2548, 1, 0, 0, 0, 2547, 2549, 5, 10, 0, 0, 2548, 2547, 1, 0, 0, 0, 2548,
		2549, 1, 0, 0, 0, 2549, 2551, 1, 0, 0, 0, 2550, 2539, 1, 0, 0, 0, 2550,
		2543, 1, 0, 0, 0, 2551, 143, 1, 0, 0, 0, 2552, 2557, 5, 72, 0, 0, 2553,
		2557, 5, 166, 0, 0, 2554, 2555, 5, 68, 0, 0, 2555, 2557, 7, 23, 0, 0, 2556,
		2552, 1, 0, 0, 0, 2556, 2553, 1, 0, 0, 0, 2556, 2554, 1, 0, 0, 0, 2557,
		145, 1, 0, 0, 0, 2558, 2560, 5, 128, 0, 0, 2559, 2558, 1, 0, 0, 0, 2559,
		2560, 1, 0, 0, 0, 2560, 2561, 1, 0, 0, 0, 2561, 2562, 3, 120, 60, 0, 2562,
		2563, 5, 279, 0, 0, 2563, 2564, 3, 132, 66, 0, 2564, 2570, 1, 0, 0, 0,
		2565, 2566, 3, 120, 60, 0, 2566, 2567, 5, 311, 0, 0, 2567, 2568, 3, 132,
		66, 0, 2568, 2570, 1, 0, 0, 0, 2569, 2559, 1, 0, 0, 0, 2569, 2565, 1, 0,
		0, 0, 2570, 147, 1, 0, 0, 0, 2571, 2572, 7, 24, 0, 0, 2572, 149, 1, 0,
		0, 0, 2573, 2574, 5, 103, 0, 0, 2574, 2578, 5, 168, 0, 0, 2575, 2576, 5,
		211, 0, 0, 2576, 2578, 5, 168, 0, 0, 2577, 2573, 1, 0, 0, 0, 2577, 2575,
		1, 0, 0, 0, 2578, 151, 1, 0, 0, 0, 2579, 2586, 5, 327, 0, 0, 2580, 2583,
		5, 328, 0, 0, 2581, 2582, 5, 261, 0, 0, 2582, 2584, 5, 327, 0, 0, 2583,
		2581, 1, 0, 0, 0, 2583, 2584, 1, 0, 0, 0, 2584, 2586, 1, 0, 0, 0, 2585,
		2579, 1, 0, 0, 0, 2585, 2580, 1, 0, 0, 0, 2586, 153, 1, 0, 0, 0, 2587,
		2588, 5, 251, 0, 0, 2588, 2589, 5, 295, 0, 0, 2589, 2594, 3, 162, 81, 0,
		2590, 2591, 5, 251, 0, 0, 2591, 2592, 5, 295, 0, 0, 2592, 2594, 3, 152,
		76, 0, 2593, 2587, 1, 0, 0, 0, 2593, 2590, 1, 0, 0, 0, 2594, 155, 1, 0,
		0, 0, 2595, 2596, 7, 25, 0, 0, 2596, 157, 1, 0, 0, 0, 2597, 2598, 7, 26,
		0, 0, 2598, 159, 1, 0, 0, 0, 2599, 2600, 7, 27, 0, 0, 2600, 161, 1, 0,
		0, 0, 2601, 2603, 5, 112, 0, 0, 2602, 2604, 7, 17, 0, 0, 2603, 2602, 1,
		0, 0, 0, 2603, 2604, 1, 0, 0, 0, 2604, 2605, 1, 0, 0, 0, 2605, 2606, 3,
		152, 76, 0, 2606, 2609, 3, 164, 82, 0, 2607, 2608, 5, 253, 0, 0, 2608,
		2610, 3, 164, 82, 0, 2609, 2607, 1, 0, 0, 0, 2609, 2610, 1, 0, 0, 0, 2610,
		163, 1, 0, 0, 0, 2611, 2612, 7, 28, 0, 0, 2612, 165, 1, 0, 0, 0, 2613,
		2614, 7, 29, 0, 0, 2614, 167, 1, 0, 0, 0, 2615, 2616, 6, 84, -1, 0, 2616,
		2617, 5, 222, 0, 0, 2617, 2618, 5, 313, 0, 0, 2618, 2623, 3, 170, 85, 0,
		2619, 2620, 5, 312, 0, 0, 2620, 2622, 3, 170, 85, 0, 2621, 2619, 1, 0,
		0, 0, 2622, 2625, 1, 0, 0, 0, 2623, 2621, 1, 0, 0, 0, 2623, 2624, 1, 0,
		0, 0, 2624, 2626, 1, 0, 0, 0, 2625, 2623, 1, 0, 0, 0, 2626, 2627, 5, 314,
		0, 0, 2627, 2707, 1, 0, 0, 0, 2628, 2629, 5, 112, 0, 0, 2629, 2632, 3,
		164, 82, 0, 2630, 2631, 5, 253, 0, 0, 2631, 2633, 3, 164, 82, 0, 2632,
		2630, 1, 0, 0, 0, 2632, 2633, 1, 0, 0, 0, 2633, 2707, 1, 0, 0, 0, 2634,
		2639, 5, 252, 0, 0, 2635, 2636, 5, 313, 0, 0, 2636, 2637, 3, 172, 86, 0,
		2637, 2638, 5, 314, 0, 0, 2638, 2640, 1, 0, 0, 0, 2639, 2635, 1, 0, 0,
		0, 2639, 2640, 1, 0, 0, 0, 2640, 2644, 1, 0, 0, 0, 2641, 2642, 5, 290,
		0, 0, 2642, 2643, 5, 251, 0, 0, 2643, 2645, 5, 295, 0, 0, 2644, 2641, 1,
		0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645, 2707, 1, 0, 0, 0, 2646, 2651, 5,
		252, 0, 0, 2647, 2648, 5, 313, 0, 0, 2648, 2649, 3, 172, 86, 0, 2649, 2650,
		5, 314, 0, 0, 2650, 2652, 1, 0, 0, 0, 2651, 2647, 1, 0, 0, 0, 2651, 2652,
		1, 0, 0, 0, 2652, 2653, 1, 0, 0, 0, 2653, 2654, 5, 288, 0, 0, 2654, 2655,
		5, 251, 0, 0, 2655, 2707, 5, 295, 0, 0, 2656, 2661, 5, 251, 0, 0, 2657,
		2658, 5, 313, 0, 0, 2658, 2659, 3, 172, 86, 0, 2659, 2660, 5, 314, 0, 0,
		2660, 2662, 1, 0, 0, 0, 2661, 2657, 1, 0, 0, 0, 2661, 2662, 1, 0, 0, 0,
		2662, 2666, 1, 0, 0, 0, 2663, 2664, 5, 290, 0, 0, 2664, 2665, 5, 251, 0,
		0, 2665, 2667, 5, 295, 0, 0, 2666, 2663, 1, 0, 0, 0, 2666, 2667, 1, 0,
		0, 0, 2667, 2707, 1, 0, 0, 0, 2668, 2673, 5, 251, 0, 0, 2669, 2670, 5,
		313, 0, 0, 2670, 2671, 3, 172, 86, 0, 2671, 2672, 5, 314, 0, 0, 2672, 2674,
		1, 0, 0, 0, 2673, 2669, 1, 0, 0, 0, 2673, 2674, 1, 0, 0, 0, 2674, 2675,
		1, 0, 0, 0, 2675, 2676, 5, 288, 0, 0, 2676, 2677, 5, 251, 0, 0, 2677, 2707,
		5, 295, 0, 0, 2678, 2679, 5, 65, 0, 0, 2679, 2707, 5, 196, 0, 0, 2680,
		2681, 5, 10, 0, 0, 2681, 2682, 5, 298, 0, 0, 2682, 2683, 3, 168, 84, 0,
		2683, 2684, 5, 300, 0, 0, 2684, 2707, 1, 0, 0, 0, 2685, 2686, 5, 145, 0,
		0, 2686, 2687, 5, 298, 0, 0, 2687, 2688, 3, 168, 84, 0, 2688, 2689, 5,
		312, 0, 0, 2689, 2690, 3, 168, 84, 0, 2690, 2691, 5, 300, 0, 0, 2691, 2707,
		1, 0, 0, 0, 2692, 2704, 3, 244, 122, 0, 2693, 2694, 5, 313, 0, 0, 2694,
		2699, 3, 172, 86, 0, 2695, 2696, 5, 312, 0, 0, 2696, 2698, 3, 172, 86,
		0, 2697, 2695, 1, 0, 0, 0, 2698, 2701, 1, 0, 0, 0, 2699, 2697, 1, 0, 0,
		0, 2699, 2700, 1, 0, 0, 0, 2700, 2702, 1, 0, 0, 0, 2701, 2699, 1, 0, 0,
		0, 2702, 2703, 5, 314, 0, 0, 2703, 2705, 1, 0, 0, 0, 2704, 2693, 1, 0,
		0, 0, 2704, 2705, 1, 0, 0, 0, 2705, 2707, 1, 0, 0, 0, 2706, 2615, 1, 0,
		0, 0, 2706, 2628, 1, 0, 0, 0, 2706, 2634, 1, 0, 0, 0, 2706, 2646, 1, 0,
		0, 0, 2706, 2656, 1, 0, 0, 0, 2706, 2668, 1, 0, 0, 0, 2706, 2678, 1, 0,
		0, 0, 2706, 2680, 1, 0, 0, 0, 2706, 2685, 1, 0, 0, 0, 2706, 2692, 1, 0,
		0, 0, 2707, 2717, 1, 0, 0, 0, 2708, 2709, 10, 2, 0, 0, 2709, 2713, 5, 10,
		0, 0, 2710, 2711, 5, 315, 0, 0, 2711, 2712, 5, 330, 0, 0, 2712, 2714, 5,
		316, 0, 0, 2713, 2710, 1, 0, 0, 0, 2713, 2714, 1, 0, 0, 0, 2714, 2716,
		1, 0, 0, 0, 2715, 2708, 1, 0, 0, 0, 2716, 2719, 1, 0, 0, 0, 2717, 2715,
		1, 0, 0, 0, 2717, 2718, 1, 0, 0, 0, 2718, 169, 1, 0, 0, 0, 2719, 2717,
		1, 0, 0, 0, 2720, 2725, 3, 168, 84, 0, 2721, 2722, 3, 244, 122, 0, 2722,
		2723, 3, 168, 84, 0, 2723, 2725, 1, 0, 0, 0, 2724, 2720, 1, 0, 0, 0, 2724,
		2721, 1, 0, 0, 0, 2725, 171, 1, 0, 0, 0, 2726, 2729, 5, 330, 0, 0, 2727,
		2729, 3, 168, 84, 0, 2728, 2726, 1, 0, 0, 0, 2728, 2727, 1, 0, 0, 0, 2729,
		173, 1, 0, 0, 0, 2730, 2731, 5, 284, 0, 0, 2731, 2732, 3, 120, 60, 0, 2732,
		2733, 5, 249, 0, 0, 2733, 2734, 3, 120, 60, 0, 2734, 175, 1, 0, 0, 0, 2735,
		2736, 5, 82, 0, 0, 2736, 2737, 5, 313, 0, 0, 2737, 2738, 5, 285, 0, 0,
		2738, 2739, 3, 122, 61, 0, 2739, 2740, 5, 314, 0, 0, 2740, 177, 1, 0, 0,
		0, 2741, 2742, 5, 284, 0, 0, 2742, 2745, 5, 147, 0, 0, 2743, 2744, 5, 8,
		0, 0, 2744, 2746, 3, 120, 60, 0, 2745, 2743, 1, 0, 0, 0, 2745, 2746, 1,
		0, 0, 0, 2746, 2747, 1, 0, 0, 0, 2747, 2748, 5, 249, 0, 0, 2748, 2749,
		5, 271, 0, 0, 2749, 2750, 5, 234, 0, 0, 2750, 2751, 3, 244, 122, 0, 2751,
		2752, 5, 296, 0, 0, 2752, 2760, 3, 120, 60, 0, 2753, 2754, 5, 312, 0, 0,
		2754, 2755, 3, 244, 122, 0, 2755, 2756, 5, 296, 0, 0, 2756, 2757, 3, 120,
		60, 0, 2757, 2759, 1, 0, 0, 0, 2758, 2753, 1, 0, 0, 0, 2759, 2762, 1, 0,
		0, 0, 2760, 2758, 1, 0, 0, 0, 2760, 2761, 1, 0, 0, 0, 2761, 2806, 1, 0,
		0, 0, 2762, 2760, 1, 0, 0, 0, 2763, 2764, 5, 284, 0, 0, 2764, 2767, 5,
		147, 0, 0, 2765, 2766, 5, 8, 0, 0, 2766, 2768, 3, 120, 60, 0, 2767, 2765,
		1, 0, 0, 0, 2767, 2768, 1, 0, 0, 0, 2768, 2769, 1, 0, 0, 0, 2769, 2770,
		5, 249, 0, 0, 2770, 2806, 5, 56, 0, 0, 2771, 2772, 5, 284, 0, 0, 2772,
		2773, 5, 165, 0, 0, 2773, 2776, 5, 147, 0, 0, 2774, 2775, 5, 8, 0, 0, 2775,
		2777, 3, 120, 60, 0, 2776, 2774, 1, 0, 0, 0, 2776, 2777, 1, 0, 0, 0, 2777,
		2778, 1, 0, 0, 0, 2778, 2779, 5, 249, 0, 0, 2779, 2791, 5, 110, 0, 0, 2780,
		2781, 5, 313, 0, 0, 2781, 2786, 3, 244, 122, 0, 2782, 2783, 5, 312, 0,
		0, 2783, 2785, 3, 244, 122, 0, 2784, 2782, 1, 0, 0, 0, 2785, 2788, 1, 0,
		0, 0, 2786, 2784, 1, 0, 0, 0, 2786, 2787, 1, 0, 0, 0, 2787, 2789, 1, 0,
		0, 0, 2788, 2786, 1, 0, 0, 0, 2789, 2790, 5, 314, 0, 0, 2790, 2792, 1,
		0, 0, 0, 2791, 2780, 1, 0, 0, 0, 2791, 2792, 1, 0, 0, 0, 2792, 2793, 1,
		0, 0, 0, 2793, 2794, 5, 280, 0, 0, 2794, 2795, 5, 313, 0, 0, 2795, 2800,
		3, 120, 60, 0, 2796, 2797, 5, 312, 0, 0, 2797, 2799, 3, 120, 60, 0, 2798,
		2796, 1, 0, 0, 0, 2799, 2802, 1, 0, 0, 0, 2800, 2798, 1, 0, 0, 0, 2800,
		2801, 1, 0, 0, 0, 2801, 2803, 1, 0, 0, 0, 2802, 2800, 1, 0, 0, 0, 2803,
		2804, 5, 314, 0, 0, 2804, 2806, 1, 0, 0, 0, 2805, 2741, 1, 0, 0, 0, 2805,
		2763, 1, 0, 0, 0, 2805, 2771, 1, 0, 0, 0, 2806, 179, 1, 0, 0, 0, 2807,
		2813, 5, 182, 0, 0, 2808, 2814, 3, 244, 122, 0, 2809, 2810, 5, 313, 0,
		0, 2810, 2811, 3, 62, 31, 0, 2811, 2812, 5, 314, 0, 0, 2812, 2814, 1, 0,
		0, 0, 2813, 2808, 1, 0, 0, 0, 2813, 2809, 1, 0, 0, 0, 2814, 181, 1, 0,
		0, 0, 2815, 2816, 5, 151, 0, 0, 2816, 2821, 3, 88, 44, 0, 2817, 2818, 5,
		312, 0, 0, 2818, 2820, 3, 88, 44, 0, 2819, 2817, 1, 0, 0, 0, 2820, 2823,
		1, 0, 0, 0, 2821, 2819, 1, 0, 0, 0, 2821, 2822, 1, 0, 0, 0, 2822, 2825,
		1, 0, 0, 0, 2823, 2821, 1, 0, 0, 0, 2824, 2815, 1, 0, 0, 0, 2824, 2825,
		1, 0, 0, 0, 2825, 2826, 1, 0, 0, 0, 2826, 2830, 3, 184, 92, 0, 2827, 2828,
		5, 4, 0, 0, 2828, 2829, 5, 146, 0, 0, 2829, 2831, 3, 94, 47, 0, 2830, 2827,
		1, 0, 0, 0, 2830, 2831, 1, 0, 0, 0, 2831, 2833, 1, 0, 0, 0, 2832, 2834,
		7, 16, 0, 0, 2833, 2832, 1, 0, 0, 0, 2833, 2834, 1, 0, 0, 0, 2834, 2840,
		1, 0, 0, 0, 2835, 2836, 5, 189, 0, 0, 2836, 2837, 5, 313, 0, 0, 2837, 2838,
		3, 188, 94, 0, 2838, 2839, 5, 314, 0, 0, 2839, 2841, 1, 0, 0, 0, 2840,
		2835, 1, 0, 0, 0, 2840, 2841, 1, 0, 0, 0, 2841, 2851, 1, 0, 0, 0, 2842,
		2843, 5, 241, 0, 0, 2843, 2848, 3, 96, 48, 0, 2844, 2845, 5, 312, 0, 0,
		2845, 2847, 3, 96, 48, 0, 2846, 2844, 1, 0, 0, 0, 2847, 2850, 1, 0, 0,
		0, 2848, 2846, 1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 2852, 1, 0, 0,
		0, 2850, 2848, 1, 0, 0, 0, 2851, 2842, 1, 0, 0, 0, 2851, 2852, 1, 0, 0,
		0, 2852, 2862, 1, 0, 0, 0, 2853, 2854, 5, 54, 0, 0, 2854, 2859, 3, 98,
		49, 0, 2855, 2856, 5, 312, 0, 0, 2856, 2858, 3, 98, 49, 0, 2857, 2855,
		1, 0, 0, 0, 2858, 2861, 1, 0, 0, 0, 2859, 2857, 1, 0, 0, 0, 2859, 2860,
		1, 0, 0, 0, 2860, 2863, 1, 0, 0, 0, 2861, 2859, 1, 0, 0, 0, 2862, 2853,
		1, 0, 0, 0, 2862, 2863, 1, 0, 0, 0, 2863, 183, 1, 0, 0, 0, 2864, 2865,
		5, 202, 0, 0, 2865, 2889, 3, 186, 93, 0, 2866, 2867, 5, 223, 0, 0, 2867,
		2889, 3, 186, 93, 0, 2868, 2869, 5, 99, 0, 0, 2869, 2889, 3, 186, 93, 0,
		2870, 2871, 5, 202, 0, 0, 2871, 2872, 5, 17, 0, 0, 2872, 2873, 3, 186,
		93, 0, 2873, 2874, 5, 8, 0, 0, 2874, 2875, 3, 186, 93, 0, 2875, 2889, 1,
		0, 0, 0, 2876, 2877, 5, 223, 0, 0, 2877, 2878, 5, 17, 0, 0, 2878, 2879,
		3, 186, 93, 0, 2879, 2880, 5, 8, 0, 0, 2880, 2881, 3, 186, 93, 0, 2881,
		2889, 1, 0, 0, 0, 2882, 2883, 5, 99, 0, 0, 2883, 2884, 5, 17, 0, 0, 2884,
		2885, 3, 186, 93, 0, 2885, 2886, 5, 8, 0, 0, 2886, 2887, 3, 186, 93, 0,
		2887, 2889, 1, 0, 0, 0, 2888, 2864, 1, 0, 0, 0, 2888, 2866, 1, 0, 0, 0,
		2888, 2868, 1, 0, 0, 0, 2888, 2870, 1, 0, 0, 0, 2888, 2876, 1, 0, 0, 0,
		2888, 2882, 1, 0, 0, 0, 2889, 185, 1, 0, 0, 0, 2890, 2891, 5, 262, 0, 0,
		2891, 2900, 5, 195, 0, 0, 2892, 2893, 5, 262, 0, 0, 2893, 2900, 5, 85,
		0, 0, 2894, 2895, 5, 39, 0, 0, 2895, 2900, 5, 222, 0, 0, 2896, 2897, 3,
		120, 60, 0, 2897, 2898, 7, 30, 0, 0, 2898, 2900, 1, 0, 0, 0, 2899, 2890,
		1, 0, 0, 0, 2899, 2892, 1, 0, 0, 0, 2899, 2894, 1, 0, 0, 0, 2899, 2896,
		1, 0, 0, 0, 2900, 187, 1, 0, 0, 0, 2901, 2902, 6, 94, -1, 0, 2902, 2904,
		3, 190, 95, 0, 2903, 2905, 3, 192, 96, 0, 2904, 2903, 1, 0, 0, 0, 2904,
		2905, 1, 0, 0, 0, 2905, 2913, 1, 0, 0, 0, 2906, 2907, 10, 2, 0, 0, 2907,
		2912, 3, 188, 94, 3, 2908, 2909, 10, 1, 0, 0, 2909, 2910, 5, 324, 0, 0,
		2910, 2912, 3, 188, 94, 2, 2911, 2906, 1, 0, 0, 0, 2911, 2908, 1, 0, 0,
		0, 2912, 2915, 1, 0, 0, 0, 2913, 2911, 1, 0, 0, 0, 2913, 2914, 1, 0, 0,
		0, 2914, 189, 1, 0, 0, 0, 2915, 2913, 1, 0, 0, 0, 2916, 2942, 3, 244, 122,
		0, 2917, 2918, 5, 313, 0, 0, 2918, 2942, 5, 314, 0, 0, 2919, 2920, 5, 192,
		0, 0, 2920, 2921, 5, 313, 0, 0, 2921, 2926, 3, 188, 94, 0, 2922, 2923,
		5, 312, 0, 0, 2923, 2925, 3, 188, 94, 0, 2924, 2922, 1, 0, 0, 0, 2925,
		2928, 1, 0, 0, 0, 2926, 2924, 1, 0, 0, 0, 2926, 2927, 1, 0, 0, 0, 2927,
		2929, 1, 0, 0, 0, 2928, 2926, 1, 0, 0, 0, 2929, 2930, 5, 314, 0, 0, 2930,
		2942, 1, 0, 0, 0, 2931, 2932, 5, 313, 0, 0, 2932, 2933, 3, 188, 94, 0,
		2933, 2934, 5, 314, 0, 0, 2934, 2942, 1, 0, 0, 0, 2935, 2942, 5, 326, 0,
		0, 2936, 2942, 5, 325, 0, 0, 2937, 2938, 5, 319, 0, 0, 2938, 2939, 3, 188,
		94, 0, 2939, 2940, 5, 320, 0, 0, 2940, 2942, 1, 0, 0, 0, 2941, 2916, 1,
		0, 0, 0, 2941, 2917, 1, 0, 0, 0, 2941, 2919, 1, 0, 0, 0, 2941, 2931, 1,
		0, 0, 0, 2941, 2935, 1, 0, 0, 0, 2941, 2936, 1, 0, 0, 0, 2941, 2937, 1,
		0, 0, 0, 2942, 191, 1, 0, 0, 0, 2943, 2945, 5, 304, 0, 0, 2944, 2946, 5,
		308, 0, 0, 2945, 2944, 1, 0, 0, 0, 2945, 2946, 1, 0, 0, 0, 2946, 2974,
		1, 0, 0, 0, 2947, 2949, 5, 302, 0, 0, 2948, 2950, 5, 308, 0, 0, 2949, 2948,
		1, 0, 0, 0, 2949, 2950, 1, 0, 0, 0, 2950, 2974, 1, 0, 0, 0, 2951, 2953,
		5, 308, 0, 0, 2952, 2954, 5, 308, 0, 0, 2953, 2952, 1, 0, 0, 0, 2953, 2954,
		1, 0, 0, 0, 2954, 2974, 1, 0, 0, 0, 2955, 2956, 5, 317, 0, 0, 2956, 2957,
		5, 330, 0, 0, 2957, 2959, 5, 318, 0, 0, 2958, 2960, 5, 308, 0, 0, 2959,
		2958, 1, 0, 0, 0, 2959, 2960, 1, 0, 0, 0, 2960, 2974, 1, 0, 0, 0, 2961,
		2963, 5, 317, 0, 0, 2962, 2964, 5, 330, 0, 0, 2963, 2962, 1, 0, 0, 0, 2963,
		2964, 1, 0, 0, 0, 2964, 2965, 1, 0, 0, 0, 2965, 2967, 5, 312, 0, 0, 2966,
		2968, 5, 330, 0, 0, 2967, 2966, 1, 0, 0, 0, 2967, 2968, 1, 0, 0, 0, 2968,
		2969, 1, 0, 0, 0, 2969, 2971, 5, 318, 0, 0, 2970, 2972, 5, 308, 0, 0, 2971,
		2970, 1, 0, 0, 0, 2971, 2972, 1, 0, 0, 0, 2972, 2974, 1, 0, 0, 0, 2973,
		2943, 1, 0, 0, 0, 2973, 2947, 1, 0, 0, 0, 2973, 2951, 1, 0, 0, 0, 2973,
		2955, 1, 0, 0, 0, 2973, 2961, 1, 0, 0, 0, 2974, 193, 1, 0, 0, 0, 2975,
		2976, 3, 244, 122, 0, 2976, 2977, 5, 296, 0, 0, 2977, 2978, 3, 120, 60,
		0, 2978, 195, 1, 0, 0, 0, 2979, 2980, 5, 87, 0, 0, 2980, 2984, 7, 31, 0,
		0, 2981, 2982, 5, 260, 0, 0, 2982, 2984, 7, 32, 0, 0, 2983, 2979, 1, 0,
		0, 0, 2983, 2981, 1, 0, 0, 0, 2984, 197, 1, 0, 0, 0, 2985, 2986, 5, 117,
		0, 0, 2986, 2987, 5, 136, 0, 0, 2987, 2991, 3, 200, 100, 0, 2988, 2989,
		5, 203, 0, 0, 2989, 2991, 7, 33, 0, 0, 2990, 2985, 1, 0, 0, 0, 2990, 2988,
		1, 0, 0, 0, 2991, 199, 1, 0, 0, 0, 2992, 2993, 5, 203, 0, 0, 2993, 3000,
		5, 263, 0, 0, 2994, 2995, 5, 203, 0, 0, 2995, 3000, 5, 31, 0, 0, 2996,
		2997, 5, 208, 0, 0, 2997, 3000, 5, 203, 0, 0, 2998, 3000, 5, 232, 0, 0,
		2999, 2992, 1, 0, 0, 0, 2999, 2994, 1, 0, 0, 0, 2999, 2996, 1, 0, 0, 0,
		2999, 2998, 1, 0, 0, 0, 3000, 201, 1, 0, 0, 0, 3001, 3007, 3, 120, 60,
		0, 3002, 3003, 3, 244, 122, 0, 3003, 3004, 5, 323, 0, 0, 3004, 3005, 3,
		120, 60, 0, 3005, 3007, 1, 0, 0, 0, 3006, 3001, 1, 0, 0, 0, 3006, 3002,
		1, 0, 0, 0, 3007, 203, 1, 0, 0, 0, 3008, 3009, 3, 244, 122, 0, 3009, 3010,
		5, 310, 0, 0, 3010, 3011, 3, 244, 122, 0, 3011, 3014, 1, 0, 0, 0, 3012,
		3014, 3, 244, 122, 0, 3013, 3008, 1, 0, 0, 0, 3013, 3012, 1, 0, 0, 0, 3014,
		205, 1, 0, 0, 0, 3015, 3020, 3, 204, 102, 0, 3016, 3017, 5, 312, 0, 0,
		3017, 3019, 3, 204, 102, 0, 3018, 3016, 1, 0, 0, 0, 3019, 3022, 1, 0, 0,
		0, 3020, 3018, 1, 0, 0, 0, 3020, 3021, 1, 0, 0, 0, 3021, 207, 1, 0, 0,
		0, 3022, 3020, 1, 0, 0, 0, 3023, 3024, 5, 90, 0, 0, 3024, 3025, 3, 210,
		105, 0, 3025, 3029, 3, 214, 107, 0, 3026, 3028, 3, 216, 108, 0, 3027, 3026,
		1, 0, 0, 0, 3028, 3031, 1, 0, 0, 0, 3029, 3027, 1, 0, 0, 0, 3029, 3030,
		1, 0, 0, 0, 3030, 3032, 1, 0, 0, 0, 3031, 3029, 1, 0, 0, 0, 3032, 3033,
		3, 218, 109, 0, 3033, 209, 1, 0, 0, 0, 3034, 3035, 3, 232, 116, 0, 3035,
		3044, 5, 313, 0, 0, 3036, 3041, 3, 212, 106, 0, 3037, 3038, 5, 312, 0,
		0, 3038, 3040, 3, 212, 106, 0, 3039, 3037, 1, 0, 0, 0, 3040, 3043, 1, 0,
		0, 0, 3041, 3039, 1, 0, 0, 0, 3041, 3042, 1, 0, 0, 0, 3042, 3045, 1, 0,
		0, 0, 3043, 3041, 1, 0, 0, 0, 3044, 3036, 1, 0, 0, 0, 3044, 3045, 1, 0,
		0, 0, 3045, 3046, 1, 0, 0, 0, 3046, 3047, 5, 314, 0, 0, 3047, 211, 1, 0,
		0, 0, 3048, 3050, 3, 244, 122, 0, 3049, 3048, 1, 0, 0, 0, 3049, 3050, 1,
		0, 0, 0, 3050, 3051, 1, 0, 0, 0, 3051, 3052, 3, 168, 84, 0, 3052, 213,
		1, 0, 0, 0, 3053, 3054, 5, 215, 0, 0, 3054, 3055, 3, 168, 84, 0, 3055,
		215, 1, 0, 0, 0, 3056, 3057, 5, 130, 0, 0, 3057, 3076, 3, 244, 122, 0,
		3058, 3060, 5, 165, 0, 0, 3059, 3058, 1, 0, 0, 0, 3059, 3060, 1, 0, 0,
		0, 3060, 3061, 1, 0, 0, 0, 3061, 3076, 5, 61, 0, 0, 3062, 3063, 5, 215,
		0, 0, 3063, 3064, 5, 166, 0, 0, 3064, 3065, 5, 173, 0, 0, 3065, 3066, 5,
		166, 0, 0, 3066, 3076, 5, 109, 0, 0, 3067, 3068, 5, 21, 0, 0, 3068, 3069,
		5, 173, 0, 0, 3069, 3070, 5, 166, 0, 0, 3070, 3076, 5, 109, 0, 0, 3071,
		3072, 5, 229, 0, 0, 3072, 3076, 7, 1, 0, 0, 3073, 3074, 5, 29, 0, 0, 3074,
		3076, 3, 152, 76, 0, 3075, 3056, 1, 0, 0, 0, 3075, 3059, 1, 0, 0, 0, 3075,
		3062, 1, 0, 0, 0, 3075, 3067, 1, 0, 0, 0, 3075, 3071, 1, 0, 0, 0, 3075,
		3073, 1, 0, 0, 0, 3076, 217, 1, 0, 0, 0, 3077, 3078, 5, 213, 0, 0, 3078,
		3177, 3, 126, 63, 0, 3079, 3080, 5, 234, 0, 0, 3080, 3081, 3, 244, 122,
		0, 3081, 3082, 5, 296, 0, 0, 3082, 3083, 3, 120, 60, 0, 3083, 3177, 1,
		0, 0, 0, 3084, 3085, 5, 23, 0, 0, 3085, 3087, 3, 120, 60, 0, 3086, 3088,
		3, 220, 110, 0, 3087, 3086, 1, 0, 0, 0, 3088, 3089, 1, 0, 0, 0, 3089, 3087,
		1, 0, 0, 0, 3089, 3090, 1, 0, 0, 0, 3090, 3092, 1, 0, 0, 0, 3091, 3093,
		3, 224, 112, 0, 3092, 3091, 1, 0, 0, 0, 3092, 3093, 1, 0, 0, 0, 3093, 3094,
		1, 0, 0, 0, 3094, 3095, 5, 71, 0, 0, 3095, 3096, 5, 23, 0, 0, 3096, 3177,
		1, 0, 0, 0, 3097, 3099, 5, 23, 0, 0, 3098, 3100, 3, 220, 110, 0, 3099,
		3098, 1, 0, 0, 0, 3100, 3101, 1, 0, 0, 0, 3101, 3099, 1, 0, 0, 0, 3101,
		3102, 1, 0, 0, 0, 3102, 3104, 1, 0, 0, 0, 3103, 3105, 3, 224, 112, 0, 3104,
		3103, 1, 0, 0, 0, 3104, 3105, 1, 0, 0, 0, 3105, 3106, 1, 0, 0, 0, 3106,
		3107, 5, 71, 0, 0, 3107, 3108, 5, 23, 0, 0, 3108, 3177, 1, 0, 0, 0, 3109,
		3110, 5, 102, 0, 0, 3110, 3111, 3, 120, 60, 0, 3111, 3112, 5, 249, 0, 0,
		3112, 3116, 3, 228, 114, 0, 3113, 3115, 3, 222, 111, 0, 3114, 3113, 1,
		0, 0, 0, 3115, 3118, 1, 0, 0, 0, 3116, 3114, 1, 0, 0, 0, 3116, 3117, 1,
		0, 0, 0, 3117, 3120, 1, 0, 0, 0, 3118, 3116, 1, 0, 0, 0, 3119, 3121, 3,
		224, 112, 0, 3120, 3119, 1, 0, 0, 0, 3120, 3121, 1, 0, 0, 0, 3121, 3122,
		1, 0, 0, 0, 3122, 3123, 5, 71, 0, 0, 3123, 3124, 5, 102, 0, 0, 3124, 3177,
		1, 0, 0, 0, 3125, 3126, 5, 118, 0, 0, 3126, 3177, 3, 244, 122, 0, 3127,
		3128, 5, 134, 0, 0, 3128, 3177, 3, 244, 122, 0, 3129, 3135, 5, 15, 0, 0,
		3130, 3131, 3, 226, 113, 0, 3131, 3132, 5, 309, 0, 0, 3132, 3134, 1, 0,
		0, 0, 3133, 3130, 1, 0, 0, 0, 3134, 3137, 1, 0, 0, 0, 3135, 3133, 1, 0,
		0, 0, 3135, 3136, 1, 0, 0, 0, 3136, 3139, 1, 0, 0, 0, 3137, 3135, 1, 0,
		0, 0, 3138, 3140, 3, 228, 114, 0, 3139, 3138, 1, 0, 0, 0, 3139, 3140, 1,
		0, 0, 0, 3140, 3141, 1, 0, 0, 0, 3141, 3177, 5, 71, 0, 0, 3142, 3143, 3,
		244, 122, 0, 3143, 3144, 5, 311, 0, 0, 3144, 3146, 1, 0, 0, 0, 3145, 3142,
		1, 0, 0, 0, 3145, 3146, 1, 0, 0, 0, 3146, 3147, 1, 0, 0, 0, 3147, 3148,
		5, 144, 0, 0, 3148, 3149, 3, 228, 114, 0, 3149, 3150, 5, 71, 0, 0, 3150,
		3151, 5, 144, 0, 0, 3151, 3177, 1, 0, 0, 0, 3152, 3153, 3, 244, 122, 0,
		3153, 3154, 5, 311, 0, 0, 3154, 3156, 1, 0, 0, 0, 3155, 3152, 1, 0, 0,
		0, 3155, 3156, 1, 0, 0, 0, 3156, 3157, 1, 0, 0, 0, 3157, 3158, 5, 286,
		0, 0, 3158, 3159, 3, 120, 60, 0, 3159, 3160, 5, 64, 0, 0, 3160, 3161, 3,
		228, 114, 0, 3161, 3162, 5, 71, 0, 0, 3162, 3163, 5, 286, 0, 0, 3163, 3177,
		1, 0, 0, 0, 3164, 3165, 3, 244, 122, 0, 3165, 3166, 5, 311, 0, 0, 3166,
		3168, 1, 0, 0, 0, 3167, 3164, 1, 0, 0, 0, 3167, 3168, 1, 0, 0, 0, 3168,
		3169, 1, 0, 0, 0, 3169, 3170, 5, 207, 0, 0, 3170, 3171, 3, 228, 114, 0,
		3171, 3172, 5, 270, 0, 0, 3172, 3173, 3, 120, 60, 0, 3173, 3174, 5, 71,
		0, 0, 3174, 3175, 5, 207, 0, 0, 3175, 3177, 1, 0, 0, 0, 3176, 3077, 1,
		0, 0, 0, 3176, 3079, 1, 0, 0, 0, 3176, 3084, 1, 0, 0, 0, 3176, 3097, 1,
		0, 0, 0, 3176, 3109, 1, 0, 0, 0, 3176, 3125, 1, 0, 0, 0, 3176, 3127, 1,
		0, 0, 0, 3176, 3129, 1, 0, 0, 0, 3176, 3145, 1, 0, 0, 0, 3176, 3155, 1,
		0, 0, 0, 3176, 3167, 1, 0, 0, 0, 3177, 219, 1, 0, 0, 0, 3178, 3179, 5,
		284, 0, 0, 3179, 3180, 3, 120, 60, 0, 3180, 3181, 5, 249, 0, 0, 3181, 3182,
		3, 228, 114, 0, 3182, 221, 1, 0, 0, 0, 3183, 3184, 5, 69, 0, 0, 3184, 3185,
		3, 120, 60, 0, 3185, 3186, 5, 249, 0, 0, 3186, 3187, 3, 228, 114, 0, 3187,
		223, 1, 0, 0, 0, 3188, 3189, 5, 67, 0, 0, 3189, 3190, 3, 228, 114, 0, 3190,
		225, 1, 0, 0, 0, 3191, 3192, 5, 52, 0, 0, 3192, 3197, 3, 244, 122, 0, 3193,
		3194, 5, 312, 0, 0, 3194, 3196, 3, 244, 122, 0, 3195, 3193, 1, 0, 0, 0,
		3196, 3199, 1, 0, 0, 0, 3197, 3195, 1, 0, 0, 0, 3197, 3198, 1, 0, 0, 0,
		3198, 3200, 1, 0, 0, 0, 3199, 3197, 1, 0, 0, 0, 3200, 3203, 3, 168, 84,
		0, 3201, 3202, 5, 53, 0, 0, 3202, 3204, 3, 126, 63, 0, 3203, 3201, 1, 0,
		0, 0, 3203, 3204, 1, 0, 0, 0, 3204, 227, 1, 0, 0, 0, 3205, 3206, 3, 218,
		109, 0, 3206, 3207, 5, 309, 0, 0, 3207, 3209, 1, 0, 0, 0, 3208, 3205, 1,
		0, 0, 0, 3209, 3210, 1, 0, 0, 0, 3210, 3208, 1, 0, 0, 0, 3210, 3211, 1,
		0, 0, 0, 3211, 229, 1, 0, 0, 0, 3212, 3213, 7, 34, 0, 0, 3213, 231, 1,
		0, 0, 0, 3214, 3219, 3, 244, 122, 0, 3215, 3216, 5, 310, 0, 0, 3216, 3218,
		3, 244, 122, 0, 3217, 3215, 1, 0, 0, 0, 3218, 3221, 1, 0, 0, 0, 3219, 3217,
		1, 0, 0, 0, 3219, 3220, 1, 0, 0, 0, 3220, 233, 1, 0, 0, 0, 3221, 3219,
		1, 0, 0, 0, 3222, 3223, 5, 86, 0, 0, 3223, 3224, 3, 236, 118, 0, 3224,
		3225, 5, 11, 0, 0, 3225, 3226, 5, 170, 0, 0, 3226, 3227, 3, 126, 63, 0,
		3227, 235, 1, 0, 0, 0, 3228, 3229, 7, 35, 0, 0, 3229, 237, 1, 0, 0, 0,
		3230, 3234, 3, 240, 120, 0, 3231, 3234, 5, 47, 0, 0, 3232, 3234, 5, 43,
		0, 0, 3233, 3230, 1, 0, 0, 0, 3233, 3231, 1, 0, 0, 0, 3233, 3232, 1, 0,
		0, 0, 3234, 239, 1, 0, 0, 0, 3235, 3241, 3, 244, 122, 0, 3236, 3237, 5,
		273, 0, 0, 3237, 3241, 3, 244, 122, 0, 3238, 3239, 5, 218, 0, 0, 3239,
		3241, 3, 244, 122, 0, 3240, 3235, 1, 0, 0, 0, 3240, 3236, 1, 0, 0, 0, 3240,
		3238, 1, 0, 0, 0, 3241, 241, 1, 0, 0, 0, 3242, 3247, 3, 244, 122, 0, 3243,
		3244, 5, 312, 0, 0, 3244, 3246, 3, 244, 122, 0, 3245, 3243, 1, 0, 0, 0,
		3246, 3249, 1, 0, 0, 0, 3247, 3245, 1, 0, 0, 0, 3247, 3248, 1, 0, 0, 0,
		3248, 243, 1, 0, 0, 0, 3249, 3247, 1, 0, 0, 0, 3250, 3256, 5, 333, 0, 0,
		3251, 3256, 5, 335, 0, 0, 3252, 3256, 3, 250, 125, 0, 3253, 3256, 5, 336,
		0, 0, 3254, 3256, 5, 334, 0, 0, 3255, 3250, 1, 0, 0, 0, 3255, 3251, 1,
		0, 0, 0, 3255, 3252, 1, 0, 0, 0, 3255, 3253, 1, 0, 0, 0, 3255, 3254, 1,
		0, 0, 0, 3256, 245, 1, 0, 0, 0, 3257, 3259, 5, 303, 0, 0, 3258, 3257, 1,
		0, 0, 0, 3258, 3259, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3270, 5,
		331, 0, 0, 3261, 3263, 5, 303, 0, 0, 3262, 3261, 1, 0, 0, 0, 3262, 3263,
		1, 0, 0, 0, 3263, 3264, 1, 0, 0, 0, 3264, 3270, 5, 332, 0, 0, 3265, 3267,
		5, 303, 0, 0, 3266, 3265, 1, 0, 0, 0, 3266, 3267, 1, 0, 0, 0, 3267, 3268,
		1, 0, 0, 0, 3268, 3270, 5, 330, 0, 0, 3269, 3258, 1, 0, 0, 0, 3269, 3262,
		1, 0, 0, 0, 3269, 3266, 1, 0, 0, 0, 3270, 247, 1, 0, 0, 0, 3271, 3274,
		3, 244, 122, 0, 3272, 3274, 3, 152, 76, 0, 3273, 3271, 1, 0, 0, 0, 3273,
		3272, 1, 0, 0, 0, 3274, 249, 1, 0, 0, 0, 3275, 3276, 7, 36, 0, 0, 3276,
		251, 1, 0, 0, 0, 434, 255, 266, 269, 302, 309, 313, 317, 323, 327, 334,
		339, 343, 349, 353, 372, 378, 382, 386, 390, 398, 402, 405, 410, 416, 425,
		431, 435, 441, 448, 457, 469, 478, 487, 493, 504, 512, 520, 527, 537, 544,
		552, 588, 591, 594, 598, 604, 609, 616, 622, 626, 630, 638, 644, 648, 662,
		670, 689, 714, 717, 724, 731, 740, 744, 751, 761, 767, 772, 776, 782, 791,
		797, 801, 808, 812, 820, 825, 829, 837, 845, 850, 854, 864, 871, 876, 880,
		890, 893, 902, 907, 913, 937, 943, 945, 951, 957, 959, 967, 969, 975, 981,
		983, 998, 1003, 1010, 1020, 1026, 1028, 1036, 1038, 1063, 1066, 1070, 1074,
		1092, 1095, 1106, 1109, 1125, 1135, 1140, 1146, 1149, 1158, 1160, 1163,
		1173, 1177, 1183, 1190, 1195, 1201, 1205, 1209, 1215, 1226, 1235, 1245,
		1248, 1253, 1255, 1262, 1268, 1270, 1274, 1284, 1290, 1293, 1295, 1307,
		1314, 1318, 1322, 1326, 1333, 1342, 1345, 1349, 1354, 1358, 1366, 1369,
		1372, 1379, 1390, 1393, 1403, 1406, 1417, 1422, 1430, 1433, 1437, 1446,
		1455, 1458, 1467, 1470, 1473, 1477, 1488, 1491, 1498, 1501, 1520, 1524,
		1528, 1532, 1534, 1545, 1550, 1559, 1568, 1571, 1586, 1589, 1598, 1601,
		1609, 1612, 1615, 1620, 1623, 1635, 1638, 1646, 1651, 1655, 1657, 1659,
		1674, 1676, 1687, 1694, 1697, 1702, 1712, 1723, 1727, 1729, 1737, 1744,
		1757, 1763, 1779, 1788, 1791, 1799, 1802, 1809, 1814, 1825, 1828, 1832,
		1834, 1842, 1852, 1858, 1860, 1867, 1871, 1873, 1880, 1884, 1886, 1888,
		1897, 1908, 1912, 1922, 1932, 1936, 1944, 1946, 1959, 1967, 1976, 1982,
		1990, 1996, 2000, 2005, 2010, 2016, 2030, 2032, 2062, 2073, 2081, 2086,
		2091, 2104, 2110, 2113, 2120, 2125, 2128, 2131, 2136, 2143, 2146, 2155,
		2158, 2162, 2165, 2168, 2183, 2186, 2205, 2209, 2217, 2221, 2246, 2249,
		2258, 2264, 2270, 2276, 2285, 2288, 2291, 2310, 2319, 2341, 2344, 2354,
		2363, 2369, 2375, 2386, 2388, 2393, 2400, 2402, 2408, 2414, 2425, 2434,
		2439, 2444, 2446, 2448, 2454, 2456, 2466, 2475, 2477, 2483, 2485, 2488,
		2498, 2500, 2512, 2515, 2520, 2525, 2537, 2541, 2545, 2548, 2550, 2556,
		2559, 2569, 2577, 2583, 2585, 2593, 2603, 2609, 2623, 2632, 2639, 2644,
		2651, 2661, 2666, 2673, 2699, 2704, 2706, 2713, 2717, 2724, 2728, 2745,
		2760, 2767, 2776, 2786, 2791, 2800, 2805, 2813, 2821, 2824, 2830, 2833,
		2840, 2848, 2851, 2859, 2862, 2888, 2899, 2904, 2911, 2913, 2926, 2941,
		2945, 2949, 2953, 2959, 2963, 2967, 2971, 2973, 2983, 2990, 2999, 3006,
		3013, 3020, 3029, 3041, 3044, 3049, 3059, 3075, 3089, 3092, 3101, 3104,
		3116, 3120, 3135, 3139, 3145, 3155, 3167, 3176, 3197, 3203, 3210, 3219,
		3233, 3240, 3247, 3255, 3258, 3262, 3266, 3269, 3273,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// TrinoParserInit initializes any static state used to implement TrinoParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewTrinoParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func TrinoParserInit() {
	staticData := &TrinoParserParserStaticData
	staticData.once.Do(trinoparserParserInit)
}

// NewTrinoParser produces a new parser instance for the optional input antlr.TokenStream.
func NewTrinoParser(input antlr.TokenStream) *TrinoParser {
	TrinoParserInit()
	this := new(TrinoParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &TrinoParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "TrinoParser.g4"

	return this
}

// TrinoParser tokens.
const (
	TrinoParserEOF                    = antlr.TokenEOF
	TrinoParserABSENT_                = 1
	TrinoParserADD_                   = 2
	TrinoParserADMIN_                 = 3
	TrinoParserAFTER_                 = 4
	TrinoParserALL_                   = 5
	TrinoParserALTER_                 = 6
	TrinoParserANALYZE_               = 7
	TrinoParserAND_                   = 8
	TrinoParserANY_                   = 9
	TrinoParserARRAY_                 = 10
	TrinoParserAS_                    = 11
	TrinoParserASC_                   = 12
	TrinoParserAT_                    = 13
	TrinoParserAUTHORIZATION_         = 14
	TrinoParserBEGIN_                 = 15
	TrinoParserBERNOULLI_             = 16
	TrinoParserBETWEEN_               = 17
	TrinoParserBOTH_                  = 18
	TrinoParserBY_                    = 19
	TrinoParserCALL_                  = 20
	TrinoParserCALLED_                = 21
	TrinoParserCASCADE_               = 22
	TrinoParserCASE_                  = 23
	TrinoParserCAST_                  = 24
	TrinoParserCATALOG_               = 25
	TrinoParserCATALOGS_              = 26
	TrinoParserCOLUMN_                = 27
	TrinoParserCOLUMNS_               = 28
	TrinoParserCOMMENT_               = 29
	TrinoParserCOMMIT_                = 30
	TrinoParserCOMMITTED_             = 31
	TrinoParserCONDITIONAL_           = 32
	TrinoParserCONSTRAINT_            = 33
	TrinoParserCOUNT_                 = 34
	TrinoParserCOPARTITION_           = 35
	TrinoParserCREATE_                = 36
	TrinoParserCROSS_                 = 37
	TrinoParserCUBE_                  = 38
	TrinoParserCURRENT_               = 39
	TrinoParserCURRENT_CATALOG_       = 40
	TrinoParserCURRENT_DATE_          = 41
	TrinoParserCURRENT_PATH_          = 42
	TrinoParserCURRENT_ROLE_          = 43
	TrinoParserCURRENT_SCHEMA_        = 44
	TrinoParserCURRENT_TIME_          = 45
	TrinoParserCURRENT_TIMESTAMP_     = 46
	TrinoParserCURRENT_USER_          = 47
	TrinoParserDATA_                  = 48
	TrinoParserDATE_                  = 49
	TrinoParserDAY_                   = 50
	TrinoParserDEALLOCATE_            = 51
	TrinoParserDECLARE_               = 52
	TrinoParserDEFAULT_               = 53
	TrinoParserDEFINE_                = 54
	TrinoParserDEFINER_               = 55
	TrinoParserDELETE_                = 56
	TrinoParserDENY_                  = 57
	TrinoParserDESC_                  = 58
	TrinoParserDESCRIBE_              = 59
	TrinoParserDESCRIPTOR_            = 60
	TrinoParserDETERMINISTIC_         = 61
	TrinoParserDISTINCT_              = 62
	TrinoParserDISTRIBUTED_           = 63
	TrinoParserDO_                    = 64
	TrinoParserDOUBLE_                = 65
	TrinoParserDROP_                  = 66
	TrinoParserELSE_                  = 67
	TrinoParserEMPTY_                 = 68
	TrinoParserELSEIF_                = 69
	TrinoParserENCODING_              = 70
	TrinoParserEND_                   = 71
	TrinoParserERROR_                 = 72
	TrinoParserESCAPE_                = 73
	TrinoParserEXCEPT_                = 74
	TrinoParserEXCLUDING_             = 75
	TrinoParserEXECUTE_               = 76
	TrinoParserEXISTS_                = 77
	TrinoParserEXPLAIN_               = 78
	TrinoParserEXTRACT_               = 79
	TrinoParserFALSE_                 = 80
	TrinoParserFETCH_                 = 81
	TrinoParserFILTER_                = 82
	TrinoParserFINAL_                 = 83
	TrinoParserFIRST_                 = 84
	TrinoParserFOLLOWING_             = 85
	TrinoParserFOR_                   = 86
	TrinoParserFORMAT_                = 87
	TrinoParserFROM_                  = 88
	TrinoParserFULL_                  = 89
	TrinoParserFUNCTION_              = 90
	TrinoParserFUNCTIONS_             = 91
	TrinoParserGRACE_                 = 92
	TrinoParserGRANT_                 = 93
	TrinoParserGRANTED_               = 94
	TrinoParserGRANTS_                = 95
	TrinoParserGRAPHVIZ_              = 96
	TrinoParserGROUP_                 = 97
	TrinoParserGROUPING_              = 98
	TrinoParserGROUPS_                = 99
	TrinoParserHAVING_                = 100
	TrinoParserHOUR_                  = 101
	TrinoParserIF_                    = 102
	TrinoParserIGNORE_                = 103
	TrinoParserIMMEDIATE_             = 104
	TrinoParserIN_                    = 105
	TrinoParserINCLUDING_             = 106
	TrinoParserINITIAL_               = 107
	TrinoParserINNER_                 = 108
	TrinoParserINPUT_                 = 109
	TrinoParserINSERT_                = 110
	TrinoParserINTERSECT_             = 111
	TrinoParserINTERVAL_              = 112
	TrinoParserINTO_                  = 113
	TrinoParserINVOKER_               = 114
	TrinoParserIO_                    = 115
	TrinoParserIS_                    = 116
	TrinoParserISOLATION_             = 117
	TrinoParserITERATE_               = 118
	TrinoParserJOIN_                  = 119
	TrinoParserJSON_                  = 120
	TrinoParserJSON_ARRAY_            = 121
	TrinoParserJSON_EXISTS_           = 122
	TrinoParserJSON_OBJECT_           = 123
	TrinoParserJSON_QUERY_            = 124
	TrinoParserJSON_TABLE_            = 125
	TrinoParserJSON_VALUE_            = 126
	TrinoParserKEEP_                  = 127
	TrinoParserKEY_                   = 128
	TrinoParserKEYS_                  = 129
	TrinoParserLANGUAGE_              = 130
	TrinoParserLAST_                  = 131
	TrinoParserLATERAL_               = 132
	TrinoParserLEADING_               = 133
	TrinoParserLEAVE_                 = 134
	TrinoParserLEFT_                  = 135
	TrinoParserLEVEL_                 = 136
	TrinoParserLIKE_                  = 137
	TrinoParserLIMIT_                 = 138
	TrinoParserLISTAGG_               = 139
	TrinoParserLOCAL_                 = 140
	TrinoParserLOCALTIME_             = 141
	TrinoParserLOCALTIMESTAMP_        = 142
	TrinoParserLOGICAL_               = 143
	TrinoParserLOOP_                  = 144
	TrinoParserMAP_                   = 145
	TrinoParserMATCH_                 = 146
	TrinoParserMATCHED_               = 147
	TrinoParserMATCHES_               = 148
	TrinoParserMATCH_RECOGNIZE_       = 149
	TrinoParserMATERIALIZED_          = 150
	TrinoParserMEASURES_              = 151
	TrinoParserMERGE_                 = 152
	TrinoParserMINUTE_                = 153
	TrinoParserMONTH_                 = 154
	TrinoParserNATURAL_               = 155
	TrinoParserNESTED_                = 156
	TrinoParserNEXT_                  = 157
	TrinoParserNFC_                   = 158
	TrinoParserNFD_                   = 159
	TrinoParserNFKC_                  = 160
	TrinoParserNFKD_                  = 161
	TrinoParserNO_                    = 162
	TrinoParserNONE_                  = 163
	TrinoParserNORMALIZE_             = 164
	TrinoParserNOT_                   = 165
	TrinoParserNULL_                  = 166
	TrinoParserNULLIF_                = 167
	TrinoParserNULLS_                 = 168
	TrinoParserOBJECT_                = 169
	TrinoParserOF_                    = 170
	TrinoParserOFFSET_                = 171
	TrinoParserOMIT_                  = 172
	TrinoParserON_                    = 173
	TrinoParserONE_                   = 174
	TrinoParserONLY_                  = 175
	TrinoParserOPTION_                = 176
	TrinoParserOR_                    = 177
	TrinoParserORDER_                 = 178
	TrinoParserORDINALITY_            = 179
	TrinoParserOUTER_                 = 180
	TrinoParserOUTPUT_                = 181
	TrinoParserOVER_                  = 182
	TrinoParserOVERFLOW_              = 183
	TrinoParserPARTITION_             = 184
	TrinoParserPARTITIONS_            = 185
	TrinoParserPASSING_               = 186
	TrinoParserPAST_                  = 187
	TrinoParserPATH_                  = 188
	TrinoParserPATTERN_               = 189
	TrinoParserPER_                   = 190
	TrinoParserPERIOD_                = 191
	TrinoParserPERMUTE_               = 192
	TrinoParserPLAN_                  = 193
	TrinoParserPOSITION_              = 194
	TrinoParserPRECEDING_             = 195
	TrinoParserPRECISION_             = 196
	TrinoParserPREPARE_               = 197
	TrinoParserPRIVILEGES_            = 198
	TrinoParserPROPERTIES_            = 199
	TrinoParserPRUNE_                 = 200
	TrinoParserQUOTES_                = 201
	TrinoParserRANGE_                 = 202
	TrinoParserREAD_                  = 203
	TrinoParserRECURSIVE_             = 204
	TrinoParserREFRESH_               = 205
	TrinoParserRENAME_                = 206
	TrinoParserREPEAT_                = 207
	TrinoParserREPEATABLE_            = 208
	TrinoParserREPLACE_               = 209
	TrinoParserRESET_                 = 210
	TrinoParserRESPECT_               = 211
	TrinoParserRESTRICT_              = 212
	TrinoParserRETURN_                = 213
	TrinoParserRETURNING_             = 214
	TrinoParserRETURNS_               = 215
	TrinoParserREVOKE_                = 216
	TrinoParserRIGHT_                 = 217
	TrinoParserROLE_                  = 218
	TrinoParserROLES_                 = 219
	TrinoParserROLLBACK_              = 220
	TrinoParserROLLUP_                = 221
	TrinoParserROW_                   = 222
	TrinoParserROWS_                  = 223
	TrinoParserRUNNING_               = 224
	TrinoParserSCALAR_                = 225
	TrinoParserSCHEMA_                = 226
	TrinoParserSCHEMAS_               = 227
	TrinoParserSECOND_                = 228
	TrinoParserSECURITY_              = 229
	TrinoParserSEEK_                  = 230
	TrinoParserSELECT_                = 231
	TrinoParserSERIALIZABLE_          = 232
	TrinoParserSESSION_               = 233
	TrinoParserSET_                   = 234
	TrinoParserSETS_                  = 235
	TrinoParserSHOW_                  = 236
	TrinoParserSKIP_                  = 237
	TrinoParserSOME_                  = 238
	TrinoParserSTART_                 = 239
	TrinoParserSTATS_                 = 240
	TrinoParserSUBSET_                = 241
	TrinoParserSUBSTRING_             = 242
	TrinoParserSYSTEM_                = 243
	TrinoParserTABLE_                 = 244
	TrinoParserTABLES_                = 245
	TrinoParserTABLESAMPLE_           = 246
	TrinoParserTEXT_                  = 247
	TrinoParserTEXT_STRING_           = 248
	TrinoParserTHEN_                  = 249
	TrinoParserTIES_                  = 250
	TrinoParserTIME_                  = 251
	TrinoParserTIMESTAMP_             = 252
	TrinoParserTO_                    = 253
	TrinoParserTRAILING_              = 254
	TrinoParserTRANSACTION_           = 255
	TrinoParserTRIM_                  = 256
	TrinoParserTRUE_                  = 257
	TrinoParserTRUNCATE_              = 258
	TrinoParserTRY_CAST_              = 259
	TrinoParserTYPE_                  = 260
	TrinoParserUESCAPE_               = 261
	TrinoParserUNBOUNDED_             = 262
	TrinoParserUNCOMMITTED_           = 263
	TrinoParserUNCONDITIONAL_         = 264
	TrinoParserUNION_                 = 265
	TrinoParserUNIQUE_                = 266
	TrinoParserUNKNOWN_               = 267
	TrinoParserUNMATCHED_             = 268
	TrinoParserUNNEST_                = 269
	TrinoParserUNTIL_                 = 270
	TrinoParserUPDATE_                = 271
	TrinoParserUSE_                   = 272
	TrinoParserUSER_                  = 273
	TrinoParserUSING_                 = 274
	TrinoParserUTF16_                 = 275
	TrinoParserUTF32_                 = 276
	TrinoParserUTF8_                  = 277
	TrinoParserVALIDATE_              = 278
	TrinoParserVALUE_                 = 279
	TrinoParserVALUES_                = 280
	TrinoParserVERBOSE_               = 281
	TrinoParserVERSION_               = 282
	TrinoParserVIEW_                  = 283
	TrinoParserWHEN_                  = 284
	TrinoParserWHERE_                 = 285
	TrinoParserWHILE_                 = 286
	TrinoParserWINDOW_                = 287
	TrinoParserWITH_                  = 288
	TrinoParserWITHIN_                = 289
	TrinoParserWITHOUT_               = 290
	TrinoParserWORK_                  = 291
	TrinoParserWRAPPER_               = 292
	TrinoParserWRITE_                 = 293
	TrinoParserYEAR_                  = 294
	TrinoParserZONE_                  = 295
	TrinoParserEQ_                    = 296
	TrinoParserNEQ_                   = 297
	TrinoParserLT_                    = 298
	TrinoParserLTE_                   = 299
	TrinoParserGT_                    = 300
	TrinoParserGTE_                   = 301
	TrinoParserPLUS_                  = 302
	TrinoParserMINUS_                 = 303
	TrinoParserASTERISK_              = 304
	TrinoParserSLASH_                 = 305
	TrinoParserPERCENT_               = 306
	TrinoParserCONCAT_                = 307
	TrinoParserQUESTION_MARK_         = 308
	TrinoParserSEMICOLON_             = 309
	TrinoParserDOT_                   = 310
	TrinoParserCOLON_                 = 311
	TrinoParserCOMMA_                 = 312
	TrinoParserLPAREN_                = 313
	TrinoParserRPAREN_                = 314
	TrinoParserLSQUARE_               = 315
	TrinoParserRSQUARE_               = 316
	TrinoParserLCURLY_                = 317
	TrinoParserRCURLY_                = 318
	TrinoParserLCURLYHYPHEN_          = 319
	TrinoParserRCURLYHYPHEN_          = 320
	TrinoParserLARROW_                = 321
	TrinoParserRARROW_                = 322
	TrinoParserRDOUBLEARROW_          = 323
	TrinoParserVBAR_                  = 324
	TrinoParserDOLLAR_                = 325
	TrinoParserCARET_                 = 326
	TrinoParserSTRING_                = 327
	TrinoParserUNICODE_STRING_        = 328
	TrinoParserBINARY_LITERAL_        = 329
	TrinoParserINTEGER_VALUE_         = 330
	TrinoParserDECIMAL_VALUE_         = 331
	TrinoParserDOUBLE_VALUE_          = 332
	TrinoParserIDENTIFIER_            = 333
	TrinoParserDIGIT_IDENTIFIER_      = 334
	TrinoParserQUOTED_IDENTIFIER_     = 335
	TrinoParserBACKQUOTED_IDENTIFIER_ = 336
	TrinoParserSIMPLE_COMMENT_        = 337
	TrinoParserBRACKETED_COMMENT_     = 338
	TrinoParserWS_                    = 339
	TrinoParserUNRECOGNIZED_          = 340
)

// TrinoParser rules.
const (
	TrinoParserRULE_parse                           = 0
	TrinoParserRULE_statements                      = 1
	TrinoParserRULE_singleStatement                 = 2
	TrinoParserRULE_standaloneExpression            = 3
	TrinoParserRULE_standalonePathSpecification     = 4
	TrinoParserRULE_standaloneType                  = 5
	TrinoParserRULE_standaloneRowPattern            = 6
	TrinoParserRULE_standaloneFunctionSpecification = 7
	TrinoParserRULE_statement                       = 8
	TrinoParserRULE_rootQuery                       = 9
	TrinoParserRULE_withFunction                    = 10
	TrinoParserRULE_query                           = 11
	TrinoParserRULE_with                            = 12
	TrinoParserRULE_tableElement                    = 13
	TrinoParserRULE_columnDefinition                = 14
	TrinoParserRULE_likeClause                      = 15
	TrinoParserRULE_properties                      = 16
	TrinoParserRULE_propertyAssignments             = 17
	TrinoParserRULE_property                        = 18
	TrinoParserRULE_propertyValue                   = 19
	TrinoParserRULE_queryNoWith                     = 20
	TrinoParserRULE_limitRowCount                   = 21
	TrinoParserRULE_rowCount                        = 22
	TrinoParserRULE_queryTerm                       = 23
	TrinoParserRULE_queryPrimary                    = 24
	TrinoParserRULE_sortItem                        = 25
	TrinoParserRULE_querySpecification              = 26
	TrinoParserRULE_groupBy                         = 27
	TrinoParserRULE_groupingElement                 = 28
	TrinoParserRULE_groupingSet                     = 29
	TrinoParserRULE_windowDefinition                = 30
	TrinoParserRULE_windowSpecification             = 31
	TrinoParserRULE_namedQuery                      = 32
	TrinoParserRULE_setQuantifier                   = 33
	TrinoParserRULE_selectItem                      = 34
	TrinoParserRULE_relation                        = 35
	TrinoParserRULE_joinType                        = 36
	TrinoParserRULE_joinCriteria                    = 37
	TrinoParserRULE_sampledRelation                 = 38
	TrinoParserRULE_sampleType                      = 39
	TrinoParserRULE_trimsSpecification              = 40
	TrinoParserRULE_listAggOverflowBehavior         = 41
	TrinoParserRULE_listaggCountIndication          = 42
	TrinoParserRULE_patternRecognition              = 43
	TrinoParserRULE_measureDefinition               = 44
	TrinoParserRULE_rowsPerMatch                    = 45
	TrinoParserRULE_emptyMatchHandling              = 46
	TrinoParserRULE_skipTo                          = 47
	TrinoParserRULE_subsetDefinition                = 48
	TrinoParserRULE_variableDefinition              = 49
	TrinoParserRULE_aliasedRelation                 = 50
	TrinoParserRULE_columnAliases                   = 51
	TrinoParserRULE_relationPrimary                 = 52
	TrinoParserRULE_tableFunctionCall               = 53
	TrinoParserRULE_tableFunctionArgument           = 54
	TrinoParserRULE_tableArgument                   = 55
	TrinoParserRULE_tableArgumentRelation           = 56
	TrinoParserRULE_descriptorArgument              = 57
	TrinoParserRULE_descriptorField                 = 58
	TrinoParserRULE_copartitionTables               = 59
	TrinoParserRULE_expression                      = 60
	TrinoParserRULE_booleanExpression               = 61
	TrinoParserRULE_predicate_                      = 62
	TrinoParserRULE_valueExpression                 = 63
	TrinoParserRULE_primaryExpression               = 64
	TrinoParserRULE_jsonPathInvocation              = 65
	TrinoParserRULE_jsonValueExpression             = 66
	TrinoParserRULE_jsonRepresentation              = 67
	TrinoParserRULE_jsonArgument                    = 68
	TrinoParserRULE_jsonExistsErrorBehavior         = 69
	TrinoParserRULE_jsonValueBehavior               = 70
	TrinoParserRULE_jsonQueryWrapperBehavior        = 71
	TrinoParserRULE_jsonQueryBehavior               = 72
	TrinoParserRULE_jsonObjectMember                = 73
	TrinoParserRULE_processingMode                  = 74
	TrinoParserRULE_nullTreatment                   = 75
	TrinoParserRULE_string_                         = 76
	TrinoParserRULE_timeZoneSpecifier               = 77
	TrinoParserRULE_comparisonOperator              = 78
	TrinoParserRULE_comparisonQuantifier            = 79
	TrinoParserRULE_booleanValue                    = 80
	TrinoParserRULE_interval                        = 81
	TrinoParserRULE_intervalField                   = 82
	TrinoParserRULE_normalForm                      = 83
	TrinoParserRULE_type                            = 84
	TrinoParserRULE_rowField                        = 85
	TrinoParserRULE_typeParameter                   = 86
	TrinoParserRULE_whenClause                      = 87
	TrinoParserRULE_filter                          = 88
	TrinoParserRULE_mergeCase                       = 89
	TrinoParserRULE_over                            = 90
	TrinoParserRULE_windowFrame                     = 91
	TrinoParserRULE_frameExtent                     = 92
	TrinoParserRULE_frameBound                      = 93
	TrinoParserRULE_rowPattern                      = 94
	TrinoParserRULE_patternPrimary                  = 95
	TrinoParserRULE_patternQuantifier               = 96
	TrinoParserRULE_updateAssignment                = 97
	TrinoParserRULE_explainOption                   = 98
	TrinoParserRULE_transactionMode                 = 99
	TrinoParserRULE_levelOfIsolation                = 100
	TrinoParserRULE_callArgument                    = 101
	TrinoParserRULE_pathElement                     = 102
	TrinoParserRULE_pathSpecification               = 103
	TrinoParserRULE_functionSpecification           = 104
	TrinoParserRULE_functionDeclaration             = 105
	TrinoParserRULE_parameterDeclaration            = 106
	TrinoParserRULE_returnsClause                   = 107
	TrinoParserRULE_routineCharacteristic           = 108
	TrinoParserRULE_controlStatement                = 109
	TrinoParserRULE_caseStatementWhenClause         = 110
	TrinoParserRULE_elseIfClause                    = 111
	TrinoParserRULE_elseClause                      = 112
	TrinoParserRULE_variableDeclaration             = 113
	TrinoParserRULE_sqlStatementList                = 114
	TrinoParserRULE_privilege                       = 115
	TrinoParserRULE_qualifiedName                   = 116
	TrinoParserRULE_queryPeriod                     = 117
	TrinoParserRULE_rangeType                       = 118
	TrinoParserRULE_grantor                         = 119
	TrinoParserRULE_principal                       = 120
	TrinoParserRULE_roles                           = 121
	TrinoParserRULE_identifier                      = 122
	TrinoParserRULE_number                          = 123
	TrinoParserRULE_authorizationUser               = 124
	TrinoParserRULE_nonReserved                     = 125
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_parse
	return p
}

func InitEmptyParseContext(p *ParseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_parse
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(TrinoParserEOF, 0)
}

func (s *ParseContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *ParseContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitParse(s)
	}
}

func (s *ParseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitParse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Parse() (localctx IParseContext) {
	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, TrinoParserRULE_parse)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611695235427862786) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347098961875043977) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-144150373018374145) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-9074541044212965921) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&4095) != 0) {
		{
			p.SetState(252)
			p.Statements()
		}

		p.SetState(257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(258)
		p.Match(TrinoParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleStatement() ISingleStatementContext
	StandaloneExpression() IStandaloneExpressionContext
	StandalonePathSpecification() IStandalonePathSpecificationContext
	StandaloneType() IStandaloneTypeContext
	StandaloneRowPattern() IStandaloneRowPatternContext
	SEMICOLON_() antlr.TerminalNode
	StandaloneFunctionSpecification() IStandaloneFunctionSpecificationContext

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) SingleStatement() ISingleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *StatementsContext) StandaloneExpression() IStandaloneExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandaloneExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandaloneExpressionContext)
}

func (s *StatementsContext) StandalonePathSpecification() IStandalonePathSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandalonePathSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandalonePathSpecificationContext)
}

func (s *StatementsContext) StandaloneType() IStandaloneTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandaloneTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandaloneTypeContext)
}

func (s *StatementsContext) StandaloneRowPattern() IStandaloneRowPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandaloneRowPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandaloneRowPatternContext)
}

func (s *StatementsContext) SEMICOLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, 0)
}

func (s *StatementsContext) StandaloneFunctionSpecification() IStandaloneFunctionSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandaloneFunctionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandaloneFunctionSpecificationContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, TrinoParserRULE_statements)
	var _la int

	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(260)
			p.SingleStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(261)
			p.StandaloneExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(262)
			p.StandalonePathSpecification()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(263)
			p.StandaloneType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(264)
			p.StandaloneRowPattern()
		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserSEMICOLON_ {
			{
				p.SetState(265)
				p.Match(TrinoParserSEMICOLON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(268)
			p.StandaloneFunctionSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SEMICOLON_() antlr.TerminalNode

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) SEMICOLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, 0)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (s *SingleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSingleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, TrinoParserRULE_singleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(271)
		p.Statement()
	}
	{
		p.SetState(272)
		p.Match(TrinoParserSEMICOLON_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneExpressionContext is an interface to support dynamic dispatch.
type IStandaloneExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	SEMICOLON_() antlr.TerminalNode

	// IsStandaloneExpressionContext differentiates from other interfaces.
	IsStandaloneExpressionContext()
}

type StandaloneExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneExpressionContext() *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneExpression
	return p
}

func InitEmptyStandaloneExpressionContext(p *StandaloneExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneExpression
}

func (*StandaloneExpressionContext) IsStandaloneExpressionContext() {}

func NewStandaloneExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_standaloneExpression

	return p
}

func (s *StandaloneExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StandaloneExpressionContext) SEMICOLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, 0)
}

func (s *StandaloneExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStandaloneExpression(s)
	}
}

func (s *StandaloneExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStandaloneExpression(s)
	}
}

func (s *StandaloneExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStandaloneExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) StandaloneExpression() (localctx IStandaloneExpressionContext) {
	localctx = NewStandaloneExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, TrinoParserRULE_standaloneExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(274)
		p.Expression()
	}
	{
		p.SetState(275)
		p.Match(TrinoParserSEMICOLON_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandalonePathSpecificationContext is an interface to support dynamic dispatch.
type IStandalonePathSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathSpecification() IPathSpecificationContext
	SEMICOLON_() antlr.TerminalNode

	// IsStandalonePathSpecificationContext differentiates from other interfaces.
	IsStandalonePathSpecificationContext()
}

type StandalonePathSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandalonePathSpecificationContext() *StandalonePathSpecificationContext {
	var p = new(StandalonePathSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standalonePathSpecification
	return p
}

func InitEmptyStandalonePathSpecificationContext(p *StandalonePathSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standalonePathSpecification
}

func (*StandalonePathSpecificationContext) IsStandalonePathSpecificationContext() {}

func NewStandalonePathSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandalonePathSpecificationContext {
	var p = new(StandalonePathSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_standalonePathSpecification

	return p
}

func (s *StandalonePathSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *StandalonePathSpecificationContext) PathSpecification() IPathSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathSpecificationContext)
}

func (s *StandalonePathSpecificationContext) SEMICOLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, 0)
}

func (s *StandalonePathSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandalonePathSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandalonePathSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStandalonePathSpecification(s)
	}
}

func (s *StandalonePathSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStandalonePathSpecification(s)
	}
}

func (s *StandalonePathSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStandalonePathSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) StandalonePathSpecification() (localctx IStandalonePathSpecificationContext) {
	localctx = NewStandalonePathSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, TrinoParserRULE_standalonePathSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.PathSpecification()
	}
	{
		p.SetState(278)
		p.Match(TrinoParserSEMICOLON_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneTypeContext is an interface to support dynamic dispatch.
type IStandaloneTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	SEMICOLON_() antlr.TerminalNode

	// IsStandaloneTypeContext differentiates from other interfaces.
	IsStandaloneTypeContext()
}

type StandaloneTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneTypeContext() *StandaloneTypeContext {
	var p = new(StandaloneTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneType
	return p
}

func InitEmptyStandaloneTypeContext(p *StandaloneTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneType
}

func (*StandaloneTypeContext) IsStandaloneTypeContext() {}

func NewStandaloneTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneTypeContext {
	var p = new(StandaloneTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_standaloneType

	return p
}

func (s *StandaloneTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *StandaloneTypeContext) SEMICOLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, 0)
}

func (s *StandaloneTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStandaloneType(s)
	}
}

func (s *StandaloneTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStandaloneType(s)
	}
}

func (s *StandaloneTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStandaloneType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) StandaloneType() (localctx IStandaloneTypeContext) {
	localctx = NewStandaloneTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, TrinoParserRULE_standaloneType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.type_(0)
	}
	{
		p.SetState(281)
		p.Match(TrinoParserSEMICOLON_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneRowPatternContext is an interface to support dynamic dispatch.
type IStandaloneRowPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RowPattern() IRowPatternContext
	SEMICOLON_() antlr.TerminalNode

	// IsStandaloneRowPatternContext differentiates from other interfaces.
	IsStandaloneRowPatternContext()
}

type StandaloneRowPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneRowPatternContext() *StandaloneRowPatternContext {
	var p = new(StandaloneRowPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneRowPattern
	return p
}

func InitEmptyStandaloneRowPatternContext(p *StandaloneRowPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneRowPattern
}

func (*StandaloneRowPatternContext) IsStandaloneRowPatternContext() {}

func NewStandaloneRowPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneRowPatternContext {
	var p = new(StandaloneRowPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_standaloneRowPattern

	return p
}

func (s *StandaloneRowPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneRowPatternContext) RowPattern() IRowPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *StandaloneRowPatternContext) SEMICOLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, 0)
}

func (s *StandaloneRowPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneRowPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneRowPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStandaloneRowPattern(s)
	}
}

func (s *StandaloneRowPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStandaloneRowPattern(s)
	}
}

func (s *StandaloneRowPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStandaloneRowPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) StandaloneRowPattern() (localctx IStandaloneRowPatternContext) {
	localctx = NewStandaloneRowPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, TrinoParserRULE_standaloneRowPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.rowPattern(0)
	}
	{
		p.SetState(284)
		p.Match(TrinoParserSEMICOLON_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneFunctionSpecificationContext is an interface to support dynamic dispatch.
type IStandaloneFunctionSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionSpecification() IFunctionSpecificationContext
	SEMICOLON_() antlr.TerminalNode

	// IsStandaloneFunctionSpecificationContext differentiates from other interfaces.
	IsStandaloneFunctionSpecificationContext()
}

type StandaloneFunctionSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneFunctionSpecificationContext() *StandaloneFunctionSpecificationContext {
	var p = new(StandaloneFunctionSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneFunctionSpecification
	return p
}

func InitEmptyStandaloneFunctionSpecificationContext(p *StandaloneFunctionSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_standaloneFunctionSpecification
}

func (*StandaloneFunctionSpecificationContext) IsStandaloneFunctionSpecificationContext() {}

func NewStandaloneFunctionSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneFunctionSpecificationContext {
	var p = new(StandaloneFunctionSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_standaloneFunctionSpecification

	return p
}

func (s *StandaloneFunctionSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneFunctionSpecificationContext) FunctionSpecification() IFunctionSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSpecificationContext)
}

func (s *StandaloneFunctionSpecificationContext) SEMICOLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, 0)
}

func (s *StandaloneFunctionSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneFunctionSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneFunctionSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStandaloneFunctionSpecification(s)
	}
}

func (s *StandaloneFunctionSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStandaloneFunctionSpecification(s)
	}
}

func (s *StandaloneFunctionSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStandaloneFunctionSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) StandaloneFunctionSpecification() (localctx IStandaloneFunctionSpecificationContext) {
	localctx = NewStandaloneFunctionSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, TrinoParserRULE_standaloneFunctionSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(286)
		p.FunctionSpecification()
	}
	{
		p.SetState(287)
		p.Match(TrinoParserSEMICOLON_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainContext struct {
	StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXPLAIN_, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *ExplainContext) AllExplainOption() []IExplainOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExplainOptionContext); ok {
			len++
		}
	}

	tst := make([]IExplainOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExplainOptionContext); ok {
			tst[i] = t.(IExplainOptionContext)
			i++
		}
	}

	return tst
}

func (s *ExplainContext) ExplainOption(i int) IExplainOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainOptionContext)
}

func (s *ExplainContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *ExplainContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *ExplainContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExplain(s)
	}
}

func (s *ExplainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExplain(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrepareContext struct {
	StatementContext
}

func NewPrepareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrepareContext {
	var p = new(PrepareContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *PrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareContext) PREPARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPREPARE_, 0)
}

func (s *PrepareContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *PrepareContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPrepare(s)
	}
}

func (s *PrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPrepare(s)
	}
}

func (s *PrepareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPrepare(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropMaterializedViewContext struct {
	StatementContext
}

func NewDropMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropMaterializedViewContext {
	var p = new(DropMaterializedViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropMaterializedViewContext) MATERIALIZED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATERIALIZED_, 0)
}

func (s *DropMaterializedViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *DropMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropMaterializedViewContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *DropMaterializedViewContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *DropMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropMaterializedView(s)
	}
}

func (s *DropMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropMaterializedView(s)
	}
}

func (s *DropMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetMaterializedViewPropertiesContext struct {
	StatementContext
}

func NewSetMaterializedViewPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetMaterializedViewPropertiesContext {
	var p = new(SetMaterializedViewPropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetMaterializedViewPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetMaterializedViewPropertiesContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *SetMaterializedViewPropertiesContext) MATERIALIZED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATERIALIZED_, 0)
}

func (s *SetMaterializedViewPropertiesContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *SetMaterializedViewPropertiesContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetMaterializedViewPropertiesContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetMaterializedViewPropertiesContext) PROPERTIES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPROPERTIES_, 0)
}

func (s *SetMaterializedViewPropertiesContext) PropertyAssignments() IPropertyAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentsContext)
}

func (s *SetMaterializedViewPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetMaterializedViewProperties(s)
	}
}

func (s *SetMaterializedViewPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetMaterializedViewProperties(s)
	}
}

func (s *SetMaterializedViewPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetMaterializedViewProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

type UseContext struct {
	StatementContext
	schema  IIdentifierContext
	catalog IIdentifierContext
}

func NewUseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseContext {
	var p = new(UseContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UseContext) GetSchema() IIdentifierContext { return s.schema }

func (s *UseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseContext) SetSchema(v IIdentifierContext) { s.schema = v }

func (s *UseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseContext) USE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSE_, 0)
}

func (s *UseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseContext) DOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOT_, 0)
}

func (s *UseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUse(s)
	}
}

func (s *UseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUse(s)
	}
}

func (s *UseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUse(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeallocateContext struct {
	StatementContext
}

func NewDeallocateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeallocateContext {
	var p = new(DeallocateContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DeallocateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateContext) DEALLOCATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEALLOCATE_, 0)
}

func (s *DeallocateContext) PREPARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPREPARE_, 0)
}

func (s *DeallocateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDeallocate(s)
	}
}

func (s *DeallocateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDeallocate(s)
	}
}

func (s *DeallocateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDeallocate(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameTableContext struct {
	StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTableContext {
	var p = new(RenameTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameTableContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameTableContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameTableContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameTableContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *RenameTableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *RenameTableContext) RENAME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRENAME_, 0)
}

func (s *RenameTableContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *RenameTableContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameTableContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *RenameTableContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

func (s *RenameTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRenameTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommitContext struct {
	StatementContext
}

func NewCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommitContext {
	var p = new(CommitContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) COMMIT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMIT_, 0)
}

func (s *CommitContext) WORK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWORK_, 0)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCommit(s)
	}
}

func (s *CommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCommit(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateRoleContext struct {
	StatementContext
	name    IIdentifierContext
	catalog IIdentifierContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoleContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *CreateRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoleContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateRoleContext) ROLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLE_, 0)
}

func (s *CreateRoleContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoleContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoleContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *CreateRoleContext) ADMIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserADMIN_, 0)
}

func (s *CreateRoleContext) Grantor() IGrantorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *CreateRoleContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropColumnContext struct {
	StatementContext
	tableName IQualifiedNameContext
	column    IQualifiedNameContext
}

func NewDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnContext {
	var p = new(DropColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *DropColumnContext) GetColumn() IQualifiedNameContext { return s.column }

func (s *DropColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *DropColumnContext) SetColumn(v IQualifiedNameContext) { s.column = v }

func (s *DropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *DropColumnContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *DropColumnContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropColumnContext) COLUMN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMN_, 0)
}

func (s *DropColumnContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *DropColumnContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropColumnContext) AllIF_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserIF_)
}

func (s *DropColumnContext) IF_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, i)
}

func (s *DropColumnContext) AllEXISTS_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserEXISTS_)
}

func (s *DropColumnContext) EXISTS_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, i)
}

func (s *DropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropColumn(s)
	}
}

func (s *DropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropColumn(s)
	}
}

func (s *DropColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropViewContext struct {
	StatementContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *DropViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *DropViewContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTablesContext struct {
	StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowTablesContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowTablesContext) GetEscape() IString_Context { return s.escape }

func (s *ShowTablesContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowTablesContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowTablesContext) TABLES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLES_, 0)
}

func (s *ShowTablesContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTablesContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *ShowTablesContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *ShowTablesContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *ShowTablesContext) AllString_() []IString_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IString_Context); ok {
			len++
		}
	}

	tst := make([]IString_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IString_Context); ok {
			tst[i] = t.(IString_Context)
			i++
		}
	}

	return tst
}

func (s *ShowTablesContext) String_(i int) IString_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowTablesContext) ESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserESCAPE_, 0)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowTables(s)
	}
}

func (s *ShowTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetViewAuthorizationContext struct {
	StatementContext
	from IQualifiedNameContext
}

func NewSetViewAuthorizationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetViewAuthorizationContext {
	var p = new(SetViewAuthorizationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetViewAuthorizationContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *SetViewAuthorizationContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *SetViewAuthorizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetViewAuthorizationContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *SetViewAuthorizationContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *SetViewAuthorizationContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetViewAuthorizationContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *SetViewAuthorizationContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *SetViewAuthorizationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetViewAuthorizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetViewAuthorization(s)
	}
}

func (s *SetViewAuthorizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetViewAuthorization(s)
	}
}

func (s *SetViewAuthorizationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetViewAuthorization(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCatalogsContext struct {
	StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCatalogsContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowCatalogsContext) GetEscape() IString_Context { return s.escape }

func (s *ShowCatalogsContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowCatalogsContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowCatalogsContext) CATALOGS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCATALOGS_, 0)
}

func (s *ShowCatalogsContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *ShowCatalogsContext) AllString_() []IString_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IString_Context); ok {
			len++
		}
	}

	tst := make([]IString_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IString_Context); ok {
			tst[i] = t.(IString_Context)
			i++
		}
	}

	return tst
}

func (s *ShowCatalogsContext) String_(i int) IString_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowCatalogsContext) ESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserESCAPE_, 0)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowCatalogs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRolesContext struct {
	StatementContext
}

func NewShowRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesContext {
	var p = new(ShowRolesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowRolesContext) ROLES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLES_, 0)
}

func (s *ShowRolesContext) CURRENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_, 0)
}

func (s *ShowRolesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRolesContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *ShowRolesContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

func (s *ShowRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

type MergeContext struct {
	StatementContext
}

func NewMergeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MergeContext {
	var p = new(MergeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *MergeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeContext) MERGE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMERGE_, 0)
}

func (s *MergeContext) INTO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTO_, 0)
}

func (s *MergeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *MergeContext) USING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSING_, 0)
}

func (s *MergeContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *MergeContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *MergeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MergeContext) AllMergeCase() []IMergeCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeCaseContext); ok {
			len++
		}
	}

	tst := make([]IMergeCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeCaseContext); ok {
			tst[i] = t.(IMergeCaseContext)
			i++
		}
	}

	return tst
}

func (s *MergeContext) MergeCase(i int) IMergeCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeCaseContext)
}

func (s *MergeContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *MergeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterMerge(s)
	}
}

func (s *MergeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitMerge(s)
	}
}

func (s *MergeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitMerge(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameColumnContext struct {
	StatementContext
	tableName IQualifiedNameContext
	from      IQualifiedNameContext
	to        IIdentifierContext
}

func NewRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnContext {
	var p = new(RenameColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *RenameColumnContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameColumnContext) GetTo() IIdentifierContext { return s.to }

func (s *RenameColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *RenameColumnContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameColumnContext) SetTo(v IIdentifierContext) { s.to = v }

func (s *RenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *RenameColumnContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *RenameColumnContext) RENAME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRENAME_, 0)
}

func (s *RenameColumnContext) COLUMN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMN_, 0)
}

func (s *RenameColumnContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *RenameColumnContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameColumnContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnContext) AllIF_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserIF_)
}

func (s *RenameColumnContext) IF_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, i)
}

func (s *RenameColumnContext) AllEXISTS_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserEXISTS_)
}

func (s *RenameColumnContext) EXISTS_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, i)
}

func (s *RenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRenameColumn(s)
	}
}

func (s *RenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRenameColumn(s)
	}
}

func (s *RenameColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRenameColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommentColumnContext struct {
	StatementContext
}

func NewCommentColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentColumnContext {
	var p = new(CommentColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommentColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentColumnContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CommentColumnContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *CommentColumnContext) COLUMN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMN_, 0)
}

func (s *CommentColumnContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CommentColumnContext) IS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIS_, 0)
}

func (s *CommentColumnContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CommentColumnContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *CommentColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCommentColumn(s)
	}
}

func (s *CommentColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCommentColumn(s)
	}
}

func (s *CommentColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCommentColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeRolesContext struct {
	StatementContext
	catalog IIdentifierContext
}

func NewRevokeRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRolesContext {
	var p = new(RevokeRolesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RevokeRolesContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *RevokeRolesContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *RevokeRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRolesContext) REVOKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREVOKE_, 0)
}

func (s *RevokeRolesContext) Roles() IRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *RevokeRolesContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *RevokeRolesContext) AllPrincipal() []IPrincipalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrincipalContext); ok {
			len++
		}
	}

	tst := make([]IPrincipalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrincipalContext); ok {
			tst[i] = t.(IPrincipalContext)
			i++
		}
	}

	return tst
}

func (s *RevokeRolesContext) Principal(i int) IPrincipalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeRolesContext) ADMIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserADMIN_, 0)
}

func (s *RevokeRolesContext) OPTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOPTION_, 0)
}

func (s *RevokeRolesContext) FOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOR_, 0)
}

func (s *RevokeRolesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *RevokeRolesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *RevokeRolesContext) GRANTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANTED_, 0)
}

func (s *RevokeRolesContext) BY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, 0)
}

func (s *RevokeRolesContext) Grantor() IGrantorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *RevokeRolesContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *RevokeRolesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RevokeRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRevokeRoles(s)
	}
}

func (s *RevokeRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRevokeRoles(s)
	}
}

func (s *RevokeRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRevokeRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateTableContext struct {
	StatementContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowCreateTableContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *ShowCreateTableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *ShowCreateTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowColumnsContext struct {
	StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowColumnsContext) GetEscape() IString_Context { return s.escape }

func (s *ShowColumnsContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowColumnsContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowColumnsContext) COLUMNS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMNS_, 0)
}

func (s *ShowColumnsContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *ShowColumnsContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *ShowColumnsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnsContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *ShowColumnsContext) AllString_() []IString_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IString_Context); ok {
			len++
		}
	}

	tst := make([]IString_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IString_Context); ok {
			tst[i] = t.(IString_Context)
			i++
		}
	}

	return tst
}

func (s *ShowColumnsContext) String_(i int) IString_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowColumnsContext) ESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserESCAPE_, 0)
}

func (s *ShowColumnsContext) DESCRIBE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESCRIBE_, 0)
}

func (s *ShowColumnsContext) DESC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESC_, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

func (s *ShowColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRoleGrantsContext struct {
	StatementContext
}

func NewShowRoleGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoleGrantsContext {
	var p = new(ShowRoleGrantsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowRoleGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoleGrantsContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowRoleGrantsContext) ROLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLE_, 0)
}

func (s *ShowRoleGrantsContext) GRANTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANTS_, 0)
}

func (s *ShowRoleGrantsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoleGrantsContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *ShowRoleGrantsContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *ShowRoleGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowRoleGrants(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddColumnContext struct {
	StatementContext
	tableName IQualifiedNameContext
	column    IColumnDefinitionContext
}

func NewAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnContext {
	var p = new(AddColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AddColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *AddColumnContext) GetColumn() IColumnDefinitionContext { return s.column }

func (s *AddColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *AddColumnContext) SetColumn(v IColumnDefinitionContext) { s.column = v }

func (s *AddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *AddColumnContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *AddColumnContext) ADD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserADD_, 0)
}

func (s *AddColumnContext) COLUMN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMN_, 0)
}

func (s *AddColumnContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AddColumnContext) AllIF_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserIF_)
}

func (s *AddColumnContext) IF_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, i)
}

func (s *AddColumnContext) AllEXISTS_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserEXISTS_)
}

func (s *AddColumnContext) EXISTS_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, i)
}

func (s *AddColumnContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *AddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterAddColumn(s)
	}
}

func (s *AddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitAddColumn(s)
	}
}

func (s *AddColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitAddColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type DenyContext struct {
	StatementContext
	grantee IPrincipalContext
}

func NewDenyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DenyContext {
	var p = new(DenyContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DenyContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *DenyContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *DenyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DenyContext) DENY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDENY_, 0)
}

func (s *DenyContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *DenyContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DenyContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *DenyContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *DenyContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *DenyContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *DenyContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *DenyContext) PRIVILEGES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRIVILEGES_, 0)
}

func (s *DenyContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *DenyContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *DenyContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *DenyContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *DenyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDeny(s)
	}
}

func (s *DenyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDeny(s)
	}
}

func (s *DenyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDeny(s)

	default:
		return t.VisitChildren(s)
	}
}

type ResetSessionContext struct {
	StatementContext
}

func NewResetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetSessionContext {
	var p = new(ResetSessionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ResetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSessionContext) RESET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESET_, 0)
}

func (s *ResetSessionContext) SESSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSESSION_, 0)
}

func (s *ResetSessionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterResetSession(s)
	}
}

func (s *ResetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitResetSession(s)
	}
}

func (s *ResetSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitResetSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type InsertIntoContext struct {
	StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINSERT_, 0)
}

func (s *InsertIntoContext) INTO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTO_, 0)
}

func (s *InsertIntoContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertIntoContext) RootQuery() IRootQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRootQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRootQueryContext)
}

func (s *InsertIntoContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

func (s *InsertIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitInsertInto(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSessionContext struct {
	StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSessionContext {
	var p = new(ShowSessionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowSessionContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowSessionContext) GetEscape() IString_Context { return s.escape }

func (s *ShowSessionContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowSessionContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSessionContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowSessionContext) SESSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSESSION_, 0)
}

func (s *ShowSessionContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *ShowSessionContext) AllString_() []IString_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IString_Context); ok {
			len++
		}
	}

	tst := make([]IString_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IString_Context); ok {
			tst[i] = t.(IString_Context)
			i++
		}
	}

	return tst
}

func (s *ShowSessionContext) String_(i int) IString_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowSessionContext) ESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserESCAPE_, 0)
}

func (s *ShowSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowSession(s)
	}
}

func (s *ShowSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowSession(s)
	}
}

func (s *ShowSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateSchemaContext struct {
	StatementContext
}

func NewCreateSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSchemaContext {
	var p = new(CreateSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSchemaContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateSchemaContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *CreateSchemaContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateSchemaContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *CreateSchemaContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *CreateSchemaContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *CreateSchemaContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *CreateSchemaContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *CreateSchemaContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *CreateSchemaContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateSchema(s)
	}
}

func (s *CreateSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateSchema(s)
	}
}

func (s *CreateSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSessionAuthorizationContext struct {
	StatementContext
}

func NewSetSessionAuthorizationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSessionAuthorizationContext {
	var p = new(SetSessionAuthorizationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetSessionAuthorizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSessionAuthorizationContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetSessionAuthorizationContext) SESSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSESSION_, 0)
}

func (s *SetSessionAuthorizationContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *SetSessionAuthorizationContext) AuthorizationUser() IAuthorizationUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthorizationUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthorizationUserContext)
}

func (s *SetSessionAuthorizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetSessionAuthorization(s)
	}
}

func (s *SetSessionAuthorizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetSessionAuthorization(s)
	}
}

func (s *SetSessionAuthorizationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetSessionAuthorization(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExplainAnalyzeContext struct {
	StatementContext
}

func NewExplainAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainAnalyzeContext {
	var p = new(ExplainAnalyzeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExplainAnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainAnalyzeContext) EXPLAIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXPLAIN_, 0)
}

func (s *ExplainAnalyzeContext) ANALYZE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserANALYZE_, 0)
}

func (s *ExplainAnalyzeContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainAnalyzeContext) VERBOSE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVERBOSE_, 0)
}

func (s *ExplainAnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExplainAnalyze(s)
	}
}

func (s *ExplainAnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExplainAnalyze(s)
	}
}

func (s *ExplainAnalyzeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExplainAnalyze(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExecuteContext struct {
	StatementContext
}

func NewExecuteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExecuteContext {
	var p = new(ExecuteContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteContext) EXECUTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXECUTE_, 0)
}

func (s *ExecuteContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteContext) USING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSING_, 0)
}

func (s *ExecuteContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExecuteContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *ExecuteContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *ExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExecute(s)
	}
}

func (s *ExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExecute(s)
	}
}

func (s *ExecuteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExecute(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameSchemaContext struct {
	StatementContext
}

func NewRenameSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameSchemaContext {
	var p = new(RenameSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameSchemaContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *RenameSchemaContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *RenameSchemaContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameSchemaContext) RENAME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRENAME_, 0)
}

func (s *RenameSchemaContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *RenameSchemaContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRenameSchema(s)
	}
}

func (s *RenameSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRenameSchema(s)
	}
}

func (s *RenameSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRenameSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropRoleContext struct {
	StatementContext
	name    IIdentifierContext
	catalog IIdentifierContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierContext { return s.name }

func (s *DropRoleContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *DropRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRoleContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropRoleContext) ROLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLE_, 0)
}

func (s *DropRoleContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropRoleContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRoleContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type AnalyzeContext struct {
	StatementContext
}

func NewAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeContext {
	var p = new(AnalyzeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeContext) ANALYZE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserANALYZE_, 0)
}

func (s *AnalyzeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnalyzeContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *AnalyzeContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterAnalyze(s)
	}
}

func (s *AnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitAnalyze(s)
	}
}

func (s *AnalyzeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitAnalyze(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetRoleContext struct {
	StatementContext
	role    IIdentifierContext
	catalog IIdentifierContext
}

func NewSetRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetRoleContext {
	var p = new(SetRoleContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetRoleContext) GetRole() IIdentifierContext { return s.role }

func (s *SetRoleContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *SetRoleContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *SetRoleContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetRoleContext) ROLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLE_, 0)
}

func (s *SetRoleContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *SetRoleContext) NONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNONE_, 0)
}

func (s *SetRoleContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetRoleContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateFunctionContext struct {
	StatementContext
}

func NewCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateFunctionContext) FunctionSpecification() IFunctionSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSpecificationContext)
}

func (s *CreateFunctionContext) OR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOR_, 0)
}

func (s *CreateFunctionContext) REPLACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPLACE_, 0)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (s *CreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropCatalogContext struct {
	StatementContext
	catalog IIdentifierContext
}

func NewDropCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogContext {
	var p = new(DropCatalogContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropCatalogContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *DropCatalogContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *DropCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropCatalogContext) CATALOG_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCATALOG_, 0)
}

func (s *DropCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropCatalogContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *DropCatalogContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *DropCatalogContext) CASCADE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCASCADE_, 0)
}

func (s *DropCatalogContext) RESTRICT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESTRICT_, 0)
}

func (s *DropCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropCatalog(s)
	}
}

func (s *DropCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropCatalog(s)
	}
}

func (s *DropCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGrantsContext struct {
	StatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowGrantsContext) GRANTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANTS_, 0)
}

func (s *ShowGrantsContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *ShowGrantsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowGrantsContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

func (s *ShowGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowGrants(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropSchemaContext struct {
	StatementContext
}

func NewDropSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSchemaContext {
	var p = new(DropSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSchemaContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropSchemaContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *DropSchemaContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropSchemaContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *DropSchemaContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *DropSchemaContext) CASCADE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCASCADE_, 0)
}

func (s *DropSchemaContext) RESTRICT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESTRICT_, 0)
}

func (s *DropSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropSchema(s)
	}
}

func (s *DropSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropSchema(s)
	}
}

func (s *DropSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type ResetSessionAuthorizationContext struct {
	StatementContext
}

func NewResetSessionAuthorizationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetSessionAuthorizationContext {
	var p = new(ResetSessionAuthorizationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ResetSessionAuthorizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSessionAuthorizationContext) RESET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESET_, 0)
}

func (s *ResetSessionAuthorizationContext) SESSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSESSION_, 0)
}

func (s *ResetSessionAuthorizationContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *ResetSessionAuthorizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterResetSessionAuthorization(s)
	}
}

func (s *ResetSessionAuthorizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitResetSessionAuthorization(s)
	}
}

func (s *ResetSessionAuthorizationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitResetSessionAuthorization(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetTableAuthorizationContext struct {
	StatementContext
	tableName IQualifiedNameContext
}

func NewSetTableAuthorizationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTableAuthorizationContext {
	var p = new(SetTableAuthorizationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetTableAuthorizationContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *SetTableAuthorizationContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *SetTableAuthorizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTableAuthorizationContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *SetTableAuthorizationContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *SetTableAuthorizationContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetTableAuthorizationContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *SetTableAuthorizationContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *SetTableAuthorizationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetTableAuthorizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetTableAuthorization(s)
	}
}

func (s *SetTableAuthorizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetTableAuthorization(s)
	}
}

func (s *SetTableAuthorizationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetTableAuthorization(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateViewContext struct {
	StatementContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowCreateViewContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *ShowCreateViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *ShowCreateViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateTableContext struct {
	StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateTableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *CreateTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *CreateTableContext) AllTableElement() []ITableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementContext); ok {
			len++
		}
	}

	tst := make([]ITableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementContext); ok {
			tst[i] = t.(ITableElementContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) TableElement(i int) ITableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *CreateTableContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *CreateTableContext) OR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOR_, 0)
}

func (s *CreateTableContext) REPLACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPLACE_, 0)
}

func (s *CreateTableContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *CreateTableContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *CreateTableContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *CreateTableContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *CreateTableContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *CreateTableContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CreateTableContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateTableContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *CreateTableContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (s *CreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type StartTransactionContext struct {
	StatementContext
}

func NewStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StartTransactionContext {
	var p = new(StartTransactionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) START_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSTART_, 0)
}

func (s *StartTransactionContext) TRANSACTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRANSACTION_, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *StartTransactionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

func (s *StartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateTableAsSelectContext struct {
	StatementContext
}

func NewCreateTableAsSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateTableAsSelectContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *CreateTableAsSelectContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *CreateTableAsSelectContext) RootQuery() IRootQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRootQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRootQueryContext)
}

func (s *CreateTableAsSelectContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *CreateTableAsSelectContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *CreateTableAsSelectContext) OR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOR_, 0)
}

func (s *CreateTableAsSelectContext) REPLACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPLACE_, 0)
}

func (s *CreateTableAsSelectContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *CreateTableAsSelectContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *CreateTableAsSelectContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *CreateTableAsSelectContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CreateTableAsSelectContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CreateTableAsSelectContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateTableAsSelectContext) AllWITH_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserWITH_)
}

func (s *CreateTableAsSelectContext) WITH_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, i)
}

func (s *CreateTableAsSelectContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectContext) DATA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDATA_, 0)
}

func (s *CreateTableAsSelectContext) NO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNO_, 0)
}

func (s *CreateTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateTableAsSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommentViewContext struct {
	StatementContext
}

func NewCommentViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentViewContext {
	var p = new(CommentViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommentViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentViewContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CommentViewContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *CommentViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *CommentViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CommentViewContext) IS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIS_, 0)
}

func (s *CommentViewContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CommentViewContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *CommentViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCommentView(s)
	}
}

func (s *CommentViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCommentView(s)
	}
}

func (s *CommentViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCommentView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStatsContext struct {
	StatementContext
}

func NewShowStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsContext {
	var p = new(ShowStatsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowStatsContext) STATS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSTATS_, 0)
}

func (s *ShowStatsContext) FOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOR_, 0)
}

func (s *ShowStatsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowStats(s)
	}
}

func (s *ShowStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowStats(s)
	}
}

func (s *ShowStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateSchemaContext struct {
	StatementContext
}

func NewShowCreateSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateSchemaContext {
	var p = new(ShowCreateSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateSchemaContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowCreateSchemaContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *ShowCreateSchemaContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *ShowCreateSchemaContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowCreateSchema(s)
	}
}

func (s *ShowCreateSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowCreateSchema(s)
	}
}

func (s *ShowCreateSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowCreateSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropFunctionContext struct {
	StatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropFunctionContext) FUNCTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFUNCTION_, 0)
}

func (s *DropFunctionContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DropFunctionContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *DropFunctionContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeContext struct {
	StatementContext
	grantee IPrincipalContext
}

func NewRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeContext {
	var p = new(RevokeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RevokeContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *RevokeContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) REVOKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREVOKE_, 0)
}

func (s *RevokeContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *RevokeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RevokeContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *RevokeContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *RevokeContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *RevokeContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *RevokeContext) PRIVILEGES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRIVILEGES_, 0)
}

func (s *RevokeContext) GRANT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANT_, 0)
}

func (s *RevokeContext) OPTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOPTION_, 0)
}

func (s *RevokeContext) FOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOR_, 0)
}

func (s *RevokeContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *RevokeContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *RevokeContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *RevokeContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (s *RevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

type UpdateContext struct {
	StatementContext
	where IBooleanExpressionContext
}

func NewUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateContext {
	var p = new(UpdateContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UpdateContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *UpdateContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) UPDATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUPDATE_, 0)
}

func (s *UpdateContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpdateContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *UpdateContext) AllUpdateAssignment() []IUpdateAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IUpdateAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateAssignmentContext); ok {
			tst[i] = t.(IUpdateAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *UpdateContext) UpdateAssignment(i int) IUpdateAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentContext)
}

func (s *UpdateContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *UpdateContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *UpdateContext) WHERE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHERE_, 0)
}

func (s *UpdateContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUpdate(s)
	}
}

func (s *UpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableExecuteContext struct {
	StatementContext
	tableName     IQualifiedNameContext
	procedureName IIdentifierContext
	where         IBooleanExpressionContext
}

func NewTableExecuteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExecuteContext {
	var p = new(TableExecuteContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *TableExecuteContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *TableExecuteContext) GetProcedureName() IIdentifierContext { return s.procedureName }

func (s *TableExecuteContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *TableExecuteContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *TableExecuteContext) SetProcedureName(v IIdentifierContext) { s.procedureName = v }

func (s *TableExecuteContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *TableExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExecuteContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *TableExecuteContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *TableExecuteContext) EXECUTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXECUTE_, 0)
}

func (s *TableExecuteContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableExecuteContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableExecuteContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *TableExecuteContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *TableExecuteContext) WHERE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHERE_, 0)
}

func (s *TableExecuteContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *TableExecuteContext) AllCallArgument() []ICallArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICallArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallArgumentContext); ok {
			tst[i] = t.(ICallArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TableExecuteContext) CallArgument(i int) ICallArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentContext)
}

func (s *TableExecuteContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *TableExecuteContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *TableExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableExecute(s)
	}
}

func (s *TableExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableExecute(s)
	}
}

func (s *TableExecuteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableExecute(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteContext struct {
	StatementContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDELETE_, 0)
}

func (s *DeleteContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *DeleteContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteContext) WHERE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHERE_, 0)
}

func (s *DeleteContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDelete(s)
	}
}

func (s *DeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeInputContext struct {
	StatementContext
}

func NewDescribeInputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeInputContext {
	var p = new(DescribeInputContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeInputContext) DESCRIBE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESCRIBE_, 0)
}

func (s *DescribeInputContext) INPUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINPUT_, 0)
}

func (s *DescribeInputContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDescribeInput(s)
	}
}

func (s *DescribeInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDescribeInput(s)
	}
}

func (s *DescribeInputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDescribeInput(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStatsForQueryContext struct {
	StatementContext
}

func NewShowStatsForQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsForQueryContext {
	var p = new(ShowStatsForQueryContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsForQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsForQueryContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowStatsForQueryContext) STATS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSTATS_, 0)
}

func (s *ShowStatsForQueryContext) FOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOR_, 0)
}

func (s *ShowStatsForQueryContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *ShowStatsForQueryContext) RootQuery() IRootQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRootQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRootQueryContext)
}

func (s *ShowStatsForQueryContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *ShowStatsForQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowStatsForQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetColumnTypeContext struct {
	StatementContext
	tableName  IQualifiedNameContext
	columnName IQualifiedNameContext
}

func NewSetColumnTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetColumnTypeContext {
	var p = new(SetColumnTypeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetColumnTypeContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *SetColumnTypeContext) GetColumnName() IQualifiedNameContext { return s.columnName }

func (s *SetColumnTypeContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *SetColumnTypeContext) SetColumnName(v IQualifiedNameContext) { s.columnName = v }

func (s *SetColumnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetColumnTypeContext) AllALTER_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserALTER_)
}

func (s *SetColumnTypeContext) ALTER_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, i)
}

func (s *SetColumnTypeContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *SetColumnTypeContext) COLUMN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMN_, 0)
}

func (s *SetColumnTypeContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetColumnTypeContext) DATA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDATA_, 0)
}

func (s *SetColumnTypeContext) TYPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTYPE_, 0)
}

func (s *SetColumnTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SetColumnTypeContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *SetColumnTypeContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetColumnTypeContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *SetColumnTypeContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *SetColumnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetColumnType(s)
	}
}

func (s *SetColumnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetColumnType(s)
	}
}

func (s *SetColumnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetColumnType(s)

	default:
		return t.VisitChildren(s)
	}
}

type StatementDefaultContext struct {
	StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) RootQuery() IRootQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRootQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRootQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

func (s *StatementDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStatementDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetTimeZoneContext struct {
	StatementContext
}

func NewSetTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTimeZoneContext {
	var p = new(SetTimeZoneContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTimeZoneContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetTimeZoneContext) TIME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIME_, 0)
}

func (s *SetTimeZoneContext) ZONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserZONE_, 0)
}

func (s *SetTimeZoneContext) LOCAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLOCAL_, 0)
}

func (s *SetTimeZoneContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetTimeZone(s)
	}
}

func (s *SetTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetTimeZone(s)
	}
}

func (s *SetTimeZoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetTimeZone(s)

	default:
		return t.VisitChildren(s)
	}
}

type TruncateTableContext struct {
	StatementContext
}

func NewTruncateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TruncateTableContext {
	var p = new(TruncateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) TRUNCATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRUNCATE_, 0)
}

func (s *TruncateTableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *TruncateTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (s *TruncateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTruncateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateMaterializedViewContext struct {
	StatementContext
}

func NewCreateMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMaterializedViewContext {
	var p = new(CreateMaterializedViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateMaterializedViewContext) MATERIALIZED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATERIALIZED_, 0)
}

func (s *CreateMaterializedViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *CreateMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateMaterializedViewContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *CreateMaterializedViewContext) RootQuery() IRootQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRootQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRootQueryContext)
}

func (s *CreateMaterializedViewContext) OR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOR_, 0)
}

func (s *CreateMaterializedViewContext) REPLACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPLACE_, 0)
}

func (s *CreateMaterializedViewContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *CreateMaterializedViewContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *CreateMaterializedViewContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *CreateMaterializedViewContext) GRACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRACE_, 0)
}

func (s *CreateMaterializedViewContext) PERIOD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPERIOD_, 0)
}

func (s *CreateMaterializedViewContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *CreateMaterializedViewContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CreateMaterializedViewContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateMaterializedViewContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *CreateMaterializedViewContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateMaterializedView(s)
	}
}

func (s *CreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateMaterializedView(s)
	}
}

func (s *CreateMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSessionContext struct {
	StatementContext
}

func NewSetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSessionContext {
	var p = new(SetSessionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSessionContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetSessionContext) SESSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSESSION_, 0)
}

func (s *SetSessionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetSessionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEQ_, 0)
}

func (s *SetSessionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetSession(s)
	}
}

func (s *SetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetSession(s)
	}
}

func (s *SetSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateViewContext struct {
	StatementContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *CreateViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *CreateViewContext) RootQuery() IRootQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRootQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRootQueryContext)
}

func (s *CreateViewContext) OR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOR_, 0)
}

func (s *CreateViewContext) REPLACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPLACE_, 0)
}

func (s *CreateViewContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CreateViewContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateViewContext) SECURITY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSECURITY_, 0)
}

func (s *CreateViewContext) DEFINER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFINER_, 0)
}

func (s *CreateViewContext) INVOKER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINVOKER_, 0)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameMaterializedViewContext struct {
	StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameMaterializedViewContext {
	var p = new(RenameMaterializedViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameMaterializedViewContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameMaterializedViewContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameMaterializedViewContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameMaterializedViewContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameMaterializedViewContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *RenameMaterializedViewContext) MATERIALIZED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATERIALIZED_, 0)
}

func (s *RenameMaterializedViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *RenameMaterializedViewContext) RENAME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRENAME_, 0)
}

func (s *RenameMaterializedViewContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *RenameMaterializedViewContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameMaterializedViewContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameMaterializedViewContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *RenameMaterializedViewContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *RenameMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRenameMaterializedView(s)
	}
}

func (s *RenameMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRenameMaterializedView(s)
	}
}

func (s *RenameMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRenameMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSchemasContext struct {
	StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowSchemasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemasContext {
	var p = new(ShowSchemasContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowSchemasContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowSchemasContext) GetEscape() IString_Context { return s.escape }

func (s *ShowSchemasContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowSchemasContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowSchemasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemasContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowSchemasContext) SCHEMAS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMAS_, 0)
}

func (s *ShowSchemasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSchemasContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *ShowSchemasContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *ShowSchemasContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *ShowSchemasContext) AllString_() []IString_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IString_Context); ok {
			len++
		}
	}

	tst := make([]IString_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IString_Context); ok {
			tst[i] = t.(IString_Context)
			i++
		}
	}

	return tst
}

func (s *ShowSchemasContext) String_(i int) IString_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowSchemasContext) ESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserESCAPE_, 0)
}

func (s *ShowSchemasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowSchemas(s)
	}
}

func (s *ShowSchemasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowSchemas(s)
	}
}

func (s *ShowSchemasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowSchemas(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropTableContext struct {
	StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDROP_, 0)
}

func (s *DropTableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *DropTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *DropTableContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSchemaAuthorizationContext struct {
	StatementContext
}

func NewSetSchemaAuthorizationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSchemaAuthorizationContext {
	var p = new(SetSchemaAuthorizationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetSchemaAuthorizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSchemaAuthorizationContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *SetSchemaAuthorizationContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *SetSchemaAuthorizationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetSchemaAuthorizationContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetSchemaAuthorizationContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *SetSchemaAuthorizationContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *SetSchemaAuthorizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetSchemaAuthorization(s)
	}
}

func (s *SetSchemaAuthorizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetSchemaAuthorization(s)
	}
}

func (s *SetSchemaAuthorizationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetSchemaAuthorization(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollbackContext struct {
	StatementContext
}

func NewRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollbackContext {
	var p = new(RollbackContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackContext) ROLLBACK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLLBACK_, 0)
}

func (s *RollbackContext) WORK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWORK_, 0)
}

func (s *RollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRollback(s)
	}
}

func (s *RollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRollback(s)
	}
}

func (s *RollbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRollback(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommentTableContext struct {
	StatementContext
}

func NewCommentTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentTableContext {
	var p = new(CommentTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommentTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentTableContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CommentTableContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *CommentTableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *CommentTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CommentTableContext) IS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIS_, 0)
}

func (s *CommentTableContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CommentTableContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *CommentTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCommentTable(s)
	}
}

func (s *CommentTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCommentTable(s)
	}
}

func (s *CommentTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCommentTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExecuteImmediateContext struct {
	StatementContext
}

func NewExecuteImmediateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExecuteImmediateContext {
	var p = new(ExecuteImmediateContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExecuteImmediateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteImmediateContext) EXECUTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXECUTE_, 0)
}

func (s *ExecuteImmediateContext) IMMEDIATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIMMEDIATE_, 0)
}

func (s *ExecuteImmediateContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ExecuteImmediateContext) USING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSING_, 0)
}

func (s *ExecuteImmediateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteImmediateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExecuteImmediateContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *ExecuteImmediateContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *ExecuteImmediateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExecuteImmediate(s)
	}
}

func (s *ExecuteImmediateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExecuteImmediate(s)
	}
}

func (s *ExecuteImmediateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExecuteImmediate(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameViewContext struct {
	StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameViewContext {
	var p = new(RenameViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameViewContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameViewContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameViewContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameViewContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameViewContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *RenameViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *RenameViewContext) RENAME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRENAME_, 0)
}

func (s *RenameViewContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *RenameViewContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameViewContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRenameView(s)
	}
}

func (s *RenameViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRenameView(s)
	}
}

func (s *RenameViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRenameView(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetPathContext struct {
	StatementContext
}

func NewSetPathContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPathContext {
	var p = new(SetPathContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPathContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetPathContext) PATH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPATH_, 0)
}

func (s *SetPathContext) PathSpecification() IPathSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathSpecificationContext)
}

func (s *SetPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetPath(s)
	}
}

func (s *SetPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetPath(s)
	}
}

func (s *SetPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetPath(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantRolesContext struct {
	StatementContext
	catalog IIdentifierContext
}

func NewGrantRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRolesContext {
	var p = new(GrantRolesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *GrantRolesContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *GrantRolesContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *GrantRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRolesContext) GRANT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANT_, 0)
}

func (s *GrantRolesContext) Roles() IRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *GrantRolesContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *GrantRolesContext) AllPrincipal() []IPrincipalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrincipalContext); ok {
			len++
		}
	}

	tst := make([]IPrincipalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrincipalContext); ok {
			tst[i] = t.(IPrincipalContext)
			i++
		}
	}

	return tst
}

func (s *GrantRolesContext) Principal(i int) IPrincipalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantRolesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *GrantRolesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *GrantRolesContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *GrantRolesContext) ADMIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserADMIN_, 0)
}

func (s *GrantRolesContext) OPTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOPTION_, 0)
}

func (s *GrantRolesContext) GRANTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANTED_, 0)
}

func (s *GrantRolesContext) BY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, 0)
}

func (s *GrantRolesContext) Grantor() IGrantorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *GrantRolesContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *GrantRolesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GrantRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterGrantRoles(s)
	}
}

func (s *GrantRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitGrantRoles(s)
	}
}

func (s *GrantRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitGrantRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

type CallContext struct {
	StatementContext
}

func NewCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallContext {
	var p = new(CallContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) CALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCALL_, 0)
}

func (s *CallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CallContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *CallContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *CallContext) AllCallArgument() []ICallArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICallArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallArgumentContext); ok {
			tst[i] = t.(ICallArgumentContext)
			i++
		}
	}

	return tst
}

func (s *CallContext) CallArgument(i int) ICallArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentContext)
}

func (s *CallContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *CallContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCall(s)
	}
}

func (s *CallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type RefreshMaterializedViewContext struct {
	StatementContext
}

func NewRefreshMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshMaterializedViewContext {
	var p = new(RefreshMaterializedViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RefreshMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMaterializedViewContext) REFRESH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREFRESH_, 0)
}

func (s *RefreshMaterializedViewContext) MATERIALIZED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATERIALIZED_, 0)
}

func (s *RefreshMaterializedViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *RefreshMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRefreshMaterializedView(s)
	}
}

func (s *RefreshMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRefreshMaterializedView(s)
	}
}

func (s *RefreshMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRefreshMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateMaterializedViewContext struct {
	StatementContext
}

func NewShowCreateMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMaterializedViewContext {
	var p = new(ShowCreateMaterializedViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMaterializedViewContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowCreateMaterializedViewContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *ShowCreateMaterializedViewContext) MATERIALIZED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATERIALIZED_, 0)
}

func (s *ShowCreateMaterializedViewContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *ShowCreateMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowCreateMaterializedView(s)
	}
}

func (s *ShowCreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowCreateMaterializedView(s)
	}
}

func (s *ShowCreateMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowCreateMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateCatalogContext struct {
	StatementContext
	catalog       IIdentifierContext
	connectorName IIdentifierContext
}

func NewCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateCatalogContext {
	var p = new(CreateCatalogContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateCatalogContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *CreateCatalogContext) GetConnectorName() IIdentifierContext { return s.connectorName }

func (s *CreateCatalogContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *CreateCatalogContext) SetConnectorName(v IIdentifierContext) { s.connectorName = v }

func (s *CreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCatalogContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *CreateCatalogContext) CATALOG_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCATALOG_, 0)
}

func (s *CreateCatalogContext) USING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSING_, 0)
}

func (s *CreateCatalogContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateCatalogContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateCatalogContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *CreateCatalogContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *CreateCatalogContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *CreateCatalogContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CreateCatalogContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateCatalogContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *CreateCatalogContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *CreateCatalogContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *CreateCatalogContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCreateCatalog(s)
	}
}

func (s *CreateCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCreateCatalog(s)
	}
}

func (s *CreateCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCreateCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowFunctionsContext struct {
	StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowFunctionsContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowFunctionsContext) GetEscape() IString_Context { return s.escape }

func (s *ShowFunctionsContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowFunctionsContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFUNCTIONS_, 0)
}

func (s *ShowFunctionsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowFunctionsContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *ShowFunctionsContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *ShowFunctionsContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *ShowFunctionsContext) AllString_() []IString_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IString_Context); ok {
			len++
		}
	}

	tst := make([]IString_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IString_Context); ok {
			tst[i] = t.(IString_Context)
			i++
		}
	}

	return tst
}

func (s *ShowFunctionsContext) String_(i int) IString_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowFunctionsContext) ESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserESCAPE_, 0)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitShowFunctions(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeOutputContext struct {
	StatementContext
}

func NewDescribeOutputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeOutputContext {
	var p = new(DescribeOutputContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeOutputContext) DESCRIBE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESCRIBE_, 0)
}

func (s *DescribeOutputContext) OUTPUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOUTPUT_, 0)
}

func (s *DescribeOutputContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDescribeOutput(s)
	}
}

func (s *DescribeOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDescribeOutput(s)
	}
}

func (s *DescribeOutputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDescribeOutput(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantContext struct {
	StatementContext
	grantee IPrincipalContext
}

func NewGrantContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantContext {
	var p = new(GrantContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *GrantContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *GrantContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) AllGRANT_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserGRANT_)
}

func (s *GrantContext) GRANT_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANT_, i)
}

func (s *GrantContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *GrantContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GrantContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *GrantContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *GrantContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *GrantContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *GrantContext) PRIVILEGES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRIVILEGES_, 0)
}

func (s *GrantContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *GrantContext) OPTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOPTION_, 0)
}

func (s *GrantContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *GrantContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *GrantContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *GrantContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (s *GrantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitGrant(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetTablePropertiesContext struct {
	StatementContext
	tableName IQualifiedNameContext
}

func NewSetTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTablePropertiesContext {
	var p = new(SetTablePropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetTablePropertiesContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *SetTablePropertiesContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *SetTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTablePropertiesContext) ALTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALTER_, 0)
}

func (s *SetTablePropertiesContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *SetTablePropertiesContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *SetTablePropertiesContext) PROPERTIES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPROPERTIES_, 0)
}

func (s *SetTablePropertiesContext) PropertyAssignments() IPropertyAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentsContext)
}

func (s *SetTablePropertiesContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetTablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetTableProperties(s)
	}
}

func (s *SetTablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetTableProperties(s)
	}
}

func (s *SetTablePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetTableProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, TrinoParserRULE_statement)
	var _la int

	p.SetState(1160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(289)
			p.RootQuery()
		}

	case 2:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(290)
			p.Match(TrinoParserUSE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(291)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 3:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(292)
			p.Match(TrinoParserUSE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(293)

			var _x = p.Identifier()

			localctx.(*UseContext).catalog = _x
		}
		{
			p.SetState(294)
			p.Match(TrinoParserDOT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(295)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 4:
		localctx = NewCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(297)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(298)
			p.Match(TrinoParserCATALOG_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(299)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(300)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(301)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(304)

			var _x = p.Identifier()

			localctx.(*CreateCatalogContext).catalog = _x
		}
		{
			p.SetState(305)
			p.Match(TrinoParserUSING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(306)

			var _x = p.Identifier()

			localctx.(*CreateCatalogContext).connectorName = _x
		}
		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCOMMENT_ {
			{
				p.SetState(307)
				p.Match(TrinoParserCOMMENT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(308)
				p.String_()
			}

		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserAUTHORIZATION_ {
			{
				p.SetState(311)
				p.Match(TrinoParserAUTHORIZATION_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(312)
				p.Principal()
			}

		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(315)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(316)
				p.Properties()
			}

		}

	case 5:
		localctx = NewDropCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(319)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(320)
			p.Match(TrinoParserCATALOG_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(321)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(322)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(325)

			var _x = p.Identifier()

			localctx.(*DropCatalogContext).catalog = _x
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCASCADE_ || _la == TrinoParserRESTRICT_ {
			{
				p.SetState(326)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserCASCADE_ || _la == TrinoParserRESTRICT_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 6:
		localctx = NewCreateSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(329)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(330)
			p.Match(TrinoParserSCHEMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(334)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(331)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(332)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(333)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(336)
			p.QualifiedName()
		}
		p.SetState(339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserAUTHORIZATION_ {
			{
				p.SetState(337)
				p.Match(TrinoParserAUTHORIZATION_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(338)
				p.Principal()
			}

		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(341)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(342)
				p.Properties()
			}

		}

	case 7:
		localctx = NewDropSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(345)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(346)
			p.Match(TrinoParserSCHEMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(349)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(347)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(348)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(351)
			p.QualifiedName()
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCASCADE_ || _la == TrinoParserRESTRICT_ {
			{
				p.SetState(352)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserCASCADE_ || _la == TrinoParserRESTRICT_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 8:
		localctx = NewRenameSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(355)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(356)
			p.Match(TrinoParserSCHEMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(357)
			p.QualifiedName()
		}
		{
			p.SetState(358)
			p.Match(TrinoParserRENAME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(359)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(360)
			p.Identifier()
		}

	case 9:
		localctx = NewSetSchemaAuthorizationContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(362)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(363)
			p.Match(TrinoParserSCHEMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(364)
			p.QualifiedName()
		}
		{
			p.SetState(365)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(366)
			p.Match(TrinoParserAUTHORIZATION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(367)
			p.Principal()
		}

	case 10:
		localctx = NewCreateTableAsSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(369)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserOR_ {
			{
				p.SetState(370)
				p.Match(TrinoParserOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(371)
				p.Match(TrinoParserREPLACE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(374)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(375)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(376)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(377)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(380)
			p.QualifiedName()
		}
		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLPAREN_ {
			{
				p.SetState(381)
				p.ColumnAliases()
			}

		}
		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCOMMENT_ {
			{
				p.SetState(384)
				p.Match(TrinoParserCOMMENT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(385)
				p.String_()
			}

		}
		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(388)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(389)
				p.Properties()
			}

		}
		{
			p.SetState(392)
			p.Match(TrinoParserAS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(393)
				p.RootQuery()
			}

		case 2:
			{
				p.SetState(394)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(395)
				p.RootQuery()
			}
			{
				p.SetState(396)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(400)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(402)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserNO_ {
				{
					p.SetState(401)
					p.Match(TrinoParserNO_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(404)
				p.Match(TrinoParserDATA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(407)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserOR_ {
			{
				p.SetState(408)
				p.Match(TrinoParserOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(409)
				p.Match(TrinoParserREPLACE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(412)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(413)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(414)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(415)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(418)
			p.QualifiedName()
		}
		{
			p.SetState(419)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(420)
			p.TableElement()
		}
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(421)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(422)
				p.TableElement()
			}

			p.SetState(427)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(428)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCOMMENT_ {
			{
				p.SetState(429)
				p.Match(TrinoParserCOMMENT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(430)
				p.String_()
			}

		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(433)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(434)
				p.Properties()
			}

		}

	case 12:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(437)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(439)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(440)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(443)
			p.QualifiedName()
		}

	case 13:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(444)
			p.Match(TrinoParserINSERT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(445)
			p.Match(TrinoParserINTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(446)
			p.QualifiedName()
		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(447)
				p.ColumnAliases()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(450)
			p.RootQuery()
		}

	case 14:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(452)
			p.Match(TrinoParserDELETE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(453)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(454)
			p.QualifiedName()
		}
		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWHERE_ {
			{
				p.SetState(455)
				p.Match(TrinoParserWHERE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(456)
				p.booleanExpression(0)
			}

		}

	case 15:
		localctx = NewTruncateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(459)
			p.Match(TrinoParserTRUNCATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(460)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(461)
			p.QualifiedName()
		}

	case 16:
		localctx = NewCommentTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(462)
			p.Match(TrinoParserCOMMENT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(464)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(465)
			p.QualifiedName()
		}
		{
			p.SetState(466)
			p.Match(TrinoParserIS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TrinoParserSTRING_, TrinoParserUNICODE_STRING_:
			{
				p.SetState(467)
				p.String_()
			}

		case TrinoParserNULL_:
			{
				p.SetState(468)
				p.Match(TrinoParserNULL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 17:
		localctx = NewCommentViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(471)
			p.Match(TrinoParserCOMMENT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(472)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(473)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(474)
			p.QualifiedName()
		}
		{
			p.SetState(475)
			p.Match(TrinoParserIS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TrinoParserSTRING_, TrinoParserUNICODE_STRING_:
			{
				p.SetState(476)
				p.String_()
			}

		case TrinoParserNULL_:
			{
				p.SetState(477)
				p.Match(TrinoParserNULL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 18:
		localctx = NewCommentColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(480)
			p.Match(TrinoParserCOMMENT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(481)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(482)
			p.Match(TrinoParserCOLUMN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)
			p.QualifiedName()
		}
		{
			p.SetState(484)
			p.Match(TrinoParserIS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TrinoParserSTRING_, TrinoParserUNICODE_STRING_:
			{
				p.SetState(485)
				p.String_()
			}

		case TrinoParserNULL_:
			{
				p.SetState(486)
				p.Match(TrinoParserNULL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 19:
		localctx = NewRenameTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(489)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(490)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(491)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(492)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(495)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).from = _x
		}
		{
			p.SetState(496)
			p.Match(TrinoParserRENAME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(498)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).to = _x
		}

	case 20:
		localctx = NewAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(500)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(504)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(502)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(503)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(506)

			var _x = p.QualifiedName()

			localctx.(*AddColumnContext).tableName = _x
		}
		{
			p.SetState(507)
			p.Match(TrinoParserADD_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(508)
			p.Match(TrinoParserCOLUMN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(509)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(510)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(511)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(514)

			var _x = p.ColumnDefinition()

			localctx.(*AddColumnContext).column = _x
		}

	case 21:
		localctx = NewRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(516)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(517)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(518)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(519)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(522)

			var _x = p.QualifiedName()

			localctx.(*RenameColumnContext).tableName = _x
		}
		{
			p.SetState(523)
			p.Match(TrinoParserRENAME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(524)
			p.Match(TrinoParserCOLUMN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(525)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(526)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(529)

			var _x = p.QualifiedName()

			localctx.(*RenameColumnContext).from = _x
		}
		{
			p.SetState(530)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(531)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).to = _x
		}

	case 22:
		localctx = NewDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(533)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(534)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(535)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(536)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(539)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).tableName = _x
		}
		{
			p.SetState(540)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(541)
			p.Match(TrinoParserCOLUMN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(542)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(543)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(546)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).column = _x
		}

	case 23:
		localctx = NewSetColumnTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(548)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(549)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(550)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(551)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(554)

			var _x = p.QualifiedName()

			localctx.(*SetColumnTypeContext).tableName = _x
		}
		{
			p.SetState(555)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(556)
			p.Match(TrinoParserCOLUMN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)

			var _x = p.QualifiedName()

			localctx.(*SetColumnTypeContext).columnName = _x
		}
		{
			p.SetState(558)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(559)
			p.Match(TrinoParserDATA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(560)
			p.Match(TrinoParserTYPE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(561)
			p.type_(0)
		}

	case 24:
		localctx = NewSetTableAuthorizationContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(563)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(565)

			var _x = p.QualifiedName()

			localctx.(*SetTableAuthorizationContext).tableName = _x
		}
		{
			p.SetState(566)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(567)
			p.Match(TrinoParserAUTHORIZATION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(568)
			p.Principal()
		}

	case 25:
		localctx = NewSetTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(570)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(571)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(572)

			var _x = p.QualifiedName()

			localctx.(*SetTablePropertiesContext).tableName = _x
		}
		{
			p.SetState(573)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(574)
			p.Match(TrinoParserPROPERTIES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(575)
			p.PropertyAssignments()
		}

	case 26:
		localctx = NewTableExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(577)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(578)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(579)

			var _x = p.QualifiedName()

			localctx.(*TableExecuteContext).tableName = _x
		}
		{
			p.SetState(580)
			p.Match(TrinoParserEXECUTE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(581)

			var _x = p.Identifier()

			localctx.(*TableExecuteContext).procedureName = _x
		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLPAREN_ {
			{
				p.SetState(582)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
				{
					p.SetState(583)
					p.CallArgument()
				}
				p.SetState(588)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == TrinoParserCOMMA_ {
					{
						p.SetState(584)
						p.Match(TrinoParserCOMMA_)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(585)
						p.CallArgument()
					}

					p.SetState(590)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}
			{
				p.SetState(593)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWHERE_ {
			{
				p.SetState(596)
				p.Match(TrinoParserWHERE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(597)

				var _x = p.booleanExpression(0)

				localctx.(*TableExecuteContext).where = _x
			}

		}

	case 27:
		localctx = NewAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(600)
			p.Match(TrinoParserANALYZE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(601)
			p.QualifiedName()
		}
		p.SetState(604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(602)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(603)
				p.Properties()
			}

		}

	case 28:
		localctx = NewCreateMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(606)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserOR_ {
			{
				p.SetState(607)
				p.Match(TrinoParserOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(608)
				p.Match(TrinoParserREPLACE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(611)
			p.Match(TrinoParserMATERIALIZED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(613)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(614)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(615)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(618)
			p.QualifiedName()
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserGRACE_ {
			{
				p.SetState(619)
				p.Match(TrinoParserGRACE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(620)
				p.Match(TrinoParserPERIOD_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(621)
				p.Interval()
			}

		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCOMMENT_ {
			{
				p.SetState(624)
				p.Match(TrinoParserCOMMENT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(625)
				p.String_()
			}

		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(628)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(629)
				p.Properties()
			}

		}
		{
			p.SetState(632)
			p.Match(TrinoParserAS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(633)
			p.RootQuery()
		}

	case 29:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(635)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserOR_ {
			{
				p.SetState(636)
				p.Match(TrinoParserOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(637)
				p.Match(TrinoParserREPLACE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(640)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(641)
			p.QualifiedName()
		}
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCOMMENT_ {
			{
				p.SetState(642)
				p.Match(TrinoParserCOMMENT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(643)
				p.String_()
			}

		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserSECURITY_ {
			{
				p.SetState(646)
				p.Match(TrinoParserSECURITY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(647)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserDEFINER_ || _la == TrinoParserINVOKER_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(650)
			p.Match(TrinoParserAS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(651)
			p.RootQuery()
		}

	case 30:
		localctx = NewRefreshMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(653)
			p.Match(TrinoParserREFRESH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(654)
			p.Match(TrinoParserMATERIALIZED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(655)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(656)
			p.QualifiedName()
		}

	case 31:
		localctx = NewDropMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(657)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(658)
			p.Match(TrinoParserMATERIALIZED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(660)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(661)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(664)
			p.QualifiedName()
		}

	case 32:
		localctx = NewRenameMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(665)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(666)
			p.Match(TrinoParserMATERIALIZED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(667)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(668)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(669)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(672)

			var _x = p.QualifiedName()

			localctx.(*RenameMaterializedViewContext).from = _x
		}
		{
			p.SetState(673)
			p.Match(TrinoParserRENAME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(675)

			var _x = p.QualifiedName()

			localctx.(*RenameMaterializedViewContext).to = _x
		}

	case 33:
		localctx = NewSetMaterializedViewPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(677)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(678)
			p.Match(TrinoParserMATERIALIZED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(679)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(680)
			p.QualifiedName()
		}
		{
			p.SetState(681)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Match(TrinoParserPROPERTIES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)
			p.PropertyAssignments()
		}

	case 34:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(685)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(686)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(687)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(688)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(691)
			p.QualifiedName()
		}

	case 35:
		localctx = NewRenameViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(692)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(693)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(694)

			var _x = p.QualifiedName()

			localctx.(*RenameViewContext).from = _x
		}
		{
			p.SetState(695)
			p.Match(TrinoParserRENAME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(696)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(697)

			var _x = p.QualifiedName()

			localctx.(*RenameViewContext).to = _x
		}

	case 36:
		localctx = NewSetViewAuthorizationContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(699)
			p.Match(TrinoParserALTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(700)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(701)

			var _x = p.QualifiedName()

			localctx.(*SetViewAuthorizationContext).from = _x
		}
		{
			p.SetState(702)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(703)
			p.Match(TrinoParserAUTHORIZATION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(704)
			p.Principal()
		}

	case 37:
		localctx = NewCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(706)
			p.Match(TrinoParserCALL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(707)
			p.QualifiedName()
		}
		{
			p.SetState(708)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
			{
				p.SetState(709)
				p.CallArgument()
			}
			p.SetState(714)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(710)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(711)
					p.CallArgument()
				}

				p.SetState(716)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(719)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		localctx = NewCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(721)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserOR_ {
			{
				p.SetState(722)
				p.Match(TrinoParserOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(723)
				p.Match(TrinoParserREPLACE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(726)
			p.FunctionSpecification()
		}

	case 39:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(727)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(728)
			p.Match(TrinoParserFUNCTION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(729)
				p.Match(TrinoParserIF_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(730)
				p.Match(TrinoParserEXISTS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(733)
			p.FunctionDeclaration()
		}

	case 40:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(734)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)
			p.Match(TrinoParserROLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(736)

			var _x = p.Identifier()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(737)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(738)
				p.Match(TrinoParserADMIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(739)
				p.Grantor()
			}

		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserIN_ {
			{
				p.SetState(742)
				p.Match(TrinoParserIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(743)

				var _x = p.Identifier()

				localctx.(*CreateRoleContext).catalog = _x
			}

		}

	case 41:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(746)
			p.Match(TrinoParserDROP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)
			p.Match(TrinoParserROLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(748)

			var _x = p.Identifier()

			localctx.(*DropRoleContext).name = _x
		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserIN_ {
			{
				p.SetState(749)
				p.Match(TrinoParserIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(750)

				var _x = p.Identifier()

				localctx.(*DropRoleContext).catalog = _x
			}

		}

	case 42:
		localctx = NewGrantRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(753)
			p.Match(TrinoParserGRANT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)
			p.Roles()
		}
		{
			p.SetState(755)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(756)
			p.Principal()
		}
		p.SetState(761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(757)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(758)
				p.Principal()
			}

			p.SetState(763)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(764)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(765)
				p.Match(TrinoParserADMIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(766)
				p.Match(TrinoParserOPTION_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserGRANTED_ {
			{
				p.SetState(769)
				p.Match(TrinoParserGRANTED_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(770)
				p.Match(TrinoParserBY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(771)
				p.Grantor()
			}

		}
		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserIN_ {
			{
				p.SetState(774)
				p.Match(TrinoParserIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(775)

				var _x = p.Identifier()

				localctx.(*GrantRolesContext).catalog = _x
			}

		}

	case 43:
		localctx = NewRevokeRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(778)
			p.Match(TrinoParserREVOKE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(782)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(779)
				p.Match(TrinoParserADMIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(780)
				p.Match(TrinoParserOPTION_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(781)
				p.Match(TrinoParserFOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(784)
			p.Roles()
		}
		{
			p.SetState(785)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(786)
			p.Principal()
		}
		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(787)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(788)
				p.Principal()
			}

			p.SetState(793)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserGRANTED_ {
			{
				p.SetState(794)
				p.Match(TrinoParserGRANTED_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(795)
				p.Match(TrinoParserBY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(796)
				p.Grantor()
			}

		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserIN_ {
			{
				p.SetState(799)
				p.Match(TrinoParserIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(800)

				var _x = p.Identifier()

				localctx.(*RevokeRolesContext).catalog = _x
			}

		}

	case 44:
		localctx = NewSetRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(803)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(804)
			p.Match(TrinoParserROLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(805)
				p.Match(TrinoParserALL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(806)
				p.Match(TrinoParserNONE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(807)

				var _x = p.Identifier()

				localctx.(*SetRoleContext).role = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserIN_ {
			{
				p.SetState(810)
				p.Match(TrinoParserIN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(811)

				var _x = p.Identifier()

				localctx.(*SetRoleContext).catalog = _x
			}

		}

	case 45:
		localctx = NewGrantContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(814)
			p.Match(TrinoParserGRANT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TrinoParserCREATE_, TrinoParserDELETE_, TrinoParserINSERT_, TrinoParserSELECT_, TrinoParserUPDATE_:
			{
				p.SetState(815)
				p.Privilege()
			}
			p.SetState(820)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(816)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(817)
					p.Privilege()
				}

				p.SetState(822)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case TrinoParserALL_:
			{
				p.SetState(823)
				p.Match(TrinoParserALL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(824)
				p.Match(TrinoParserPRIVILEGES_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(827)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(829)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(828)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserSCHEMA_ || _la == TrinoParserTABLE_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(831)
			p.QualifiedName()
		}
		{
			p.SetState(832)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(833)

			var _x = p.Principal()

			localctx.(*GrantContext).grantee = _x
		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ {
			{
				p.SetState(834)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(835)
				p.Match(TrinoParserGRANT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(836)
				p.Match(TrinoParserOPTION_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 46:
		localctx = NewDenyContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(839)
			p.Match(TrinoParserDENY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TrinoParserCREATE_, TrinoParserDELETE_, TrinoParserINSERT_, TrinoParserSELECT_, TrinoParserUPDATE_:
			{
				p.SetState(840)
				p.Privilege()
			}
			p.SetState(845)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(841)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(842)
					p.Privilege()
				}

				p.SetState(847)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case TrinoParserALL_:
			{
				p.SetState(848)
				p.Match(TrinoParserALL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(849)
				p.Match(TrinoParserPRIVILEGES_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(852)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(854)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(853)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserSCHEMA_ || _la == TrinoParserTABLE_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(856)
			p.QualifiedName()
		}
		{
			p.SetState(857)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(858)

			var _x = p.Principal()

			localctx.(*DenyContext).grantee = _x
		}

	case 47:
		localctx = NewRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(860)
			p.Match(TrinoParserREVOKE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserGRANT_ {
			{
				p.SetState(861)
				p.Match(TrinoParserGRANT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(862)
				p.Match(TrinoParserOPTION_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(863)
				p.Match(TrinoParserFOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TrinoParserCREATE_, TrinoParserDELETE_, TrinoParserINSERT_, TrinoParserSELECT_, TrinoParserUPDATE_:
			{
				p.SetState(866)
				p.Privilege()
			}
			p.SetState(871)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(867)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(868)
					p.Privilege()
				}

				p.SetState(873)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case TrinoParserALL_:
			{
				p.SetState(874)
				p.Match(TrinoParserALL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(875)
				p.Match(TrinoParserPRIVILEGES_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(878)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(879)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserSCHEMA_ || _la == TrinoParserTABLE_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(882)
			p.QualifiedName()
		}
		{
			p.SetState(883)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(884)

			var _x = p.Principal()

			localctx.(*RevokeContext).grantee = _x
		}

	case 48:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(886)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(887)
			p.Match(TrinoParserGRANTS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserON_ {
			{
				p.SetState(888)
				p.Match(TrinoParserON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(890)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserTABLE_ {
				{
					p.SetState(889)
					p.Match(TrinoParserTABLE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(892)
				p.QualifiedName()
			}

		}

	case 49:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(895)
			p.Match(TrinoParserEXPLAIN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(907)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(896)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(897)
				p.ExplainOption()
			}
			p.SetState(902)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(898)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(899)
					p.ExplainOption()
				}

				p.SetState(904)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(905)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(909)
			p.Statement()
		}

	case 50:
		localctx = NewExplainAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(910)
			p.Match(TrinoParserEXPLAIN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(911)
			p.Match(TrinoParserANALYZE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserVERBOSE_ {
			{
				p.SetState(912)
				p.Match(TrinoParserVERBOSE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(915)
			p.Statement()
		}

	case 51:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(916)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(917)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(918)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(919)
			p.QualifiedName()
		}

	case 52:
		localctx = NewShowCreateSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(920)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(921)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(922)
			p.Match(TrinoParserSCHEMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.QualifiedName()
		}

	case 53:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(924)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(925)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(926)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(927)
			p.QualifiedName()
		}

	case 54:
		localctx = NewShowCreateMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(928)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(929)
			p.Match(TrinoParserCREATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(930)
			p.Match(TrinoParserMATERIALIZED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(931)
			p.Match(TrinoParserVIEW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(932)
			p.QualifiedName()
		}

	case 55:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(933)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)
			p.Match(TrinoParserTABLES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserFROM_ || _la == TrinoParserIN_ {
			{
				p.SetState(935)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserFROM_ || _la == TrinoParserIN_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(936)
				p.QualifiedName()
			}

		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLIKE_ {
			{
				p.SetState(939)
				p.Match(TrinoParserLIKE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(940)

				var _x = p.String_()

				localctx.(*ShowTablesContext).pattern = _x
			}
			p.SetState(943)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserESCAPE_ {
				{
					p.SetState(941)
					p.Match(TrinoParserESCAPE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(942)

					var _x = p.String_()

					localctx.(*ShowTablesContext).escape = _x
				}

			}

		}

	case 56:
		localctx = NewShowSchemasContext(p, localctx)
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(947)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(948)
			p.Match(TrinoParserSCHEMAS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserFROM_ || _la == TrinoParserIN_ {
			{
				p.SetState(949)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserFROM_ || _la == TrinoParserIN_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(950)
				p.Identifier()
			}

		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLIKE_ {
			{
				p.SetState(953)
				p.Match(TrinoParserLIKE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(954)

				var _x = p.String_()

				localctx.(*ShowSchemasContext).pattern = _x
			}
			p.SetState(957)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserESCAPE_ {
				{
					p.SetState(955)
					p.Match(TrinoParserESCAPE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(956)

					var _x = p.String_()

					localctx.(*ShowSchemasContext).escape = _x
				}

			}

		}

	case 57:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(961)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(962)
			p.Match(TrinoParserCATALOGS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLIKE_ {
			{
				p.SetState(963)
				p.Match(TrinoParserLIKE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(964)

				var _x = p.String_()

				localctx.(*ShowCatalogsContext).pattern = _x
			}
			p.SetState(967)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserESCAPE_ {
				{
					p.SetState(965)
					p.Match(TrinoParserESCAPE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(966)

					var _x = p.String_()

					localctx.(*ShowCatalogsContext).escape = _x
				}

			}

		}

	case 58:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(971)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(972)
			p.Match(TrinoParserCOLUMNS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(973)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserFROM_ || _la == TrinoParserIN_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699602754) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
			{
				p.SetState(974)
				p.QualifiedName()
			}

		}
		p.SetState(983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLIKE_ {
			{
				p.SetState(977)
				p.Match(TrinoParserLIKE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(978)

				var _x = p.String_()

				localctx.(*ShowColumnsContext).pattern = _x
			}
			p.SetState(981)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserESCAPE_ {
				{
					p.SetState(979)
					p.Match(TrinoParserESCAPE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(980)

					var _x = p.String_()

					localctx.(*ShowColumnsContext).escape = _x
				}

			}

		}

	case 59:
		localctx = NewShowStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(985)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(986)
			p.Match(TrinoParserSTATS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(987)
			p.Match(TrinoParserFOR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.QualifiedName()
		}

	case 60:
		localctx = NewShowStatsForQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(989)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(990)
			p.Match(TrinoParserSTATS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(991)
			p.Match(TrinoParserFOR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(992)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(993)
			p.RootQuery()
		}
		{
			p.SetState(994)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 61:
		localctx = NewShowRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(996)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCURRENT_ {
			{
				p.SetState(997)
				p.Match(TrinoParserCURRENT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1000)
			p.Match(TrinoParserROLES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserFROM_ || _la == TrinoParserIN_ {
			{
				p.SetState(1001)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserFROM_ || _la == TrinoParserIN_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1002)
				p.Identifier()
			}

		}

	case 62:
		localctx = NewShowRoleGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(1005)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1006)
			p.Match(TrinoParserROLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1007)
			p.Match(TrinoParserGRANTS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserFROM_ || _la == TrinoParserIN_ {
			{
				p.SetState(1008)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserFROM_ || _la == TrinoParserIN_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1009)
				p.Identifier()
			}

		}

	case 63:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(1012)
			p.Match(TrinoParserDESCRIBE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1013)
			p.QualifiedName()
		}

	case 64:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(1014)
			p.Match(TrinoParserDESC_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1015)
			p.QualifiedName()
		}

	case 65:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(1016)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1017)
			p.Match(TrinoParserFUNCTIONS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserFROM_ || _la == TrinoParserIN_ {
			{
				p.SetState(1018)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserFROM_ || _la == TrinoParserIN_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1019)
				p.QualifiedName()
			}

		}
		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLIKE_ {
			{
				p.SetState(1022)
				p.Match(TrinoParserLIKE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1023)

				var _x = p.String_()

				localctx.(*ShowFunctionsContext).pattern = _x
			}
			p.SetState(1026)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserESCAPE_ {
				{
					p.SetState(1024)
					p.Match(TrinoParserESCAPE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1025)

					var _x = p.String_()

					localctx.(*ShowFunctionsContext).escape = _x
				}

			}

		}

	case 66:
		localctx = NewShowSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(1030)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1031)
			p.Match(TrinoParserSESSION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLIKE_ {
			{
				p.SetState(1032)
				p.Match(TrinoParserLIKE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1033)

				var _x = p.String_()

				localctx.(*ShowSessionContext).pattern = _x
			}
			p.SetState(1036)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserESCAPE_ {
				{
					p.SetState(1034)
					p.Match(TrinoParserESCAPE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1035)

					var _x = p.String_()

					localctx.(*ShowSessionContext).escape = _x
				}

			}

		}

	case 67:
		localctx = NewSetSessionAuthorizationContext(p, localctx)
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(1040)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.Match(TrinoParserSESSION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1042)
			p.Match(TrinoParserAUTHORIZATION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)
			p.AuthorizationUser()
		}

	case 68:
		localctx = NewResetSessionAuthorizationContext(p, localctx)
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(1044)
			p.Match(TrinoParserRESET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1045)
			p.Match(TrinoParserSESSION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1046)
			p.Match(TrinoParserAUTHORIZATION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 69:
		localctx = NewSetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(1047)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1048)
			p.Match(TrinoParserSESSION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1049)
			p.QualifiedName()
		}
		{
			p.SetState(1050)
			p.Match(TrinoParserEQ_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1051)
			p.Expression()
		}

	case 70:
		localctx = NewResetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(1053)
			p.Match(TrinoParserRESET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.Match(TrinoParserSESSION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1055)
			p.QualifiedName()
		}

	case 71:
		localctx = NewStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(1056)
			p.Match(TrinoParserSTART_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1057)
			p.Match(TrinoParserTRANSACTION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserISOLATION_ || _la == TrinoParserREAD_ {
			{
				p.SetState(1058)
				p.TransactionMode()
			}
			p.SetState(1063)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1059)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1060)
					p.TransactionMode()
				}

				p.SetState(1065)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 72:
		localctx = NewCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(1068)
			p.Match(TrinoParserCOMMIT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWORK_ {
			{
				p.SetState(1069)
				p.Match(TrinoParserWORK_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 73:
		localctx = NewRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(1072)
			p.Match(TrinoParserROLLBACK_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWORK_ {
			{
				p.SetState(1073)
				p.Match(TrinoParserWORK_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 74:
		localctx = NewPrepareContext(p, localctx)
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(1076)
			p.Match(TrinoParserPREPARE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1077)
			p.Identifier()
		}
		{
			p.SetState(1078)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.Statement()
		}

	case 75:
		localctx = NewDeallocateContext(p, localctx)
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(1081)
			p.Match(TrinoParserDEALLOCATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1082)
			p.Match(TrinoParserPREPARE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1083)
			p.Identifier()
		}

	case 76:
		localctx = NewExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(1084)
			p.Match(TrinoParserEXECUTE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1085)
			p.Identifier()
		}
		p.SetState(1095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserUSING_ {
			{
				p.SetState(1086)
				p.Match(TrinoParserUSING_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1087)
				p.Expression()
			}
			p.SetState(1092)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1088)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1089)
					p.Expression()
				}

				p.SetState(1094)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 77:
		localctx = NewExecuteImmediateContext(p, localctx)
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(1097)
			p.Match(TrinoParserEXECUTE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1098)
			p.Match(TrinoParserIMMEDIATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1099)
			p.String_()
		}
		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserUSING_ {
			{
				p.SetState(1100)
				p.Match(TrinoParserUSING_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1101)
				p.Expression()
			}
			p.SetState(1106)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1102)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1103)
					p.Expression()
				}

				p.SetState(1108)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 78:
		localctx = NewDescribeInputContext(p, localctx)
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(1111)
			p.Match(TrinoParserDESCRIBE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1112)
			p.Match(TrinoParserINPUT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1113)
			p.Identifier()
		}

	case 79:
		localctx = NewDescribeOutputContext(p, localctx)
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(1114)
			p.Match(TrinoParserDESCRIBE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1115)
			p.Match(TrinoParserOUTPUT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1116)
			p.Identifier()
		}

	case 80:
		localctx = NewSetPathContext(p, localctx)
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(1117)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1118)
			p.Match(TrinoParserPATH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1119)
			p.PathSpecification()
		}

	case 81:
		localctx = NewSetTimeZoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(1120)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1121)
			p.Match(TrinoParserTIME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)
			p.Match(TrinoParserZONE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1123)
				p.Match(TrinoParserLOCAL_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1124)
				p.Expression()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 82:
		localctx = NewUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(1127)
			p.Match(TrinoParserUPDATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1128)
			p.QualifiedName()
		}
		{
			p.SetState(1129)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1130)
			p.UpdateAssignment()
		}
		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1131)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1132)
				p.UpdateAssignment()
			}

			p.SetState(1137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWHERE_ {
			{
				p.SetState(1138)
				p.Match(TrinoParserWHERE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1139)

				var _x = p.booleanExpression(0)

				localctx.(*UpdateContext).where = _x
			}

		}

	case 83:
		localctx = NewMergeContext(p, localctx)
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(1142)
			p.Match(TrinoParserMERGE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1143)
			p.Match(TrinoParserINTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1144)
			p.QualifiedName()
		}
		p.SetState(1149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699600706) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
			p.SetState(1146)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserAS_ {
				{
					p.SetState(1145)
					p.Match(TrinoParserAS_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1148)
				p.Identifier()
			}

		}
		{
			p.SetState(1151)
			p.Match(TrinoParserUSING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1152)
			p.relation(0)
		}
		{
			p.SetState(1153)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1154)
			p.Expression()
		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TrinoParserWHEN_ {
			{
				p.SetState(1155)
				p.MergeCase()
			}

			p.SetState(1158)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRootQueryContext is an interface to support dynamic dispatch.
type IRootQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query() IQueryContext
	WithFunction() IWithFunctionContext

	// IsRootQueryContext differentiates from other interfaces.
	IsRootQueryContext()
}

type RootQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootQueryContext() *RootQueryContext {
	var p = new(RootQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rootQuery
	return p
}

func InitEmptyRootQueryContext(p *RootQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rootQuery
}

func (*RootQueryContext) IsRootQueryContext() {}

func NewRootQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootQueryContext {
	var p = new(RootQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_rootQuery

	return p
}

func (s *RootQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *RootQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *RootQueryContext) WithFunction() IWithFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithFunctionContext)
}

func (s *RootQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRootQuery(s)
	}
}

func (s *RootQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRootQuery(s)
	}
}

func (s *RootQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRootQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RootQuery() (localctx IRootQueryContext) {
	localctx = NewRootQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, TrinoParserRULE_rootQuery)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1162)
			p.WithFunction()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1165)
		p.Query()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithFunctionContext is an interface to support dynamic dispatch.
type IWithFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_() antlr.TerminalNode
	AllFunctionSpecification() []IFunctionSpecificationContext
	FunctionSpecification(i int) IFunctionSpecificationContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsWithFunctionContext differentiates from other interfaces.
	IsWithFunctionContext()
}

type WithFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithFunctionContext() *WithFunctionContext {
	var p = new(WithFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_withFunction
	return p
}

func InitEmptyWithFunctionContext(p *WithFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_withFunction
}

func (*WithFunctionContext) IsWithFunctionContext() {}

func NewWithFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithFunctionContext {
	var p = new(WithFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_withFunction

	return p
}

func (s *WithFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithFunctionContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *WithFunctionContext) AllFunctionSpecification() []IFunctionSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IFunctionSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionSpecificationContext); ok {
			tst[i] = t.(IFunctionSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *WithFunctionContext) FunctionSpecification(i int) IFunctionSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSpecificationContext)
}

func (s *WithFunctionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *WithFunctionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *WithFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterWithFunction(s)
	}
}

func (s *WithFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitWithFunction(s)
	}
}

func (s *WithFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitWithFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) WithFunction() (localctx IWithFunctionContext) {
	localctx = NewWithFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, TrinoParserRULE_withFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Match(TrinoParserWITH_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1168)
		p.FunctionSpecification()
	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(1169)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1170)
			p.FunctionSpecification()
		}

		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryNoWith() IQueryNoWithContext
	With() IWithContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryContext) With() IWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, TrinoParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserWITH_ {
		{
			p.SetState(1176)
			p.With()
		}

	}
	{
		p.SetState(1179)
		p.QueryNoWith()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_() antlr.TerminalNode
	AllNamedQuery() []INamedQueryContext
	NamedQuery(i int) INamedQueryContext
	RECURSIVE_() antlr.TerminalNode
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_with
	return p
}

func InitEmptyWithContext(p *WithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_with
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *WithContext) AllNamedQuery() []INamedQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedQueryContext); ok {
			len++
		}
	}

	tst := make([]INamedQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedQueryContext); ok {
			tst[i] = t.(INamedQueryContext)
			i++
		}
	}

	return tst
}

func (s *WithContext) NamedQuery(i int) INamedQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *WithContext) RECURSIVE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRECURSIVE_, 0)
}

func (s *WithContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *WithContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitWith(s)
	}
}

func (s *WithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, TrinoParserRULE_with)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1181)
		p.Match(TrinoParserWITH_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserRECURSIVE_ {
		{
			p.SetState(1182)
			p.Match(TrinoParserRECURSIVE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1185)
		p.NamedQuery()
	}
	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(1186)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1187)
			p.NamedQuery()
		}

		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnDefinition() IColumnDefinitionContext
	LikeClause() ILikeClauseContext

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableElement
	return p
}

func InitEmptyTableElementContext(p *TableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableElement
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) LikeClause() ILikeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (s *TableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, TrinoParserRULE_tableElement)
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserABSENT_, TrinoParserADD_, TrinoParserADMIN_, TrinoParserAFTER_, TrinoParserALL_, TrinoParserANALYZE_, TrinoParserANY_, TrinoParserARRAY_, TrinoParserASC_, TrinoParserAT_, TrinoParserAUTHORIZATION_, TrinoParserBEGIN_, TrinoParserBERNOULLI_, TrinoParserBOTH_, TrinoParserCALL_, TrinoParserCALLED_, TrinoParserCASCADE_, TrinoParserCATALOG_, TrinoParserCATALOGS_, TrinoParserCOLUMN_, TrinoParserCOLUMNS_, TrinoParserCOMMENT_, TrinoParserCOMMIT_, TrinoParserCOMMITTED_, TrinoParserCONDITIONAL_, TrinoParserCOUNT_, TrinoParserCOPARTITION_, TrinoParserCURRENT_, TrinoParserDATA_, TrinoParserDATE_, TrinoParserDAY_, TrinoParserDECLARE_, TrinoParserDEFAULT_, TrinoParserDEFINE_, TrinoParserDEFINER_, TrinoParserDENY_, TrinoParserDESC_, TrinoParserDESCRIPTOR_, TrinoParserDETERMINISTIC_, TrinoParserDISTRIBUTED_, TrinoParserDO_, TrinoParserDOUBLE_, TrinoParserEMPTY_, TrinoParserELSEIF_, TrinoParserENCODING_, TrinoParserERROR_, TrinoParserEXCLUDING_, TrinoParserEXPLAIN_, TrinoParserFETCH_, TrinoParserFILTER_, TrinoParserFINAL_, TrinoParserFIRST_, TrinoParserFOLLOWING_, TrinoParserFORMAT_, TrinoParserFUNCTION_, TrinoParserFUNCTIONS_, TrinoParserGRACE_, TrinoParserGRANT_, TrinoParserGRANTED_, TrinoParserGRANTS_, TrinoParserGRAPHVIZ_, TrinoParserGROUPS_, TrinoParserHOUR_, TrinoParserIF_, TrinoParserIGNORE_, TrinoParserIMMEDIATE_, TrinoParserINCLUDING_, TrinoParserINITIAL_, TrinoParserINPUT_, TrinoParserINTERVAL_, TrinoParserINVOKER_, TrinoParserIO_, TrinoParserISOLATION_, TrinoParserITERATE_, TrinoParserJSON_, TrinoParserKEEP_, TrinoParserKEY_, TrinoParserKEYS_, TrinoParserLANGUAGE_, TrinoParserLAST_, TrinoParserLATERAL_, TrinoParserLEADING_, TrinoParserLEAVE_, TrinoParserLEVEL_, TrinoParserLIMIT_, TrinoParserLOCAL_, TrinoParserLOGICAL_, TrinoParserLOOP_, TrinoParserMAP_, TrinoParserMATCH_, TrinoParserMATCHED_, TrinoParserMATCHES_, TrinoParserMATCH_RECOGNIZE_, TrinoParserMATERIALIZED_, TrinoParserMEASURES_, TrinoParserMERGE_, TrinoParserMINUTE_, TrinoParserMONTH_, TrinoParserNESTED_, TrinoParserNEXT_, TrinoParserNFC_, TrinoParserNFD_, TrinoParserNFKC_, TrinoParserNFKD_, TrinoParserNO_, TrinoParserNONE_, TrinoParserNULLIF_, TrinoParserNULLS_, TrinoParserOBJECT_, TrinoParserOF_, TrinoParserOFFSET_, TrinoParserOMIT_, TrinoParserONE_, TrinoParserONLY_, TrinoParserOPTION_, TrinoParserORDINALITY_, TrinoParserOUTPUT_, TrinoParserOVER_, TrinoParserOVERFLOW_, TrinoParserPARTITION_, TrinoParserPARTITIONS_, TrinoParserPASSING_, TrinoParserPAST_, TrinoParserPATH_, TrinoParserPATTERN_, TrinoParserPER_, TrinoParserPERIOD_, TrinoParserPERMUTE_, TrinoParserPLAN_, TrinoParserPOSITION_, TrinoParserPRECEDING_, TrinoParserPRECISION_, TrinoParserPRIVILEGES_, TrinoParserPROPERTIES_, TrinoParserPRUNE_, TrinoParserQUOTES_, TrinoParserRANGE_, TrinoParserREAD_, TrinoParserREFRESH_, TrinoParserRENAME_, TrinoParserREPEAT_, TrinoParserREPEATABLE_, TrinoParserREPLACE_, TrinoParserRESET_, TrinoParserRESPECT_, TrinoParserRESTRICT_, TrinoParserRETURN_, TrinoParserRETURNING_, TrinoParserRETURNS_, TrinoParserREVOKE_, TrinoParserROLE_, TrinoParserROLES_, TrinoParserROLLBACK_, TrinoParserROW_, TrinoParserROWS_, TrinoParserRUNNING_, TrinoParserSCALAR_, TrinoParserSCHEMA_, TrinoParserSCHEMAS_, TrinoParserSECOND_, TrinoParserSECURITY_, TrinoParserSEEK_, TrinoParserSERIALIZABLE_, TrinoParserSESSION_, TrinoParserSET_, TrinoParserSETS_, TrinoParserSHOW_, TrinoParserSOME_, TrinoParserSTART_, TrinoParserSTATS_, TrinoParserSUBSET_, TrinoParserSUBSTRING_, TrinoParserSYSTEM_, TrinoParserTABLES_, TrinoParserTABLESAMPLE_, TrinoParserTEXT_, TrinoParserTEXT_STRING_, TrinoParserTIES_, TrinoParserTIME_, TrinoParserTIMESTAMP_, TrinoParserTO_, TrinoParserTRAILING_, TrinoParserTRANSACTION_, TrinoParserTRUNCATE_, TrinoParserTRY_CAST_, TrinoParserTYPE_, TrinoParserUNBOUNDED_, TrinoParserUNCOMMITTED_, TrinoParserUNCONDITIONAL_, TrinoParserUNIQUE_, TrinoParserUNKNOWN_, TrinoParserUNMATCHED_, TrinoParserUNTIL_, TrinoParserUPDATE_, TrinoParserUSE_, TrinoParserUSER_, TrinoParserUTF16_, TrinoParserUTF32_, TrinoParserUTF8_, TrinoParserVALIDATE_, TrinoParserVALUE_, TrinoParserVERBOSE_, TrinoParserVERSION_, TrinoParserVIEW_, TrinoParserWHILE_, TrinoParserWINDOW_, TrinoParserWITHIN_, TrinoParserWITHOUT_, TrinoParserWORK_, TrinoParserWRAPPER_, TrinoParserWRITE_, TrinoParserYEAR_, TrinoParserZONE_, TrinoParserIDENTIFIER_, TrinoParserDIGIT_IDENTIFIER_, TrinoParserQUOTED_IDENTIFIER_, TrinoParserBACKQUOTED_IDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1193)
			p.ColumnDefinition()
		}

	case TrinoParserLIKE_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1194)
			p.LikeClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext
	NOT_() antlr.TerminalNode
	NULL_() antlr.TerminalNode
	COMMENT_() antlr.TerminalNode
	String_() IString_Context
	WITH_() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefinitionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ColumnDefinitionContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *ColumnDefinitionContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *ColumnDefinitionContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *ColumnDefinitionContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ColumnDefinitionContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *ColumnDefinitionContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, TrinoParserRULE_columnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1197)
		p.Identifier()
	}
	{
		p.SetState(1198)
		p.type_(0)
	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserNOT_ {
		{
			p.SetState(1199)
			p.Match(TrinoParserNOT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1200)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserCOMMENT_ {
		{
			p.SetState(1203)
			p.Match(TrinoParserCOMMENT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1204)
			p.String_()
		}

	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserWITH_ {
		{
			p.SetState(1207)
			p.Match(TrinoParserWITH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1208)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptionType returns the optionType token.
	GetOptionType() antlr.Token

	// SetOptionType sets the optionType token.
	SetOptionType(antlr.Token)

	// Getter signatures
	LIKE_() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PROPERTIES_() antlr.TerminalNode
	INCLUDING_() antlr.TerminalNode
	EXCLUDING_() antlr.TerminalNode

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	optionType antlr.Token
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_likeClause
	return p
}

func InitEmptyLikeClauseContext(p *LikeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_likeClause
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) GetOptionType() antlr.Token { return s.optionType }

func (s *LikeClauseContext) SetOptionType(v antlr.Token) { s.optionType = v }

func (s *LikeClauseContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *LikeClauseContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *LikeClauseContext) PROPERTIES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPROPERTIES_, 0)
}

func (s *LikeClauseContext) INCLUDING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINCLUDING_, 0)
}

func (s *LikeClauseContext) EXCLUDING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXCLUDING_, 0)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (s *LikeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLikeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, TrinoParserRULE_likeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1211)
		p.Match(TrinoParserLIKE_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1212)
		p.QualifiedName()
	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserEXCLUDING_ || _la == TrinoParserINCLUDING_ {
		{
			p.SetState(1213)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikeClauseContext).optionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserEXCLUDING_ || _la == TrinoParserINCLUDING_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikeClauseContext).optionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1214)
			p.Match(TrinoParserPROPERTIES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN_() antlr.TerminalNode
	PropertyAssignments() IPropertyAssignmentsContext
	RPAREN_() antlr.TerminalNode

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *PropertiesContext) PropertyAssignments() IPropertyAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentsContext)
}

func (s *PropertiesContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, TrinoParserRULE_properties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1218)
		p.PropertyAssignments()
	}
	{
		p.SetState(1219)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyAssignmentsContext is an interface to support dynamic dispatch.
type IPropertyAssignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsPropertyAssignmentsContext differentiates from other interfaces.
	IsPropertyAssignmentsContext()
}

type PropertyAssignmentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentsContext() *PropertyAssignmentsContext {
	var p = new(PropertyAssignmentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_propertyAssignments
	return p
}

func InitEmptyPropertyAssignmentsContext(p *PropertyAssignmentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_propertyAssignments
}

func (*PropertyAssignmentsContext) IsPropertyAssignmentsContext() {}

func NewPropertyAssignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentsContext {
	var p = new(PropertyAssignmentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_propertyAssignments

	return p
}

func (s *PropertyAssignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentsContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyAssignmentsContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyAssignmentsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *PropertyAssignmentsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *PropertyAssignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyAssignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPropertyAssignments(s)
	}
}

func (s *PropertyAssignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPropertyAssignments(s)
	}
}

func (s *PropertyAssignmentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPropertyAssignments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PropertyAssignments() (localctx IPropertyAssignmentsContext) {
	localctx = NewPropertyAssignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, TrinoParserRULE_propertyAssignments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1221)
		p.Property()
	}
	p.SetState(1226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(1222)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1223)
			p.Property()
		}

		p.SetState(1228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ_() antlr.TerminalNode
	PropertyValue() IPropertyValueContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyContext) EQ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEQ_, 0)
}

func (s *PropertyContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, TrinoParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Identifier()
	}
	{
		p.SetState(1230)
		p.Match(TrinoParserEQ_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1231)
		p.PropertyValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) CopyAll(ctx *PropertyValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DefaultPropertyValueContext struct {
	PropertyValueContext
}

func NewDefaultPropertyValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultPropertyValueContext {
	var p = new(DefaultPropertyValueContext)

	InitEmptyPropertyValueContext(&p.PropertyValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyValueContext))

	return p
}

func (s *DefaultPropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultPropertyValueContext) DEFAULT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFAULT_, 0)
}

func (s *DefaultPropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDefaultPropertyValue(s)
	}
}

func (s *DefaultPropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDefaultPropertyValue(s)
	}
}

func (s *DefaultPropertyValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDefaultPropertyValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type NonDefaultPropertyValueContext struct {
	PropertyValueContext
}

func NewNonDefaultPropertyValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonDefaultPropertyValueContext {
	var p = new(NonDefaultPropertyValueContext)

	InitEmptyPropertyValueContext(&p.PropertyValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyValueContext))

	return p
}

func (s *NonDefaultPropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonDefaultPropertyValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NonDefaultPropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNonDefaultPropertyValue(s)
	}
}

func (s *NonDefaultPropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNonDefaultPropertyValue(s)
	}
}

func (s *NonDefaultPropertyValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNonDefaultPropertyValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, TrinoParserRULE_propertyValue)
	p.SetState(1235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDefaultPropertyValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1233)
			p.Match(TrinoParserDEFAULT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewNonDefaultPropertyValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1234)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() IRowCountContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitRowCountContext

	// GetFetchFirst returns the fetchFirst rule contexts.
	GetFetchFirst() IRowCountContext

	// SetOffset sets the offset rule contexts.
	SetOffset(IRowCountContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitRowCountContext)

	// SetFetchFirst sets the fetchFirst rule contexts.
	SetFetchFirst(IRowCountContext)

	// Getter signatures
	QueryTerm() IQueryTermContext
	ORDER_() antlr.TerminalNode
	BY_() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	OFFSET_() antlr.TerminalNode
	LIMIT_() antlr.TerminalNode
	FETCH_() antlr.TerminalNode
	AllRowCount() []IRowCountContext
	RowCount(i int) IRowCountContext
	LimitRowCount() ILimitRowCountContext
	FIRST_() antlr.TerminalNode
	NEXT_() antlr.TerminalNode
	AllROW_() []antlr.TerminalNode
	ROW_(i int) antlr.TerminalNode
	AllROWS_() []antlr.TerminalNode
	ROWS_(i int) antlr.TerminalNode
	ONLY_() antlr.TerminalNode
	WITH_() antlr.TerminalNode
	TIES_() antlr.TerminalNode
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	offset     IRowCountContext
	limit      ILimitRowCountContext
	fetchFirst IRowCountContext
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryNoWith
	return p
}

func InitEmptyQueryNoWithContext(p *QueryNoWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryNoWith
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) GetOffset() IRowCountContext { return s.offset }

func (s *QueryNoWithContext) GetLimit() ILimitRowCountContext { return s.limit }

func (s *QueryNoWithContext) GetFetchFirst() IRowCountContext { return s.fetchFirst }

func (s *QueryNoWithContext) SetOffset(v IRowCountContext) { s.offset = v }

func (s *QueryNoWithContext) SetLimit(v ILimitRowCountContext) { s.limit = v }

func (s *QueryNoWithContext) SetFetchFirst(v IRowCountContext) { s.fetchFirst = v }

func (s *QueryNoWithContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryNoWithContext) ORDER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDER_, 0)
}

func (s *QueryNoWithContext) BY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) OFFSET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOFFSET_, 0)
}

func (s *QueryNoWithContext) LIMIT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIMIT_, 0)
}

func (s *QueryNoWithContext) FETCH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFETCH_, 0)
}

func (s *QueryNoWithContext) AllRowCount() []IRowCountContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowCountContext); ok {
			len++
		}
	}

	tst := make([]IRowCountContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowCountContext); ok {
			tst[i] = t.(IRowCountContext)
			i++
		}
	}

	return tst
}

func (s *QueryNoWithContext) RowCount(i int) IRowCountContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowCountContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowCountContext)
}

func (s *QueryNoWithContext) LimitRowCount() ILimitRowCountContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitRowCountContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitRowCountContext)
}

func (s *QueryNoWithContext) FIRST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFIRST_, 0)
}

func (s *QueryNoWithContext) NEXT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNEXT_, 0)
}

func (s *QueryNoWithContext) AllROW_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserROW_)
}

func (s *QueryNoWithContext) ROW_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserROW_, i)
}

func (s *QueryNoWithContext) AllROWS_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserROWS_)
}

func (s *QueryNoWithContext) ROWS_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserROWS_, i)
}

func (s *QueryNoWithContext) ONLY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserONLY_, 0)
}

func (s *QueryNoWithContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *QueryNoWithContext) TIES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIES_, 0)
}

func (s *QueryNoWithContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *QueryNoWithContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQueryNoWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, TrinoParserRULE_queryNoWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.queryTerm(0)
	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserORDER_ {
		{
			p.SetState(1238)
			p.Match(TrinoParserORDER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1239)
			p.Match(TrinoParserBY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1240)
			p.SortItem()
		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1241)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1242)
				p.SortItem()
			}

			p.SetState(1247)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserOFFSET_ {
		{
			p.SetState(1250)
			p.Match(TrinoParserOFFSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1251)

			var _x = p.RowCount()

			localctx.(*QueryNoWithContext).offset = _x
		}
		p.SetState(1253)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserROW_ || _la == TrinoParserROWS_ {
			{
				p.SetState(1252)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserROW_ || _la == TrinoParserROWS_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}
	p.SetState(1270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case TrinoParserLIMIT_:
		{
			p.SetState(1257)
			p.Match(TrinoParserLIMIT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1258)

			var _x = p.LimitRowCount()

			localctx.(*QueryNoWithContext).limit = _x
		}

	case TrinoParserFETCH_:
		{
			p.SetState(1259)
			p.Match(TrinoParserFETCH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1260)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserFIRST_ || _la == TrinoParserNEXT_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserQUESTION_MARK_ || _la == TrinoParserINTEGER_VALUE_ {
			{
				p.SetState(1261)

				var _x = p.RowCount()

				localctx.(*QueryNoWithContext).fetchFirst = _x
			}

		}
		{
			p.SetState(1264)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserROW_ || _la == TrinoParserROWS_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TrinoParserONLY_:
			{
				p.SetState(1265)
				p.Match(TrinoParserONLY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TrinoParserWITH_:
			{
				p.SetState(1266)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1267)
				p.Match(TrinoParserTIES_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case TrinoParserWITH_, TrinoParserSEMICOLON_, TrinoParserRPAREN_:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitRowCountContext is an interface to support dynamic dispatch.
type ILimitRowCountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_() antlr.TerminalNode
	RowCount() IRowCountContext

	// IsLimitRowCountContext differentiates from other interfaces.
	IsLimitRowCountContext()
}

type LimitRowCountContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitRowCountContext() *LimitRowCountContext {
	var p = new(LimitRowCountContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_limitRowCount
	return p
}

func InitEmptyLimitRowCountContext(p *LimitRowCountContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_limitRowCount
}

func (*LimitRowCountContext) IsLimitRowCountContext() {}

func NewLimitRowCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitRowCountContext {
	var p = new(LimitRowCountContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_limitRowCount

	return p
}

func (s *LimitRowCountContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitRowCountContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *LimitRowCountContext) RowCount() IRowCountContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowCountContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowCountContext)
}

func (s *LimitRowCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitRowCountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitRowCountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLimitRowCount(s)
	}
}

func (s *LimitRowCountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLimitRowCount(s)
	}
}

func (s *LimitRowCountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLimitRowCount(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) LimitRowCount() (localctx ILimitRowCountContext) {
	localctx = NewLimitRowCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, TrinoParserRULE_limitRowCount)
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserALL_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1272)
			p.Match(TrinoParserALL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserQUESTION_MARK_, TrinoParserINTEGER_VALUE_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1273)
			p.RowCount()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowCountContext is an interface to support dynamic dispatch.
type IRowCountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE_() antlr.TerminalNode
	QUESTION_MARK_() antlr.TerminalNode

	// IsRowCountContext differentiates from other interfaces.
	IsRowCountContext()
}

type RowCountContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowCountContext() *RowCountContext {
	var p = new(RowCountContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowCount
	return p
}

func InitEmptyRowCountContext(p *RowCountContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowCount
}

func (*RowCountContext) IsRowCountContext() {}

func NewRowCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowCountContext {
	var p = new(RowCountContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_rowCount

	return p
}

func (s *RowCountContext) GetParser() antlr.Parser { return s.parser }

func (s *RowCountContext) INTEGER_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTEGER_VALUE_, 0)
}

func (s *RowCountContext) QUESTION_MARK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUESTION_MARK_, 0)
}

func (s *RowCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowCountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowCountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRowCount(s)
	}
}

func (s *RowCountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRowCount(s)
	}
}

func (s *RowCountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRowCount(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RowCount() (localctx IRowCountContext) {
	localctx = NewRowCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, TrinoParserRULE_rowCount)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1276)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserQUESTION_MARK_ || _la == TrinoParserINTEGER_VALUE_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQueryTermDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTERSECT_, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNION_, 0)
}

func (s *SetOperationContext) EXCEPT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXCEPT_, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *TrinoParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, TrinoParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(1279)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1293)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_queryTerm)
				p.SetState(1281)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1282)

					var _m = p.Match(TrinoParserINTERSECT_)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1284)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TrinoParserALL_ || _la == TrinoParserDISTINCT_ {
					{
						p.SetState(1283)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(1286)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_queryTerm)
				p.SetState(1287)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1288)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TrinoParserEXCEPT_ || _la == TrinoParserUNION_) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(1290)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TrinoParserALL_ || _la == TrinoParserDISTINCT_ {
					{
						p.SetState(1289)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(1292)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *SubqueryContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *SubqueryContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableContext struct {
	QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *TableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (s *TableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type InlineTableContext struct {
	QueryPrimaryContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVALUES_, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *InlineTableContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, TrinoParserRULE_queryPrimary)
	var _alt int

	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserSELECT_:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1298)
			p.QuerySpecification()
		}

	case TrinoParserTABLE_:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1299)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1300)
			p.QualifiedName()
		}

	case TrinoParserVALUES_:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1301)
			p.Match(TrinoParserVALUES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1302)
			p.Expression()
		}
		p.SetState(1307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1303)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1304)
					p.Expression()
				}

			}
			p.SetState(1309)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case TrinoParserLPAREN_:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1310)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1311)
			p.QueryNoWith()
		}
		{
			p.SetState(1312)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS_() antlr.TerminalNode
	ASC_() antlr.TerminalNode
	DESC_() antlr.TerminalNode
	FIRST_() antlr.TerminalNode
	LAST_() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULLS_, 0)
}

func (s *SortItemContext) ASC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserASC_, 0)
}

func (s *SortItemContext) DESC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESC_, 0)
}

func (s *SortItemContext) FIRST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFIRST_, 0)
}

func (s *SortItemContext) LAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLAST_, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, TrinoParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.Expression()
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserASC_ || _la == TrinoParserDESC_ {
		{
			p.SetState(1317)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserASC_ || _la == TrinoParserDESC_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserNULLS_ {
		{
			p.SetState(1320)
			p.Match(TrinoParserNULLS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1321)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserFIRST_ || _la == TrinoParserLAST_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// Getter signatures
	SELECT_() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	SetQuantifier() ISetQuantifierContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode
	FROM_() antlr.TerminalNode
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	WHERE_() antlr.TerminalNode
	GROUP_() antlr.TerminalNode
	BY_() antlr.TerminalNode
	GroupBy() IGroupByContext
	HAVING_() antlr.TerminalNode
	WINDOW_() antlr.TerminalNode
	AllWindowDefinition() []IWindowDefinitionContext
	WindowDefinition(i int) IWindowDefinitionContext
	AllBooleanExpression() []IBooleanExpressionContext
	BooleanExpression(i int) IBooleanExpressionContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QuerySpecificationContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SELECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSELECT_, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *QuerySpecificationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *QuerySpecificationContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *QuerySpecificationContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QuerySpecificationContext) WHERE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHERE_, 0)
}

func (s *QuerySpecificationContext) GROUP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGROUP_, 0)
}

func (s *QuerySpecificationContext) BY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, 0)
}

func (s *QuerySpecificationContext) GroupBy() IGroupByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QuerySpecificationContext) HAVING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserHAVING_, 0)
}

func (s *QuerySpecificationContext) WINDOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWINDOW_, 0)
}

func (s *QuerySpecificationContext) AllWindowDefinition() []IWindowDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IWindowDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowDefinitionContext); ok {
			tst[i] = t.(IWindowDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) WindowDefinition(i int) IWindowDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowDefinitionContext)
}

func (s *QuerySpecificationContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, TrinoParserRULE_querySpecification)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1324)
		p.Match(TrinoParserSELECT_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1325)
			p.SetQuantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1328)
		p.SelectItem()
	}
	p.SetState(1333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1329)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1330)
				p.SelectItem()
			}

		}
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1345)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1336)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.relation(0)
		}
		p.SetState(1342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1338)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1339)
					p.relation(0)
				}

			}
			p.SetState(1344)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1349)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1347)
			p.Match(TrinoParserWHERE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1348)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1351)
			p.Match(TrinoParserGROUP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(TrinoParserBY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1353)
			p.GroupBy()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1358)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1356)
			p.Match(TrinoParserHAVING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1357)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1360)
			p.Match(TrinoParserWINDOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1361)
			p.WindowDefinition()
		}
		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1362)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1363)
					p.WindowDefinition()
				}

			}
			p.SetState(1368)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGroupingElement() []IGroupingElementContext
	GroupingElement(i int) IGroupingElementContext
	SetQuantifier() ISetQuantifierContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_groupBy
	return p
}

func InitEmptyGroupByContext(p *GroupByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_groupBy
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllGroupingElement() []IGroupingElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingElementContext); ok {
			len++
		}
	}

	tst := make([]IGroupingElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingElementContext); ok {
			tst[i] = t.(IGroupingElementContext)
			i++
		}
	}

	return tst
}

func (s *GroupByContext) GroupingElement(i int) IGroupingElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupByContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GroupByContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *GroupByContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (s *GroupByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitGroupBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, TrinoParserRULE_groupBy)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1372)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1371)
			p.SetQuantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1374)
		p.GroupingElement()
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1375)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1376)
				p.GroupingElement()
			}

		}
		p.SetState(1381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyAll(ctx *GroupingElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGROUPING_, 0)
}

func (s *MultipleGroupingSetsContext) SETS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSETS_, 0)
}

func (s *MultipleGroupingSetsContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *MultipleGroupingSetsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *MultipleGroupingSetsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitMultipleGroupingSets(s)

	default:
		return t.VisitChildren(s)
	}
}

type SingleGroupingSetContext struct {
	GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) GroupingSet() IGroupingSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSingleGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type CubeContext struct {
	GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCUBE_, 0)
}

func (s *CubeContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *CubeContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *CubeContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CubeContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CubeContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *CubeContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCube(s)
	}
}

func (s *CubeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCube(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollupContext struct {
	GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLLUP_, 0)
}

func (s *RollupContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *RollupContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *RollupContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RollupContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RollupContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *RollupContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (s *RollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, TrinoParserRULE_groupingElement)
	var _la int

	p.SetState(1422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1382)
			p.GroupingSet()
		}

	case 2:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1383)
			p.Match(TrinoParserROLLUP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1384)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
			{
				p.SetState(1385)
				p.Expression()
			}
			p.SetState(1390)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1386)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1387)
					p.Expression()
				}

				p.SetState(1392)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1395)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1396)
			p.Match(TrinoParserCUBE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1397)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
			{
				p.SetState(1398)
				p.Expression()
			}
			p.SetState(1403)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1399)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1400)
					p.Expression()
				}

				p.SetState(1405)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1408)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1409)
			p.Match(TrinoParserGROUPING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1410)
			p.Match(TrinoParserSETS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1411)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.GroupingSet()
		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1413)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1414)
				p.GroupingSet()
			}

			p.SetState(1419)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1420)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN_() antlr.TerminalNode
	RPAREN_() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *GroupingSetContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *GroupingSetContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (s *GroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, TrinoParserRULE_groupingSet)
	var _la int

	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1424)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
			{
				p.SetState(1425)
				p.Expression()
			}
			p.SetState(1430)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1426)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1427)
					p.Expression()
				}

				p.SetState(1432)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1435)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1436)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowDefinitionContext is an interface to support dynamic dispatch.
type IWindowDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	WindowSpecification() IWindowSpecificationContext
	RPAREN_() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWindowDefinitionContext differentiates from other interfaces.
	IsWindowDefinitionContext()
}

type WindowDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyWindowDefinitionContext() *WindowDefinitionContext {
	var p = new(WindowDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_windowDefinition
	return p
}

func InitEmptyWindowDefinitionContext(p *WindowDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_windowDefinition
}

func (*WindowDefinitionContext) IsWindowDefinitionContext() {}

func NewWindowDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowDefinitionContext {
	var p = new(WindowDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_windowDefinition

	return p
}

func (s *WindowDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *WindowDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *WindowDefinitionContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *WindowDefinitionContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *WindowDefinitionContext) WindowSpecification() IWindowSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecificationContext)
}

func (s *WindowDefinitionContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *WindowDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WindowDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterWindowDefinition(s)
	}
}

func (s *WindowDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitWindowDefinition(s)
	}
}

func (s *WindowDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitWindowDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) WindowDefinition() (localctx IWindowDefinitionContext) {
	localctx = NewWindowDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, TrinoParserRULE_windowDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1439)

		var _x = p.Identifier()

		localctx.(*WindowDefinitionContext).name = _x
	}
	{
		p.SetState(1440)
		p.Match(TrinoParserAS_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1441)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1442)
		p.WindowSpecification()
	}
	{
		p.SetState(1443)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecificationContext is an interface to support dynamic dispatch.
type IWindowSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExistingWindowName returns the existingWindowName rule contexts.
	GetExistingWindowName() IIdentifierContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetExistingWindowName sets the existingWindowName rule contexts.
	SetExistingWindowName(IIdentifierContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	PARTITION_() antlr.TerminalNode
	AllBY_() []antlr.TerminalNode
	BY_(i int) antlr.TerminalNode
	ORDER_() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	WindowFrame() IWindowFrameContext
	Identifier() IIdentifierContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsWindowSpecificationContext differentiates from other interfaces.
	IsWindowSpecificationContext()
}

type WindowSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	existingWindowName IIdentifierContext
	_expression        IExpressionContext
	partition          []IExpressionContext
}

func NewEmptyWindowSpecificationContext() *WindowSpecificationContext {
	var p = new(WindowSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_windowSpecification
	return p
}

func InitEmptyWindowSpecificationContext(p *WindowSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_windowSpecification
}

func (*WindowSpecificationContext) IsWindowSpecificationContext() {}

func NewWindowSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecificationContext {
	var p = new(WindowSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_windowSpecification

	return p
}

func (s *WindowSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecificationContext) GetExistingWindowName() IIdentifierContext {
	return s.existingWindowName
}

func (s *WindowSpecificationContext) Get_expression() IExpressionContext { return s._expression }

func (s *WindowSpecificationContext) SetExistingWindowName(v IIdentifierContext) {
	s.existingWindowName = v
}

func (s *WindowSpecificationContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *WindowSpecificationContext) GetPartition() []IExpressionContext { return s.partition }

func (s *WindowSpecificationContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *WindowSpecificationContext) PARTITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPARTITION_, 0)
}

func (s *WindowSpecificationContext) AllBY_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserBY_)
}

func (s *WindowSpecificationContext) BY_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, i)
}

func (s *WindowSpecificationContext) ORDER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDER_, 0)
}

func (s *WindowSpecificationContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *WindowSpecificationContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *WindowSpecificationContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowSpecificationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WindowSpecificationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WindowSpecificationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WindowSpecificationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *WindowSpecificationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *WindowSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterWindowSpecification(s)
	}
}

func (s *WindowSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitWindowSpecification(s)
	}
}

func (s *WindowSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitWindowSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) WindowSpecification() (localctx IWindowSpecificationContext) {
	localctx = NewWindowSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, TrinoParserRULE_windowSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1445)

			var _x = p.Identifier()

			localctx.(*WindowSpecificationContext).existingWindowName = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserPARTITION_ {
		{
			p.SetState(1448)
			p.Match(TrinoParserPARTITION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1449)
			p.Match(TrinoParserBY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1450)

			var _x = p.Expression()

			localctx.(*WindowSpecificationContext)._expression = _x
		}
		localctx.(*WindowSpecificationContext).partition = append(localctx.(*WindowSpecificationContext).partition, localctx.(*WindowSpecificationContext)._expression)
		p.SetState(1455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1451)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1452)

				var _x = p.Expression()

				localctx.(*WindowSpecificationContext)._expression = _x
			}
			localctx.(*WindowSpecificationContext).partition = append(localctx.(*WindowSpecificationContext).partition, localctx.(*WindowSpecificationContext)._expression)

			p.SetState(1457)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserORDER_ {
		{
			p.SetState(1460)
			p.Match(TrinoParserORDER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1461)
			p.Match(TrinoParserBY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1462)
			p.SortItem()
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1463)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1464)
				p.SortItem()
			}

			p.SetState(1469)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserGROUPS_ || _la == TrinoParserMEASURES_ || _la == TrinoParserRANGE_ || _la == TrinoParserROWS_ {
		{
			p.SetState(1472)
			p.WindowFrame()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	Query() IQueryContext
	RPAREN_() antlr.TerminalNode
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_namedQuery
	return p
}

func InitEmptyNamedQueryContext(p *NamedQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_namedQuery
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *NamedQueryContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (s *NamedQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNamedQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, TrinoParserRULE_namedQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserLPAREN_ {
		{
			p.SetState(1476)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(1479)
		p.Match(TrinoParserAS_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1480)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1481)
		p.Query()
	}
	{
		p.SetState(1482)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT_() antlr.TerminalNode
	ALL_() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDISTINCT_, 0)
}

func (s *SetQuantifierContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, TrinoParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1484)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserALL_ || _la == TrinoParserDISTINCT_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyAll(ctx *SelectItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SelectAllContext) DOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOT_, 0)
}

func (s *SelectAllContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserASTERISK_, 0)
}

func (s *SelectAllContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *SelectAllContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectSingleContext struct {
	SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (s *SelectSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSelectSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, TrinoParserRULE_selectItem)
	var _la int

	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1486)
			p.Expression()
		}
		p.SetState(1491)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			p.SetState(1488)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserAS_ {
				{
					p.SetState(1487)
					p.Match(TrinoParserAS_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1490)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1493)
			p.primaryExpression(0)
		}
		{
			p.SetState(1494)
			p.Match(TrinoParserDOT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1495)
			p.Match(TrinoParserASTERISK_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1496)
				p.Match(TrinoParserAS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1497)
				p.ColumnAliases()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1500)
			p.Match(TrinoParserASTERISK_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyAll(ctx *RelationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) SampledRelation() ISampledRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampledRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

func (s *RelationDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRelationDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinRelationContext struct {
	RelationContext
	left          IRelationContext
	right         ISampledRelationContext
	rightRelation IRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IRelationContext { return s.left }

func (s *JoinRelationContext) GetRight() ISampledRelationContext { return s.right }

func (s *JoinRelationContext) GetRightRelation() IRelationContext { return s.rightRelation }

func (s *JoinRelationContext) SetLeft(v IRelationContext) { s.left = v }

func (s *JoinRelationContext) SetRight(v ISampledRelationContext) { s.right = v }

func (s *JoinRelationContext) SetRightRelation(v IRelationContext) { s.rightRelation = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *JoinRelationContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinRelationContext) CROSS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCROSS_, 0)
}

func (s *JoinRelationContext) JOIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJOIN_, 0)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) NATURAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNATURAL_, 0)
}

func (s *JoinRelationContext) SampledRelation() ISampledRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampledRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Relation() (localctx IRelationContext) {
	return p.relation(0)
}

func (p *TrinoParser) relation(_p int) (localctx IRelationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRelationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 70
	p.EnterRecursionRule(localctx, 70, TrinoParserRULE_relation, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewRelationDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(1504)
		p.SampledRelation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinRelationContext(p, NewRelationContext(p, _parentctx, _parentState))
			localctx.(*JoinRelationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_relation)
			p.SetState(1506)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			p.SetState(1520)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case TrinoParserCROSS_:
				{
					p.SetState(1507)
					p.Match(TrinoParserCROSS_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1508)
					p.Match(TrinoParserJOIN_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1509)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			case TrinoParserFULL_, TrinoParserINNER_, TrinoParserJOIN_, TrinoParserLEFT_, TrinoParserRIGHT_:
				{
					p.SetState(1510)
					p.JoinType()
				}
				{
					p.SetState(1511)
					p.Match(TrinoParserJOIN_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1512)

					var _x = p.relation(0)

					localctx.(*JoinRelationContext).rightRelation = _x
				}
				{
					p.SetState(1513)
					p.JoinCriteria()
				}

			case TrinoParserNATURAL_:
				{
					p.SetState(1515)
					p.Match(TrinoParserNATURAL_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1516)
					p.JoinType()
				}
				{
					p.SetState(1517)
					p.Match(TrinoParserJOIN_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1518)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER_() antlr.TerminalNode
	LEFT_() antlr.TerminalNode
	RIGHT_() antlr.TerminalNode
	FULL_() antlr.TerminalNode
	OUTER_() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINNER_, 0)
}

func (s *JoinTypeContext) LEFT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLEFT_, 0)
}

func (s *JoinTypeContext) RIGHT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRIGHT_, 0)
}

func (s *JoinTypeContext) FULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFULL_, 0)
}

func (s *JoinTypeContext) OUTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOUTER_, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (s *JoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, TrinoParserRULE_joinType)
	var _la int

	p.SetState(1534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserINNER_, TrinoParserJOIN_:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserINNER_ {
			{
				p.SetState(1527)
				p.Match(TrinoParserINNER_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TrinoParserFULL_, TrinoParserLEFT_, TrinoParserRIGHT_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1530)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserFULL_ || _la == TrinoParserLEFT_ || _la == TrinoParserRIGHT_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserOUTER_ {
			{
				p.SetState(1531)
				p.Match(TrinoParserOUTER_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	USING_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN_() antlr.TerminalNode
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSING_, 0)
}

func (s *JoinCriteriaContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *JoinCriteriaContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *JoinCriteriaContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, TrinoParserRULE_joinCriteria)
	var _la int

	p.SetState(1550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserON_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1536)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)
			p.booleanExpression(0)
		}

	case TrinoParserUSING_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1538)
			p.Match(TrinoParserUSING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1539)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1540)
			p.Identifier()
		}
		p.SetState(1545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1541)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1542)
				p.Identifier()
			}

			p.SetState(1547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1548)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampledRelationContext is an interface to support dynamic dispatch.
type ISampledRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IExpressionContext)

	// Getter signatures
	PatternRecognition() IPatternRecognitionContext
	TABLESAMPLE_() antlr.TerminalNode
	SampleType() ISampleTypeContext
	LPAREN_() antlr.TerminalNode
	RPAREN_() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSampledRelationContext differentiates from other interfaces.
	IsSampledRelationContext()
}

type SampledRelationContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	percentage IExpressionContext
}

func NewEmptySampledRelationContext() *SampledRelationContext {
	var p = new(SampledRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sampledRelation
	return p
}

func InitEmptySampledRelationContext(p *SampledRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sampledRelation
}

func (*SampledRelationContext) IsSampledRelationContext() {}

func NewSampledRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampledRelationContext {
	var p = new(SampledRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_sampledRelation

	return p
}

func (s *SampledRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *SampledRelationContext) GetPercentage() IExpressionContext { return s.percentage }

func (s *SampledRelationContext) SetPercentage(v IExpressionContext) { s.percentage = v }

func (s *SampledRelationContext) PatternRecognition() IPatternRecognitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternRecognitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternRecognitionContext)
}

func (s *SampledRelationContext) TABLESAMPLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLESAMPLE_, 0)
}

func (s *SampledRelationContext) SampleType() ISampleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleTypeContext)
}

func (s *SampledRelationContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *SampledRelationContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *SampledRelationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampledRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampledRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampledRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSampledRelation(s)
	}
}

func (s *SampledRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSampledRelation(s)
	}
}

func (s *SampledRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSampledRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SampledRelation() (localctx ISampledRelationContext) {
	localctx = NewSampledRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, TrinoParserRULE_sampledRelation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.PatternRecognition()
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1553)
			p.Match(TrinoParserTABLESAMPLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1554)
			p.SampleType()
		}
		{
			p.SetState(1555)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1556)

			var _x = p.Expression()

			localctx.(*SampledRelationContext).percentage = _x
		}
		{
			p.SetState(1557)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleTypeContext is an interface to support dynamic dispatch.
type ISampleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BERNOULLI_() antlr.TerminalNode
	SYSTEM_() antlr.TerminalNode

	// IsSampleTypeContext differentiates from other interfaces.
	IsSampleTypeContext()
}

type SampleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleTypeContext() *SampleTypeContext {
	var p = new(SampleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sampleType
	return p
}

func InitEmptySampleTypeContext(p *SampleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sampleType
}

func (*SampleTypeContext) IsSampleTypeContext() {}

func NewSampleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleTypeContext {
	var p = new(SampleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_sampleType

	return p
}

func (s *SampleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleTypeContext) BERNOULLI_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBERNOULLI_, 0)
}

func (s *SampleTypeContext) SYSTEM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSYSTEM_, 0)
}

func (s *SampleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSampleType(s)
	}
}

func (s *SampleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSampleType(s)
	}
}

func (s *SampleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSampleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SampleType() (localctx ISampleTypeContext) {
	localctx = NewSampleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, TrinoParserRULE_sampleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserBERNOULLI_ || _la == TrinoParserSYSTEM_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimsSpecificationContext is an interface to support dynamic dispatch.
type ITrimsSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEADING_() antlr.TerminalNode
	TRAILING_() antlr.TerminalNode
	BOTH_() antlr.TerminalNode

	// IsTrimsSpecificationContext differentiates from other interfaces.
	IsTrimsSpecificationContext()
}

type TrimsSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimsSpecificationContext() *TrimsSpecificationContext {
	var p = new(TrimsSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_trimsSpecification
	return p
}

func InitEmptyTrimsSpecificationContext(p *TrimsSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_trimsSpecification
}

func (*TrimsSpecificationContext) IsTrimsSpecificationContext() {}

func NewTrimsSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimsSpecificationContext {
	var p = new(TrimsSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_trimsSpecification

	return p
}

func (s *TrimsSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimsSpecificationContext) LEADING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLEADING_, 0)
}

func (s *TrimsSpecificationContext) TRAILING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRAILING_, 0)
}

func (s *TrimsSpecificationContext) BOTH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBOTH_, 0)
}

func (s *TrimsSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimsSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimsSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTrimsSpecification(s)
	}
}

func (s *TrimsSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTrimsSpecification(s)
	}
}

func (s *TrimsSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTrimsSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TrimsSpecification() (localctx ITrimsSpecificationContext) {
	localctx = NewTrimsSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, TrinoParserRULE_trimsSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserBOTH_ || _la == TrinoParserLEADING_ || _la == TrinoParserTRAILING_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListAggOverflowBehaviorContext is an interface to support dynamic dispatch.
type IListAggOverflowBehaviorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR_() antlr.TerminalNode
	TRUNCATE_() antlr.TerminalNode
	ListaggCountIndication() IListaggCountIndicationContext
	String_() IString_Context

	// IsListAggOverflowBehaviorContext differentiates from other interfaces.
	IsListAggOverflowBehaviorContext()
}

type ListAggOverflowBehaviorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListAggOverflowBehaviorContext() *ListAggOverflowBehaviorContext {
	var p = new(ListAggOverflowBehaviorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_listAggOverflowBehavior
	return p
}

func InitEmptyListAggOverflowBehaviorContext(p *ListAggOverflowBehaviorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_listAggOverflowBehavior
}

func (*ListAggOverflowBehaviorContext) IsListAggOverflowBehaviorContext() {}

func NewListAggOverflowBehaviorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListAggOverflowBehaviorContext {
	var p = new(ListAggOverflowBehaviorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_listAggOverflowBehavior

	return p
}

func (s *ListAggOverflowBehaviorContext) GetParser() antlr.Parser { return s.parser }

func (s *ListAggOverflowBehaviorContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *ListAggOverflowBehaviorContext) TRUNCATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRUNCATE_, 0)
}

func (s *ListAggOverflowBehaviorContext) ListaggCountIndication() IListaggCountIndicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaggCountIndicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaggCountIndicationContext)
}

func (s *ListAggOverflowBehaviorContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ListAggOverflowBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListAggOverflowBehaviorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListAggOverflowBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterListAggOverflowBehavior(s)
	}
}

func (s *ListAggOverflowBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitListAggOverflowBehavior(s)
	}
}

func (s *ListAggOverflowBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitListAggOverflowBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ListAggOverflowBehavior() (localctx IListAggOverflowBehaviorContext) {
	localctx = NewListAggOverflowBehaviorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, TrinoParserRULE_listAggOverflowBehavior)
	var _la int

	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserERROR_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1565)
			p.Match(TrinoParserERROR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserTRUNCATE_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1566)
			p.Match(TrinoParserTRUNCATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserSTRING_ || _la == TrinoParserUNICODE_STRING_ {
			{
				p.SetState(1567)
				p.String_()
			}

		}
		{
			p.SetState(1570)
			p.ListaggCountIndication()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaggCountIndicationContext is an interface to support dynamic dispatch.
type IListaggCountIndicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COUNT_() antlr.TerminalNode
	WITH_() antlr.TerminalNode
	WITHOUT_() antlr.TerminalNode

	// IsListaggCountIndicationContext differentiates from other interfaces.
	IsListaggCountIndicationContext()
}

type ListaggCountIndicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListaggCountIndicationContext() *ListaggCountIndicationContext {
	var p = new(ListaggCountIndicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_listaggCountIndication
	return p
}

func InitEmptyListaggCountIndicationContext(p *ListaggCountIndicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_listaggCountIndication
}

func (*ListaggCountIndicationContext) IsListaggCountIndicationContext() {}

func NewListaggCountIndicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaggCountIndicationContext {
	var p = new(ListaggCountIndicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_listaggCountIndication

	return p
}

func (s *ListaggCountIndicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaggCountIndicationContext) COUNT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOUNT_, 0)
}

func (s *ListaggCountIndicationContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *ListaggCountIndicationContext) WITHOUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITHOUT_, 0)
}

func (s *ListaggCountIndicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaggCountIndicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaggCountIndicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterListaggCountIndication(s)
	}
}

func (s *ListaggCountIndicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitListaggCountIndication(s)
	}
}

func (s *ListaggCountIndicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitListaggCountIndication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ListaggCountIndication() (localctx IListaggCountIndicationContext) {
	localctx = NewListaggCountIndicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, TrinoParserRULE_listaggCountIndication)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1573)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserWITH_ || _la == TrinoParserWITHOUT_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1574)
		p.Match(TrinoParserCOUNT_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternRecognitionContext is an interface to support dynamic dispatch.
type IPatternRecognitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	AliasedRelation() IAliasedRelationContext
	MATCH_RECOGNIZE_() antlr.TerminalNode
	AllLPAREN_() []antlr.TerminalNode
	LPAREN_(i int) antlr.TerminalNode
	PATTERN_() antlr.TerminalNode
	RowPattern() IRowPatternContext
	AllRPAREN_() []antlr.TerminalNode
	RPAREN_(i int) antlr.TerminalNode
	DEFINE_() antlr.TerminalNode
	AllVariableDefinition() []IVariableDefinitionContext
	VariableDefinition(i int) IVariableDefinitionContext
	PARTITION_() antlr.TerminalNode
	AllBY_() []antlr.TerminalNode
	BY_(i int) antlr.TerminalNode
	ORDER_() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	MEASURES_() antlr.TerminalNode
	AllMeasureDefinition() []IMeasureDefinitionContext
	MeasureDefinition(i int) IMeasureDefinitionContext
	RowsPerMatch() IRowsPerMatchContext
	AFTER_() antlr.TerminalNode
	MATCH_() antlr.TerminalNode
	SkipTo() ISkipToContext
	SUBSET_() antlr.TerminalNode
	AllSubsetDefinition() []ISubsetDefinitionContext
	SubsetDefinition(i int) ISubsetDefinitionContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	INITIAL_() antlr.TerminalNode
	SEEK_() antlr.TerminalNode
	AS_() antlr.TerminalNode
	ColumnAliases() IColumnAliasesContext

	// IsPatternRecognitionContext differentiates from other interfaces.
	IsPatternRecognitionContext()
}

type PatternRecognitionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyPatternRecognitionContext() *PatternRecognitionContext {
	var p = new(PatternRecognitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_patternRecognition
	return p
}

func InitEmptyPatternRecognitionContext(p *PatternRecognitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_patternRecognition
}

func (*PatternRecognitionContext) IsPatternRecognitionContext() {}

func NewPatternRecognitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternRecognitionContext {
	var p = new(PatternRecognitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_patternRecognition

	return p
}

func (s *PatternRecognitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternRecognitionContext) Get_expression() IExpressionContext { return s._expression }

func (s *PatternRecognitionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *PatternRecognitionContext) GetPartition() []IExpressionContext { return s.partition }

func (s *PatternRecognitionContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *PatternRecognitionContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *PatternRecognitionContext) MATCH_RECOGNIZE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCH_RECOGNIZE_, 0)
}

func (s *PatternRecognitionContext) AllLPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserLPAREN_)
}

func (s *PatternRecognitionContext) LPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, i)
}

func (s *PatternRecognitionContext) PATTERN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPATTERN_, 0)
}

func (s *PatternRecognitionContext) RowPattern() IRowPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *PatternRecognitionContext) AllRPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserRPAREN_)
}

func (s *PatternRecognitionContext) RPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, i)
}

func (s *PatternRecognitionContext) DEFINE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFINE_, 0)
}

func (s *PatternRecognitionContext) AllVariableDefinition() []IVariableDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IVariableDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDefinitionContext); ok {
			tst[i] = t.(IVariableDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PatternRecognitionContext) VariableDefinition(i int) IVariableDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDefinitionContext)
}

func (s *PatternRecognitionContext) PARTITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPARTITION_, 0)
}

func (s *PatternRecognitionContext) AllBY_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserBY_)
}

func (s *PatternRecognitionContext) BY_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, i)
}

func (s *PatternRecognitionContext) ORDER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDER_, 0)
}

func (s *PatternRecognitionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *PatternRecognitionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *PatternRecognitionContext) MEASURES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMEASURES_, 0)
}

func (s *PatternRecognitionContext) AllMeasureDefinition() []IMeasureDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMeasureDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IMeasureDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMeasureDefinitionContext); ok {
			tst[i] = t.(IMeasureDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PatternRecognitionContext) MeasureDefinition(i int) IMeasureDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureDefinitionContext)
}

func (s *PatternRecognitionContext) RowsPerMatch() IRowsPerMatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowsPerMatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowsPerMatchContext)
}

func (s *PatternRecognitionContext) AFTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAFTER_, 0)
}

func (s *PatternRecognitionContext) MATCH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCH_, 0)
}

func (s *PatternRecognitionContext) SkipTo() ISkipToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipToContext)
}

func (s *PatternRecognitionContext) SUBSET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSUBSET_, 0)
}

func (s *PatternRecognitionContext) AllSubsetDefinition() []ISubsetDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubsetDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubsetDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubsetDefinitionContext); ok {
			tst[i] = t.(ISubsetDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PatternRecognitionContext) SubsetDefinition(i int) ISubsetDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsetDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsetDefinitionContext)
}

func (s *PatternRecognitionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *PatternRecognitionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *PatternRecognitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PatternRecognitionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PatternRecognitionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PatternRecognitionContext) INITIAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINITIAL_, 0)
}

func (s *PatternRecognitionContext) SEEK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEEK_, 0)
}

func (s *PatternRecognitionContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *PatternRecognitionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *PatternRecognitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternRecognitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternRecognitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPatternRecognition(s)
	}
}

func (s *PatternRecognitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPatternRecognition(s)
	}
}

func (s *PatternRecognitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPatternRecognition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PatternRecognition() (localctx IPatternRecognitionContext) {
	localctx = NewPatternRecognitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, TrinoParserRULE_patternRecognition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1576)
		p.AliasedRelation()
	}
	p.SetState(1659)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1577)
			p.Match(TrinoParserMATCH_RECOGNIZE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1578)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserPARTITION_ {
			{
				p.SetState(1579)
				p.Match(TrinoParserPARTITION_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1580)
				p.Match(TrinoParserBY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1581)

				var _x = p.Expression()

				localctx.(*PatternRecognitionContext)._expression = _x
			}
			localctx.(*PatternRecognitionContext).partition = append(localctx.(*PatternRecognitionContext).partition, localctx.(*PatternRecognitionContext)._expression)
			p.SetState(1586)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1582)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1583)

					var _x = p.Expression()

					localctx.(*PatternRecognitionContext)._expression = _x
				}
				localctx.(*PatternRecognitionContext).partition = append(localctx.(*PatternRecognitionContext).partition, localctx.(*PatternRecognitionContext)._expression)

				p.SetState(1588)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserORDER_ {
			{
				p.SetState(1591)
				p.Match(TrinoParserORDER_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1592)
				p.Match(TrinoParserBY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1593)
				p.SortItem()
			}
			p.SetState(1598)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1594)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1595)
					p.SortItem()
				}

				p.SetState(1600)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserMEASURES_ {
			{
				p.SetState(1603)
				p.Match(TrinoParserMEASURES_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1604)
				p.MeasureDefinition()
			}
			p.SetState(1609)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1605)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1606)
					p.MeasureDefinition()
				}

				p.SetState(1611)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserALL_ || _la == TrinoParserONE_ {
			{
				p.SetState(1614)
				p.RowsPerMatch()
			}

		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserAFTER_ {
			{
				p.SetState(1617)
				p.Match(TrinoParserAFTER_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1618)
				p.Match(TrinoParserMATCH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1619)
				p.SkipTo()
			}

		}
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserINITIAL_ || _la == TrinoParserSEEK_ {
			{
				p.SetState(1622)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserINITIAL_ || _la == TrinoParserSEEK_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1625)
			p.Match(TrinoParserPATTERN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1626)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1627)
			p.rowPattern(0)
		}
		{
			p.SetState(1628)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserSUBSET_ {
			{
				p.SetState(1629)
				p.Match(TrinoParserSUBSET_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1630)
				p.SubsetDefinition()
			}
			p.SetState(1635)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1631)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1632)
					p.SubsetDefinition()
				}

				p.SetState(1637)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1640)
			p.Match(TrinoParserDEFINE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.VariableDefinition()
		}
		p.SetState(1646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1642)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1643)
				p.VariableDefinition()
			}

			p.SetState(1648)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1649)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
			p.SetState(1651)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserAS_ {
				{
					p.SetState(1650)
					p.Match(TrinoParserAS_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1653)
				p.Identifier()
			}
			p.SetState(1655)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1654)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMeasureDefinitionContext is an interface to support dynamic dispatch.
type IMeasureDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AS_() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsMeasureDefinitionContext differentiates from other interfaces.
	IsMeasureDefinitionContext()
}

type MeasureDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeasureDefinitionContext() *MeasureDefinitionContext {
	var p = new(MeasureDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_measureDefinition
	return p
}

func InitEmptyMeasureDefinitionContext(p *MeasureDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_measureDefinition
}

func (*MeasureDefinitionContext) IsMeasureDefinitionContext() {}

func NewMeasureDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeasureDefinitionContext {
	var p = new(MeasureDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_measureDefinition

	return p
}

func (s *MeasureDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MeasureDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MeasureDefinitionContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *MeasureDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MeasureDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeasureDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeasureDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterMeasureDefinition(s)
	}
}

func (s *MeasureDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitMeasureDefinition(s)
	}
}

func (s *MeasureDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitMeasureDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) MeasureDefinition() (localctx IMeasureDefinitionContext) {
	localctx = NewMeasureDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, TrinoParserRULE_measureDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1661)
		p.Expression()
	}
	{
		p.SetState(1662)
		p.Match(TrinoParserAS_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1663)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowsPerMatchContext is an interface to support dynamic dispatch.
type IRowsPerMatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ONE_() antlr.TerminalNode
	ROW_() antlr.TerminalNode
	PER_() antlr.TerminalNode
	MATCH_() antlr.TerminalNode
	ALL_() antlr.TerminalNode
	ROWS_() antlr.TerminalNode
	EmptyMatchHandling() IEmptyMatchHandlingContext

	// IsRowsPerMatchContext differentiates from other interfaces.
	IsRowsPerMatchContext()
}

type RowsPerMatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowsPerMatchContext() *RowsPerMatchContext {
	var p = new(RowsPerMatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowsPerMatch
	return p
}

func InitEmptyRowsPerMatchContext(p *RowsPerMatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowsPerMatch
}

func (*RowsPerMatchContext) IsRowsPerMatchContext() {}

func NewRowsPerMatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowsPerMatchContext {
	var p = new(RowsPerMatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_rowsPerMatch

	return p
}

func (s *RowsPerMatchContext) GetParser() antlr.Parser { return s.parser }

func (s *RowsPerMatchContext) ONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserONE_, 0)
}

func (s *RowsPerMatchContext) ROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROW_, 0)
}

func (s *RowsPerMatchContext) PER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPER_, 0)
}

func (s *RowsPerMatchContext) MATCH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCH_, 0)
}

func (s *RowsPerMatchContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *RowsPerMatchContext) ROWS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROWS_, 0)
}

func (s *RowsPerMatchContext) EmptyMatchHandling() IEmptyMatchHandlingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyMatchHandlingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyMatchHandlingContext)
}

func (s *RowsPerMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowsPerMatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowsPerMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRowsPerMatch(s)
	}
}

func (s *RowsPerMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRowsPerMatch(s)
	}
}

func (s *RowsPerMatchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRowsPerMatch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RowsPerMatch() (localctx IRowsPerMatchContext) {
	localctx = NewRowsPerMatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, TrinoParserRULE_rowsPerMatch)
	var _la int

	p.SetState(1676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserONE_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1665)
			p.Match(TrinoParserONE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1666)
			p.Match(TrinoParserROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1667)
			p.Match(TrinoParserPER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1668)
			p.Match(TrinoParserMATCH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserALL_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1669)
			p.Match(TrinoParserALL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1670)
			p.Match(TrinoParserROWS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1671)
			p.Match(TrinoParserPER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1672)
			p.Match(TrinoParserMATCH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserOMIT_ || _la == TrinoParserSHOW_ || _la == TrinoParserWITH_ {
			{
				p.SetState(1673)
				p.EmptyMatchHandling()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyMatchHandlingContext is an interface to support dynamic dispatch.
type IEmptyMatchHandlingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW_() antlr.TerminalNode
	EMPTY_() antlr.TerminalNode
	MATCHES_() antlr.TerminalNode
	OMIT_() antlr.TerminalNode
	WITH_() antlr.TerminalNode
	UNMATCHED_() antlr.TerminalNode
	ROWS_() antlr.TerminalNode

	// IsEmptyMatchHandlingContext differentiates from other interfaces.
	IsEmptyMatchHandlingContext()
}

type EmptyMatchHandlingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyMatchHandlingContext() *EmptyMatchHandlingContext {
	var p = new(EmptyMatchHandlingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_emptyMatchHandling
	return p
}

func InitEmptyEmptyMatchHandlingContext(p *EmptyMatchHandlingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_emptyMatchHandling
}

func (*EmptyMatchHandlingContext) IsEmptyMatchHandlingContext() {}

func NewEmptyMatchHandlingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyMatchHandlingContext {
	var p = new(EmptyMatchHandlingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_emptyMatchHandling

	return p
}

func (s *EmptyMatchHandlingContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyMatchHandlingContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *EmptyMatchHandlingContext) EMPTY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEMPTY_, 0)
}

func (s *EmptyMatchHandlingContext) MATCHES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCHES_, 0)
}

func (s *EmptyMatchHandlingContext) OMIT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOMIT_, 0)
}

func (s *EmptyMatchHandlingContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *EmptyMatchHandlingContext) UNMATCHED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNMATCHED_, 0)
}

func (s *EmptyMatchHandlingContext) ROWS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROWS_, 0)
}

func (s *EmptyMatchHandlingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyMatchHandlingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyMatchHandlingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterEmptyMatchHandling(s)
	}
}

func (s *EmptyMatchHandlingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitEmptyMatchHandling(s)
	}
}

func (s *EmptyMatchHandlingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitEmptyMatchHandling(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) EmptyMatchHandling() (localctx IEmptyMatchHandlingContext) {
	localctx = NewEmptyMatchHandlingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, TrinoParserRULE_emptyMatchHandling)
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserSHOW_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1678)
			p.Match(TrinoParserSHOW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1679)
			p.Match(TrinoParserEMPTY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1680)
			p.Match(TrinoParserMATCHES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserOMIT_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1681)
			p.Match(TrinoParserOMIT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1682)
			p.Match(TrinoParserEMPTY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1683)
			p.Match(TrinoParserMATCHES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserWITH_:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1684)
			p.Match(TrinoParserWITH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1685)
			p.Match(TrinoParserUNMATCHED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1686)
			p.Match(TrinoParserROWS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipToContext is an interface to support dynamic dispatch.
type ISkipToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SKIP_() antlr.TerminalNode
	TO_() antlr.TerminalNode
	PAST_() antlr.TerminalNode
	LAST_() antlr.TerminalNode
	ROW_() antlr.TerminalNode
	NEXT_() antlr.TerminalNode
	Identifier() IIdentifierContext
	FIRST_() antlr.TerminalNode

	// IsSkipToContext differentiates from other interfaces.
	IsSkipToContext()
}

type SkipToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkipToContext() *SkipToContext {
	var p = new(SkipToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_skipTo
	return p
}

func InitEmptySkipToContext(p *SkipToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_skipTo
}

func (*SkipToContext) IsSkipToContext() {}

func NewSkipToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipToContext {
	var p = new(SkipToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_skipTo

	return p
}

func (s *SkipToContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipToContext) SKIP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSKIP_, 0)
}

func (s *SkipToContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *SkipToContext) PAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPAST_, 0)
}

func (s *SkipToContext) LAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLAST_, 0)
}

func (s *SkipToContext) ROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROW_, 0)
}

func (s *SkipToContext) NEXT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNEXT_, 0)
}

func (s *SkipToContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SkipToContext) FIRST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFIRST_, 0)
}

func (s *SkipToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSkipTo(s)
	}
}

func (s *SkipToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSkipTo(s)
	}
}

func (s *SkipToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSkipTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SkipTo() (localctx ISkipToContext) {
	localctx = NewSkipToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, TrinoParserRULE_skipTo)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		p.Match(TrinoParserSKIP_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserTO_:
		{
			p.SetState(1690)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1691)
				p.Match(TrinoParserNEXT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1692)
				p.Match(TrinoParserROW_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			p.SetState(1694)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1693)
					_la = p.GetTokenStream().LA(1)

					if !(_la == TrinoParserFIRST_ || _la == TrinoParserLAST_) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1696)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case TrinoParserPAST_:
		{
			p.SetState(1699)
			p.Match(TrinoParserPAST_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1700)
			p.Match(TrinoParserLAST_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1701)
			p.Match(TrinoParserROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubsetDefinitionContext is an interface to support dynamic dispatch.
type ISubsetDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetUnion returns the union rule context list.
	GetUnion() []IIdentifierContext

	// SetUnion sets the union rule context list.
	SetUnion([]IIdentifierContext)

	// Getter signatures
	EQ_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	RPAREN_() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsSubsetDefinitionContext differentiates from other interfaces.
	IsSubsetDefinitionContext()
}

type SubsetDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	name        IIdentifierContext
	_identifier IIdentifierContext
	union       []IIdentifierContext
}

func NewEmptySubsetDefinitionContext() *SubsetDefinitionContext {
	var p = new(SubsetDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_subsetDefinition
	return p
}

func InitEmptySubsetDefinitionContext(p *SubsetDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_subsetDefinition
}

func (*SubsetDefinitionContext) IsSubsetDefinitionContext() {}

func NewSubsetDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubsetDefinitionContext {
	var p = new(SubsetDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_subsetDefinition

	return p
}

func (s *SubsetDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubsetDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *SubsetDefinitionContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *SubsetDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *SubsetDefinitionContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *SubsetDefinitionContext) GetUnion() []IIdentifierContext { return s.union }

func (s *SubsetDefinitionContext) SetUnion(v []IIdentifierContext) { s.union = v }

func (s *SubsetDefinitionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEQ_, 0)
}

func (s *SubsetDefinitionContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *SubsetDefinitionContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *SubsetDefinitionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *SubsetDefinitionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubsetDefinitionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *SubsetDefinitionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *SubsetDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubsetDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubsetDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSubsetDefinition(s)
	}
}

func (s *SubsetDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSubsetDefinition(s)
	}
}

func (s *SubsetDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSubsetDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SubsetDefinition() (localctx ISubsetDefinitionContext) {
	localctx = NewSubsetDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, TrinoParserRULE_subsetDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1704)

		var _x = p.Identifier()

		localctx.(*SubsetDefinitionContext).name = _x
	}
	{
		p.SetState(1705)
		p.Match(TrinoParserEQ_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1706)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1707)

		var _x = p.Identifier()

		localctx.(*SubsetDefinitionContext)._identifier = _x
	}
	localctx.(*SubsetDefinitionContext).union = append(localctx.(*SubsetDefinitionContext).union, localctx.(*SubsetDefinitionContext)._identifier)
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(1708)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1709)

			var _x = p.Identifier()

			localctx.(*SubsetDefinitionContext)._identifier = _x
		}
		localctx.(*SubsetDefinitionContext).union = append(localctx.(*SubsetDefinitionContext).union, localctx.(*SubsetDefinitionContext)._identifier)

		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1715)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDefinitionContext is an interface to support dynamic dispatch.
type IVariableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDefinitionContext differentiates from other interfaces.
	IsVariableDefinitionContext()
}

type VariableDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDefinitionContext() *VariableDefinitionContext {
	var p = new(VariableDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_variableDefinition
	return p
}

func InitEmptyVariableDefinitionContext(p *VariableDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_variableDefinition
}

func (*VariableDefinitionContext) IsVariableDefinitionContext() {}

func NewVariableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDefinitionContext {
	var p = new(VariableDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_variableDefinition

	return p
}

func (s *VariableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDefinitionContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *VariableDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterVariableDefinition(s)
	}
}

func (s *VariableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitVariableDefinition(s)
	}
}

func (s *VariableDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitVariableDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) VariableDefinition() (localctx IVariableDefinitionContext) {
	localctx = NewVariableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, TrinoParserRULE_variableDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.Identifier()
	}
	{
		p.SetState(1718)
		p.Match(TrinoParserAS_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1719)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	Identifier() IIdentifierContext
	AS_() antlr.TerminalNode
	ColumnAliases() IColumnAliasesContext

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_aliasedRelation
	return p
}

func InitEmptyAliasedRelationContext(p *AliasedRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_aliasedRelation
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasedRelationContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *AliasedRelationContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitAliasedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, TrinoParserRULE_aliasedRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1721)
		p.RelationPrimary()
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
		p.SetState(1723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserAS_ {
			{
				p.SetState(1722)
				p.Match(TrinoParserAS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1725)
			p.Identifier()
		}
		p.SetState(1727)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1726)
				p.ColumnAliases()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN_() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN_() antlr.TerminalNode
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *ColumnAliasesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *ColumnAliasesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, TrinoParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1731)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1732)
		p.Identifier()
	}
	p.SetState(1737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(1733)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1734)
			p.Identifier()
		}

		p.SetState(1739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1740)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryRelationContext struct {
	RelationPrimaryContext
}

func NewSubqueryRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryRelationContext {
	var p = new(SubqueryRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryRelationContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *SubqueryRelationContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryRelationContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *SubqueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSubqueryRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedRelationContext struct {
	RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *ParenthesizedRelationContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ParenthesizedRelationContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitParenthesizedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnnestContext struct {
	RelationPrimaryContext
}

func NewUnnestContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestContext {
	var p = new(UnnestContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *UnnestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestContext) UNNEST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNNEST_, 0)
}

func (s *UnnestContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *UnnestContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *UnnestContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *UnnestContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *UnnestContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *UnnestContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *UnnestContext) ORDINALITY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDINALITY_, 0)
}

func (s *UnnestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUnnest(s)
	}
}

func (s *UnnestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUnnest(s)
	}
}

func (s *UnnestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUnnest(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableFunctionInvocationContext struct {
	RelationPrimaryContext
}

func NewTableFunctionInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFunctionInvocationContext {
	var p = new(TableFunctionInvocationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableFunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionInvocationContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *TableFunctionInvocationContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *TableFunctionInvocationContext) TableFunctionCall() ITableFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionCallContext)
}

func (s *TableFunctionInvocationContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *TableFunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableFunctionInvocation(s)
	}
}

func (s *TableFunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableFunctionInvocation(s)
	}
}

func (s *TableFunctionInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableFunctionInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

type LateralContext struct {
	RelationPrimaryContext
}

func NewLateralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LateralContext {
	var p = new(LateralContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *LateralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralContext) LATERAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLATERAL_, 0)
}

func (s *LateralContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *LateralContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *LateralContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *LateralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLateral(s)
	}
}

func (s *LateralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLateral(s)
	}
}

func (s *LateralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLateral(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) QueryPeriod() IQueryPeriodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPeriodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPeriodContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, TrinoParserRULE_relationPrimary)
	var _la int

	p.SetState(1779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1742)
			p.QualifiedName()
		}
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1743)
				p.QueryPeriod()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSubqueryRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1746)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1747)
			p.Query()
		}
		{
			p.SetState(1748)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewUnnestContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1750)
			p.Match(TrinoParserUNNEST_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1751)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1752)
			p.Expression()
		}
		p.SetState(1757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1753)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1754)
				p.Expression()
			}

			p.SetState(1759)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1760)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1763)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1761)
				p.Match(TrinoParserWITH_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1762)
				p.Match(TrinoParserORDINALITY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewLateralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1765)
			p.Match(TrinoParserLATERAL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1766)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1767)
			p.Query()
		}
		{
			p.SetState(1768)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewTableFunctionInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1770)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1771)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1772)
			p.TableFunctionCall()
		}
		{
			p.SetState(1773)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1775)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1776)
			p.relation(0)
		}
		{
			p.SetState(1777)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFunctionCallContext is an interface to support dynamic dispatch.
type ITableFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	LPAREN_() antlr.TerminalNode
	RPAREN_() antlr.TerminalNode
	AllTableFunctionArgument() []ITableFunctionArgumentContext
	TableFunctionArgument(i int) ITableFunctionArgumentContext
	COPARTITION_() antlr.TerminalNode
	AllCopartitionTables() []ICopartitionTablesContext
	CopartitionTables(i int) ICopartitionTablesContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsTableFunctionCallContext differentiates from other interfaces.
	IsTableFunctionCallContext()
}

type TableFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFunctionCallContext() *TableFunctionCallContext {
	var p = new(TableFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableFunctionCall
	return p
}

func InitEmptyTableFunctionCallContext(p *TableFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableFunctionCall
}

func (*TableFunctionCallContext) IsTableFunctionCallContext() {}

func NewTableFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFunctionCallContext {
	var p = new(TableFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_tableFunctionCall

	return p
}

func (s *TableFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableFunctionCallContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *TableFunctionCallContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *TableFunctionCallContext) AllTableFunctionArgument() []ITableFunctionArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableFunctionArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITableFunctionArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableFunctionArgumentContext); ok {
			tst[i] = t.(ITableFunctionArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TableFunctionCallContext) TableFunctionArgument(i int) ITableFunctionArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionArgumentContext)
}

func (s *TableFunctionCallContext) COPARTITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOPARTITION_, 0)
}

func (s *TableFunctionCallContext) AllCopartitionTables() []ICopartitionTablesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopartitionTablesContext); ok {
			len++
		}
	}

	tst := make([]ICopartitionTablesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopartitionTablesContext); ok {
			tst[i] = t.(ICopartitionTablesContext)
			i++
		}
	}

	return tst
}

func (s *TableFunctionCallContext) CopartitionTables(i int) ICopartitionTablesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopartitionTablesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopartitionTablesContext)
}

func (s *TableFunctionCallContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *TableFunctionCallContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *TableFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableFunctionCall(s)
	}
}

func (s *TableFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableFunctionCall(s)
	}
}

func (s *TableFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TableFunctionCall() (localctx ITableFunctionCallContext) {
	localctx = NewTableFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, TrinoParserRULE_tableFunctionCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1781)
		p.QualifiedName()
	}
	{
		p.SetState(1782)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1783)
			p.TableFunctionArgument()
		}
		p.SetState(1788)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1784)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1785)
				p.TableFunctionArgument()
			}

			p.SetState(1790)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserCOPARTITION_ {
		{
			p.SetState(1793)
			p.Match(TrinoParserCOPARTITION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1794)
			p.CopartitionTables()
		}
		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1795)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1796)
				p.CopartitionTables()
			}

			p.SetState(1801)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1804)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFunctionArgumentContext is an interface to support dynamic dispatch.
type ITableFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableArgument() ITableArgumentContext
	DescriptorArgument() IDescriptorArgumentContext
	Expression() IExpressionContext
	Identifier() IIdentifierContext
	RDOUBLEARROW_() antlr.TerminalNode

	// IsTableFunctionArgumentContext differentiates from other interfaces.
	IsTableFunctionArgumentContext()
}

type TableFunctionArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFunctionArgumentContext() *TableFunctionArgumentContext {
	var p = new(TableFunctionArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableFunctionArgument
	return p
}

func InitEmptyTableFunctionArgumentContext(p *TableFunctionArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableFunctionArgument
}

func (*TableFunctionArgumentContext) IsTableFunctionArgumentContext() {}

func NewTableFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFunctionArgumentContext {
	var p = new(TableFunctionArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_tableFunctionArgument

	return p
}

func (s *TableFunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFunctionArgumentContext) TableArgument() ITableArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableArgumentContext)
}

func (s *TableFunctionArgumentContext) DescriptorArgument() IDescriptorArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptorArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptorArgumentContext)
}

func (s *TableFunctionArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TableFunctionArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionArgumentContext) RDOUBLEARROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRDOUBLEARROW_, 0)
}

func (s *TableFunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableFunctionArgument(s)
	}
}

func (s *TableFunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableFunctionArgument(s)
	}
}

func (s *TableFunctionArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableFunctionArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TableFunctionArgument() (localctx ITableFunctionArgumentContext) {
	localctx = NewTableFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, TrinoParserRULE_tableFunctionArgument)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1806)
			p.Identifier()
		}
		{
			p.SetState(1807)
			p.Match(TrinoParserRDOUBLEARROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1811)
			p.TableArgument()
		}

	case 2:
		{
			p.SetState(1812)
			p.DescriptorArgument()
		}

	case 3:
		{
			p.SetState(1813)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableArgumentContext is an interface to support dynamic dispatch.
type ITableArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableArgumentRelation() ITableArgumentRelationContext
	PARTITION_() antlr.TerminalNode
	AllBY_() []antlr.TerminalNode
	BY_(i int) antlr.TerminalNode
	PRUNE_() antlr.TerminalNode
	WHEN_() antlr.TerminalNode
	EMPTY_() antlr.TerminalNode
	KEEP_() antlr.TerminalNode
	ORDER_() antlr.TerminalNode
	AllLPAREN_() []antlr.TerminalNode
	LPAREN_(i int) antlr.TerminalNode
	AllRPAREN_() []antlr.TerminalNode
	RPAREN_(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsTableArgumentContext differentiates from other interfaces.
	IsTableArgumentContext()
}

type TableArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgumentContext() *TableArgumentContext {
	var p = new(TableArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableArgument
	return p
}

func InitEmptyTableArgumentContext(p *TableArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableArgument
}

func (*TableArgumentContext) IsTableArgumentContext() {}

func NewTableArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgumentContext {
	var p = new(TableArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_tableArgument

	return p
}

func (s *TableArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgumentContext) TableArgumentRelation() ITableArgumentRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableArgumentRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableArgumentRelationContext)
}

func (s *TableArgumentContext) PARTITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPARTITION_, 0)
}

func (s *TableArgumentContext) AllBY_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserBY_)
}

func (s *TableArgumentContext) BY_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, i)
}

func (s *TableArgumentContext) PRUNE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRUNE_, 0)
}

func (s *TableArgumentContext) WHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHEN_, 0)
}

func (s *TableArgumentContext) EMPTY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEMPTY_, 0)
}

func (s *TableArgumentContext) KEEP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserKEEP_, 0)
}

func (s *TableArgumentContext) ORDER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDER_, 0)
}

func (s *TableArgumentContext) AllLPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserLPAREN_)
}

func (s *TableArgumentContext) LPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, i)
}

func (s *TableArgumentContext) AllRPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserRPAREN_)
}

func (s *TableArgumentContext) RPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, i)
}

func (s *TableArgumentContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TableArgumentContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TableArgumentContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *TableArgumentContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *TableArgumentContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *TableArgumentContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *TableArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableArgument(s)
	}
}

func (s *TableArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableArgument(s)
	}
}

func (s *TableArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TableArgument() (localctx ITableArgumentContext) {
	localctx = NewTableArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, TrinoParserRULE_tableArgument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.TableArgumentRelation()
	}
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserPARTITION_ {
		{
			p.SetState(1817)
			p.Match(TrinoParserPARTITION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1818)
			p.Match(TrinoParserBY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1819)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1828)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
				{
					p.SetState(1820)
					p.Expression()
				}
				p.SetState(1825)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == TrinoParserCOMMA_ {
					{
						p.SetState(1821)
						p.Match(TrinoParserCOMMA_)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1822)
						p.Expression()
					}

					p.SetState(1827)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}
			{
				p.SetState(1830)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1831)
				p.Expression()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case TrinoParserPRUNE_:
		{
			p.SetState(1836)
			p.Match(TrinoParserPRUNE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1837)
			p.Match(TrinoParserWHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1838)
			p.Match(TrinoParserEMPTY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserKEEP_:
		{
			p.SetState(1839)
			p.Match(TrinoParserKEEP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1840)
			p.Match(TrinoParserWHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1841)
			p.Match(TrinoParserEMPTY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserCOPARTITION_, TrinoParserORDER_, TrinoParserCOMMA_, TrinoParserRPAREN_:

	default:
	}
	p.SetState(1860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserORDER_ {
		{
			p.SetState(1844)
			p.Match(TrinoParserORDER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1845)
			p.Match(TrinoParserBY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1846)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1847)
				p.SortItem()
			}
			p.SetState(1852)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(1848)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1849)
					p.SortItem()
				}

				p.SetState(1854)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1855)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1857)
				p.SortItem()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableArgumentRelationContext is an interface to support dynamic dispatch.
type ITableArgumentRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableArgumentRelationContext differentiates from other interfaces.
	IsTableArgumentRelationContext()
}

type TableArgumentRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgumentRelationContext() *TableArgumentRelationContext {
	var p = new(TableArgumentRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableArgumentRelation
	return p
}

func InitEmptyTableArgumentRelationContext(p *TableArgumentRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_tableArgumentRelation
}

func (*TableArgumentRelationContext) IsTableArgumentRelationContext() {}

func NewTableArgumentRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgumentRelationContext {
	var p = new(TableArgumentRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_tableArgumentRelation

	return p
}

func (s *TableArgumentRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgumentRelationContext) CopyAll(ctx *TableArgumentRelationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableArgumentRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgumentRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableArgumentQueryContext struct {
	TableArgumentRelationContext
}

func NewTableArgumentQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableArgumentQueryContext {
	var p = new(TableArgumentQueryContext)

	InitEmptyTableArgumentRelationContext(&p.TableArgumentRelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableArgumentRelationContext))

	return p
}

func (s *TableArgumentQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgumentQueryContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *TableArgumentQueryContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *TableArgumentQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *TableArgumentQueryContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *TableArgumentQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableArgumentQueryContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *TableArgumentQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *TableArgumentQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableArgumentQuery(s)
	}
}

func (s *TableArgumentQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableArgumentQuery(s)
	}
}

func (s *TableArgumentQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableArgumentQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableArgumentTableContext struct {
	TableArgumentRelationContext
}

func NewTableArgumentTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableArgumentTableContext {
	var p = new(TableArgumentTableContext)

	InitEmptyTableArgumentRelationContext(&p.TableArgumentRelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableArgumentRelationContext))

	return p
}

func (s *TableArgumentTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgumentTableContext) TABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLE_, 0)
}

func (s *TableArgumentTableContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *TableArgumentTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableArgumentTableContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *TableArgumentTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableArgumentTableContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *TableArgumentTableContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *TableArgumentTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTableArgumentTable(s)
	}
}

func (s *TableArgumentTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTableArgumentTable(s)
	}
}

func (s *TableArgumentTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTableArgumentTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TableArgumentRelation() (localctx ITableArgumentRelationContext) {
	localctx = NewTableArgumentRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, TrinoParserRULE_tableArgumentRelation)
	var _la int

	p.SetState(1888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableArgumentTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1862)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1863)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1864)
			p.QualifiedName()
		}
		{
			p.SetState(1865)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1873)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
			p.SetState(1867)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserAS_ {
				{
					p.SetState(1866)
					p.Match(TrinoParserAS_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1869)
				p.Identifier()
			}
			p.SetState(1871)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserLPAREN_ {
				{
					p.SetState(1870)
					p.ColumnAliases()
				}

			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewTableArgumentQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1875)
			p.Match(TrinoParserTABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1876)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1877)
			p.Query()
		}
		{
			p.SetState(1878)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1886)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
			p.SetState(1880)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserAS_ {
				{
					p.SetState(1879)
					p.Match(TrinoParserAS_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1882)
				p.Identifier()
			}
			p.SetState(1884)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserLPAREN_ {
				{
					p.SetState(1883)
					p.ColumnAliases()
				}

			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescriptorArgumentContext is an interface to support dynamic dispatch.
type IDescriptorArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DESCRIPTOR_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	AllDescriptorField() []IDescriptorFieldContext
	DescriptorField(i int) IDescriptorFieldContext
	RPAREN_() antlr.TerminalNode
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode
	CAST_() antlr.TerminalNode
	NULL_() antlr.TerminalNode
	AS_() antlr.TerminalNode

	// IsDescriptorArgumentContext differentiates from other interfaces.
	IsDescriptorArgumentContext()
}

type DescriptorArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptorArgumentContext() *DescriptorArgumentContext {
	var p = new(DescriptorArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_descriptorArgument
	return p
}

func InitEmptyDescriptorArgumentContext(p *DescriptorArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_descriptorArgument
}

func (*DescriptorArgumentContext) IsDescriptorArgumentContext() {}

func NewDescriptorArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptorArgumentContext {
	var p = new(DescriptorArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_descriptorArgument

	return p
}

func (s *DescriptorArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptorArgumentContext) DESCRIPTOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESCRIPTOR_, 0)
}

func (s *DescriptorArgumentContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *DescriptorArgumentContext) AllDescriptorField() []IDescriptorFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDescriptorFieldContext); ok {
			len++
		}
	}

	tst := make([]IDescriptorFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDescriptorFieldContext); ok {
			tst[i] = t.(IDescriptorFieldContext)
			i++
		}
	}

	return tst
}

func (s *DescriptorArgumentContext) DescriptorField(i int) IDescriptorFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptorFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptorFieldContext)
}

func (s *DescriptorArgumentContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *DescriptorArgumentContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *DescriptorArgumentContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *DescriptorArgumentContext) CAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCAST_, 0)
}

func (s *DescriptorArgumentContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *DescriptorArgumentContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *DescriptorArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptorArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptorArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDescriptorArgument(s)
	}
}

func (s *DescriptorArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDescriptorArgument(s)
	}
}

func (s *DescriptorArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDescriptorArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) DescriptorArgument() (localctx IDescriptorArgumentContext) {
	localctx = NewDescriptorArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, TrinoParserRULE_descriptorArgument)
	var _la int

	p.SetState(1908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserDESCRIPTOR_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1890)
			p.Match(TrinoParserDESCRIPTOR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1891)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1892)
			p.DescriptorField()
		}
		p.SetState(1897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1893)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1894)
				p.DescriptorField()
			}

			p.SetState(1899)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1900)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserCAST_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1902)
			p.Match(TrinoParserCAST_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1903)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1904)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1905)
			p.Match(TrinoParserAS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1906)
			p.Match(TrinoParserDESCRIPTOR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1907)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescriptorFieldContext is an interface to support dynamic dispatch.
type IDescriptorFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext

	// IsDescriptorFieldContext differentiates from other interfaces.
	IsDescriptorFieldContext()
}

type DescriptorFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptorFieldContext() *DescriptorFieldContext {
	var p = new(DescriptorFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_descriptorField
	return p
}

func InitEmptyDescriptorFieldContext(p *DescriptorFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_descriptorField
}

func (*DescriptorFieldContext) IsDescriptorFieldContext() {}

func NewDescriptorFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptorFieldContext {
	var p = new(DescriptorFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_descriptorField

	return p
}

func (s *DescriptorFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptorFieldContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescriptorFieldContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *DescriptorFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptorFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptorFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDescriptorField(s)
	}
}

func (s *DescriptorFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDescriptorField(s)
	}
}

func (s *DescriptorFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDescriptorField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) DescriptorField() (localctx IDescriptorFieldContext) {
	localctx = NewDescriptorFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, TrinoParserRULE_descriptorField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1910)
		p.Identifier()
	}
	p.SetState(1912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699602754) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
		{
			p.SetState(1911)
			p.type_(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopartitionTablesContext is an interface to support dynamic dispatch.
type ICopartitionTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN_() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode
	RPAREN_() antlr.TerminalNode

	// IsCopartitionTablesContext differentiates from other interfaces.
	IsCopartitionTablesContext()
}

type CopartitionTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopartitionTablesContext() *CopartitionTablesContext {
	var p = new(CopartitionTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_copartitionTables
	return p
}

func InitEmptyCopartitionTablesContext(p *CopartitionTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_copartitionTables
}

func (*CopartitionTablesContext) IsCopartitionTablesContext() {}

func NewCopartitionTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopartitionTablesContext {
	var p = new(CopartitionTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_copartitionTables

	return p
}

func (s *CopartitionTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *CopartitionTablesContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *CopartitionTablesContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CopartitionTablesContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CopartitionTablesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *CopartitionTablesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *CopartitionTablesContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *CopartitionTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopartitionTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopartitionTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCopartitionTables(s)
	}
}

func (s *CopartitionTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCopartitionTables(s)
	}
}

func (s *CopartitionTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCopartitionTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) CopartitionTables() (localctx ICopartitionTablesContext) {
	localctx = NewCopartitionTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, TrinoParserRULE_copartitionTables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1914)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1915)
		p.QualifiedName()
	}
	{
		p.SetState(1916)
		p.Match(TrinoParserCOMMA_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1917)
		p.QualifiedName()
	}
	p.SetState(1922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(1918)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1919)
			p.QualifiedName()
		}

		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1925)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, TrinoParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1927)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate_() IPredicate_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicate_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicate_Context)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (s *PredicatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPredicated(s)

	default:
		return t.VisitChildren(s)
	}
}

type OrContext struct {
	BooleanExpressionContext
}

func NewOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrContext {
	var p = new(OrContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *OrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *OrContext) OR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOR_, 0)
}

func (s *OrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterOr(s)
	}
}

func (s *OrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitOr(s)
	}
}

func (s *OrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type AndContext struct {
	BooleanExpressionContext
}

func NewAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndContext {
	var p = new(AndContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *AndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *AndContext) AND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAND_, 0)
}

func (s *AndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterAnd(s)
	}
}

func (s *AndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitAnd(s)
	}
}

func (s *AndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *TrinoParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, TrinoParserRULE_booleanExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserABSENT_, TrinoParserADD_, TrinoParserADMIN_, TrinoParserAFTER_, TrinoParserALL_, TrinoParserANALYZE_, TrinoParserANY_, TrinoParserARRAY_, TrinoParserASC_, TrinoParserAT_, TrinoParserAUTHORIZATION_, TrinoParserBEGIN_, TrinoParserBERNOULLI_, TrinoParserBOTH_, TrinoParserCALL_, TrinoParserCALLED_, TrinoParserCASCADE_, TrinoParserCASE_, TrinoParserCAST_, TrinoParserCATALOG_, TrinoParserCATALOGS_, TrinoParserCOLUMN_, TrinoParserCOLUMNS_, TrinoParserCOMMENT_, TrinoParserCOMMIT_, TrinoParserCOMMITTED_, TrinoParserCONDITIONAL_, TrinoParserCOUNT_, TrinoParserCOPARTITION_, TrinoParserCURRENT_, TrinoParserCURRENT_CATALOG_, TrinoParserCURRENT_DATE_, TrinoParserCURRENT_PATH_, TrinoParserCURRENT_SCHEMA_, TrinoParserCURRENT_TIME_, TrinoParserCURRENT_TIMESTAMP_, TrinoParserCURRENT_USER_, TrinoParserDATA_, TrinoParserDATE_, TrinoParserDAY_, TrinoParserDECLARE_, TrinoParserDEFAULT_, TrinoParserDEFINE_, TrinoParserDEFINER_, TrinoParserDENY_, TrinoParserDESC_, TrinoParserDESCRIPTOR_, TrinoParserDETERMINISTIC_, TrinoParserDISTRIBUTED_, TrinoParserDO_, TrinoParserDOUBLE_, TrinoParserEMPTY_, TrinoParserELSEIF_, TrinoParserENCODING_, TrinoParserERROR_, TrinoParserEXCLUDING_, TrinoParserEXISTS_, TrinoParserEXPLAIN_, TrinoParserEXTRACT_, TrinoParserFALSE_, TrinoParserFETCH_, TrinoParserFILTER_, TrinoParserFINAL_, TrinoParserFIRST_, TrinoParserFOLLOWING_, TrinoParserFORMAT_, TrinoParserFUNCTION_, TrinoParserFUNCTIONS_, TrinoParserGRACE_, TrinoParserGRANT_, TrinoParserGRANTED_, TrinoParserGRANTS_, TrinoParserGRAPHVIZ_, TrinoParserGROUPING_, TrinoParserGROUPS_, TrinoParserHOUR_, TrinoParserIF_, TrinoParserIGNORE_, TrinoParserIMMEDIATE_, TrinoParserINCLUDING_, TrinoParserINITIAL_, TrinoParserINPUT_, TrinoParserINTERVAL_, TrinoParserINVOKER_, TrinoParserIO_, TrinoParserISOLATION_, TrinoParserITERATE_, TrinoParserJSON_, TrinoParserJSON_ARRAY_, TrinoParserJSON_EXISTS_, TrinoParserJSON_OBJECT_, TrinoParserJSON_QUERY_, TrinoParserJSON_VALUE_, TrinoParserKEEP_, TrinoParserKEY_, TrinoParserKEYS_, TrinoParserLANGUAGE_, TrinoParserLAST_, TrinoParserLATERAL_, TrinoParserLEADING_, TrinoParserLEAVE_, TrinoParserLEVEL_, TrinoParserLIMIT_, TrinoParserLISTAGG_, TrinoParserLOCAL_, TrinoParserLOCALTIME_, TrinoParserLOCALTIMESTAMP_, TrinoParserLOGICAL_, TrinoParserLOOP_, TrinoParserMAP_, TrinoParserMATCH_, TrinoParserMATCHED_, TrinoParserMATCHES_, TrinoParserMATCH_RECOGNIZE_, TrinoParserMATERIALIZED_, TrinoParserMEASURES_, TrinoParserMERGE_, TrinoParserMINUTE_, TrinoParserMONTH_, TrinoParserNESTED_, TrinoParserNEXT_, TrinoParserNFC_, TrinoParserNFD_, TrinoParserNFKC_, TrinoParserNFKD_, TrinoParserNO_, TrinoParserNONE_, TrinoParserNORMALIZE_, TrinoParserNULL_, TrinoParserNULLIF_, TrinoParserNULLS_, TrinoParserOBJECT_, TrinoParserOF_, TrinoParserOFFSET_, TrinoParserOMIT_, TrinoParserONE_, TrinoParserONLY_, TrinoParserOPTION_, TrinoParserORDINALITY_, TrinoParserOUTPUT_, TrinoParserOVER_, TrinoParserOVERFLOW_, TrinoParserPARTITION_, TrinoParserPARTITIONS_, TrinoParserPASSING_, TrinoParserPAST_, TrinoParserPATH_, TrinoParserPATTERN_, TrinoParserPER_, TrinoParserPERIOD_, TrinoParserPERMUTE_, TrinoParserPLAN_, TrinoParserPOSITION_, TrinoParserPRECEDING_, TrinoParserPRECISION_, TrinoParserPRIVILEGES_, TrinoParserPROPERTIES_, TrinoParserPRUNE_, TrinoParserQUOTES_, TrinoParserRANGE_, TrinoParserREAD_, TrinoParserREFRESH_, TrinoParserRENAME_, TrinoParserREPEAT_, TrinoParserREPEATABLE_, TrinoParserREPLACE_, TrinoParserRESET_, TrinoParserRESPECT_, TrinoParserRESTRICT_, TrinoParserRETURN_, TrinoParserRETURNING_, TrinoParserRETURNS_, TrinoParserREVOKE_, TrinoParserROLE_, TrinoParserROLES_, TrinoParserROLLBACK_, TrinoParserROW_, TrinoParserROWS_, TrinoParserRUNNING_, TrinoParserSCALAR_, TrinoParserSCHEMA_, TrinoParserSCHEMAS_, TrinoParserSECOND_, TrinoParserSECURITY_, TrinoParserSEEK_, TrinoParserSERIALIZABLE_, TrinoParserSESSION_, TrinoParserSET_, TrinoParserSETS_, TrinoParserSHOW_, TrinoParserSOME_, TrinoParserSTART_, TrinoParserSTATS_, TrinoParserSUBSET_, TrinoParserSUBSTRING_, TrinoParserSYSTEM_, TrinoParserTABLES_, TrinoParserTABLESAMPLE_, TrinoParserTEXT_, TrinoParserTEXT_STRING_, TrinoParserTIES_, TrinoParserTIME_, TrinoParserTIMESTAMP_, TrinoParserTO_, TrinoParserTRAILING_, TrinoParserTRANSACTION_, TrinoParserTRIM_, TrinoParserTRUE_, TrinoParserTRUNCATE_, TrinoParserTRY_CAST_, TrinoParserTYPE_, TrinoParserUNBOUNDED_, TrinoParserUNCOMMITTED_, TrinoParserUNCONDITIONAL_, TrinoParserUNIQUE_, TrinoParserUNKNOWN_, TrinoParserUNMATCHED_, TrinoParserUNTIL_, TrinoParserUPDATE_, TrinoParserUSE_, TrinoParserUSER_, TrinoParserUTF16_, TrinoParserUTF32_, TrinoParserUTF8_, TrinoParserVALIDATE_, TrinoParserVALUE_, TrinoParserVERBOSE_, TrinoParserVERSION_, TrinoParserVIEW_, TrinoParserWHILE_, TrinoParserWINDOW_, TrinoParserWITHIN_, TrinoParserWITHOUT_, TrinoParserWORK_, TrinoParserWRAPPER_, TrinoParserWRITE_, TrinoParserYEAR_, TrinoParserZONE_, TrinoParserPLUS_, TrinoParserMINUS_, TrinoParserQUESTION_MARK_, TrinoParserLPAREN_, TrinoParserSTRING_, TrinoParserUNICODE_STRING_, TrinoParserBINARY_LITERAL_, TrinoParserINTEGER_VALUE_, TrinoParserDECIMAL_VALUE_, TrinoParserDOUBLE_VALUE_, TrinoParserIDENTIFIER_, TrinoParserDIGIT_IDENTIFIER_, TrinoParserQUOTED_IDENTIFIER_, TrinoParserBACKQUOTED_IDENTIFIER_:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1930)
			p.valueExpression(0)
		}
		p.SetState(1932)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1931)
				p.Predicate_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TrinoParserNOT_:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1934)
			p.Match(TrinoParserNOT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.booleanExpression(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1944)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) {
			case 1:
				localctx = NewAndContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_booleanExpression)
				p.SetState(1938)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1939)
					p.Match(TrinoParserAND_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1940)
					p.booleanExpression(3)
				}

			case 2:
				localctx = NewOrContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_booleanExpression)
				p.SetState(1941)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1942)
					p.Match(TrinoParserOR_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1943)
					p.booleanExpression(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicate_Context is an interface to support dynamic dispatch.
type IPredicate_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicate_Context differentiates from other interfaces.
	IsPredicate_Context()
}

type Predicate_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicate_Context() *Predicate_Context {
	var p = new(Predicate_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_predicate_
	return p
}

func InitEmptyPredicate_Context(p *Predicate_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_predicate_
}

func (*Predicate_Context) IsPredicate_Context() {}

func NewPredicate_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Predicate_Context {
	var p = new(Predicate_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_predicate_

	return p
}

func (s *Predicate_Context) GetParser() antlr.Parser { return s.parser }

func (s *Predicate_Context) CopyAll(ctx *Predicate_Context) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Predicate_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Predicate_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	Predicate_Context
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikeContext struct {
	Predicate_Context
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIKE_, 0)
}

func (s *LikeContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LikeContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *LikeContext) ESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserESCAPE_, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLike(s)
	}
}

func (s *LikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type InSubqueryContext struct {
	Predicate_Context
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *InSubqueryContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *InSubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InSubqueryContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *InSubqueryContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

func (s *InSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type DistinctFromContext struct {
	Predicate_Context
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIS_, 0)
}

func (s *DistinctFromContext) DISTINCT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDISTINCT_, 0)
}

func (s *DistinctFromContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

func (s *DistinctFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDistinctFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

type InListContext struct {
	Predicate_Context
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *InListContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *InListContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *InListContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *InListContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitInList(s)
	}
}

func (s *InListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitInList(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullPredicateContext struct {
	Predicate_Context
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIS_, 0)
}

func (s *NullPredicateContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *NullPredicateContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

func (s *NullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenContext struct {
	Predicate_Context
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBETWEEN_, 0)
}

func (s *BetweenContext) AND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAND_, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (s *BetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuantifiedComparisonContext struct {
	Predicate_Context
}

func NewQuantifiedComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonContext {
	var p = new(QuantifiedComparisonContext)

	InitEmptyPredicate_Context(&p.Predicate_Context)
	p.parser = parser
	p.CopyAll(ctx.(*Predicate_Context))

	return p
}

func (s *QuantifiedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuantifiedComparisonContext) ComparisonQuantifier() IComparisonQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonQuantifierContext)
}

func (s *QuantifiedComparisonContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *QuantifiedComparisonContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QuantifiedComparisonContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *QuantifiedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQuantifiedComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Predicate_() (localctx IPredicate_Context) {
	localctx = NewPredicate_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, TrinoParserRULE_predicate_)
	var _la int

	p.SetState(2010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1949)
			p.ComparisonOperator()
		}
		{
			p.SetState(1950)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewQuantifiedComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1952)
			p.ComparisonOperator()
		}
		{
			p.SetState(1953)
			p.ComparisonQuantifier()
		}
		{
			p.SetState(1954)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1955)
			p.Query()
		}
		{
			p.SetState(1956)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserNOT_ {
			{
				p.SetState(1958)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1961)
			p.Match(TrinoParserBETWEEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1962)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(1963)
			p.Match(TrinoParserAND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1964)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserNOT_ {
			{
				p.SetState(1966)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1969)
			p.Match(TrinoParserIN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1970)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1971)
			p.Expression()
		}
		p.SetState(1976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(1972)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1973)
				p.Expression()
			}

			p.SetState(1978)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1979)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserNOT_ {
			{
				p.SetState(1981)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1984)
			p.Match(TrinoParserIN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1985)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1986)
			p.Query()
		}
		{
			p.SetState(1987)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserNOT_ {
			{
				p.SetState(1989)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1992)
			p.Match(TrinoParserLIKE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1993)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(1996)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1994)
				p.Match(TrinoParserESCAPE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1995)

				var _x = p.valueExpression(0)

				localctx.(*LikeContext).escape = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1998)
			p.Match(TrinoParserIS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserNOT_ {
			{
				p.SetState(1999)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2002)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2003)
			p.Match(TrinoParserIS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserNOT_ {
			{
				p.SetState(2004)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2007)
			p.Match(TrinoParserDISTINCT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2009)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatenationContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCONCAT_, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (s *ConcatenationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitConcatenation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserASTERISK_, 0)
}

func (s *ArithmeticBinaryContext) SLASH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSLASH_, 0)
}

func (s *ArithmeticBinaryContext) PERCENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPERCENT_, 0)
}

func (s *ArithmeticBinaryContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPLUS_, 0)
}

func (s *ArithmeticBinaryContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUS_, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUS_, 0)
}

func (s *ArithmeticUnaryContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPLUS_, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

type AtTimeZoneContext struct {
	ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAT_, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeZoneSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitAtTimeZone(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *TrinoParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, TrinoParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(2013)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2014)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserPLUS_ || _la == TrinoParserMINUS_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2015)
			p.valueExpression(4)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2030)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_valueExpression)
				p.SetState(2018)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(2019)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-304)) & ^0x3f) == 0 && ((int64(1)<<(_la-304))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2020)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_valueExpression)
				p.SetState(2021)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2022)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TrinoParserPLUS_ || _la == TrinoParserMINUS_) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2023)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_valueExpression)
				p.SetState(2024)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2025)
					p.Match(TrinoParserCONCAT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2026)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_valueExpression)
				p.SetState(2027)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(2028)
					p.Match(TrinoParserAT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2029)
					p.TimeZoneSpecifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base_     IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase_() IPrimaryExpressionContext { return s.base_ }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase_(v IPrimaryExpressionContext) { s.base_ = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) DOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOT_, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeConstructorContext struct {
	PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *TypeConstructorContext) DOUBLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOUBLE_, 0)
}

func (s *TypeConstructorContext) PRECISION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRECISION_, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTypeConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonValueContext struct {
	PrimaryExpressionContext
	emptyBehavior IJsonValueBehaviorContext
	errorBehavior IJsonValueBehaviorContext
}

func NewJsonValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonValueContext {
	var p = new(JsonValueContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *JsonValueContext) GetEmptyBehavior() IJsonValueBehaviorContext { return s.emptyBehavior }

func (s *JsonValueContext) GetErrorBehavior() IJsonValueBehaviorContext { return s.errorBehavior }

func (s *JsonValueContext) SetEmptyBehavior(v IJsonValueBehaviorContext) { s.emptyBehavior = v }

func (s *JsonValueContext) SetErrorBehavior(v IJsonValueBehaviorContext) { s.errorBehavior = v }

func (s *JsonValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueContext) JSON_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_VALUE_, 0)
}

func (s *JsonValueContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *JsonValueContext) JsonPathInvocation() IJsonPathInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathInvocationContext)
}

func (s *JsonValueContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *JsonValueContext) RETURNING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNING_, 0)
}

func (s *JsonValueContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *JsonValueContext) AllON_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserON_)
}

func (s *JsonValueContext) ON_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, i)
}

func (s *JsonValueContext) EMPTY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEMPTY_, 0)
}

func (s *JsonValueContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *JsonValueContext) AllJsonValueBehavior() []IJsonValueBehaviorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonValueBehaviorContext); ok {
			len++
		}
	}

	tst := make([]IJsonValueBehaviorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonValueBehaviorContext); ok {
			tst[i] = t.(IJsonValueBehaviorContext)
			i++
		}
	}

	return tst
}

func (s *JsonValueContext) JsonValueBehavior(i int) IJsonValueBehaviorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueBehaviorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueBehaviorContext)
}

func (s *JsonValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonValue(s)
	}
}

func (s *JsonValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonValue(s)
	}
}

func (s *JsonValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialDateTimeFunctionContext struct {
	PrimaryExpressionContext
	name      antlr.Token
	precision antlr.Token
}

func NewSpecialDateTimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeFunctionContext {
	var p = new(SpecialDateTimeFunctionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SpecialDateTimeFunctionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeFunctionContext) GetPrecision() antlr.Token { return s.precision }

func (s *SpecialDateTimeFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeFunctionContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *SpecialDateTimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeFunctionContext) CURRENT_DATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_DATE_, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_TIME_, 0)
}

func (s *SpecialDateTimeFunctionContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *SpecialDateTimeFunctionContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *SpecialDateTimeFunctionContext) INTEGER_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTEGER_VALUE_, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIMESTAMP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_TIMESTAMP_, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLOCALTIME_, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIMESTAMP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLOCALTIMESTAMP_, 0)
}

func (s *SpecialDateTimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSpecialDateTimeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubstringContext struct {
	PrimaryExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) SUBSTRING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSUBSTRING_, 0)
}

func (s *SubstringContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *SubstringContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *SubstringContext) FOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOR_, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSubstring(s)
	}
}

func (s *SubstringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSubstring(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCAST_, 0)
}

func (s *CastContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *CastContext) TRY_CAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRY_CAST_, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaContext struct {
	PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) RARROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRARROW_, 0)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *LambdaContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *LambdaContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *LambdaContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (s *LambdaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLambda(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TrimContext struct {
	PrimaryExpressionContext
	trimChar   IValueExpressionContext
	trimSource IValueExpressionContext
}

func NewTrimContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TrimContext {
	var p = new(TrimContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TrimContext) GetTrimChar() IValueExpressionContext { return s.trimChar }

func (s *TrimContext) GetTrimSource() IValueExpressionContext { return s.trimSource }

func (s *TrimContext) SetTrimChar(v IValueExpressionContext) { s.trimChar = v }

func (s *TrimContext) SetTrimSource(v IValueExpressionContext) { s.trimSource = v }

func (s *TrimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimContext) TRIM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRIM_, 0)
}

func (s *TrimContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *TrimContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *TrimContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TrimContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *TrimContext) TrimsSpecification() ITrimsSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimsSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimsSpecificationContext)
}

func (s *TrimContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, 0)
}

func (s *TrimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTrim(s)
	}
}

func (s *TrimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTrim(s)
	}
}

func (s *TrimContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTrim(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterContext struct {
	PrimaryExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) QUESTION_MARK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUESTION_MARK_, 0)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

type NormalizeContext struct {
	PrimaryExpressionContext
}

func NewNormalizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizeContext {
	var p = new(NormalizeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NormalizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizeContext) NORMALIZE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNORMALIZE_, 0)
}

func (s *NormalizeContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *NormalizeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizeContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *NormalizeContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, 0)
}

func (s *NormalizeContext) NormalForm() INormalFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalFormContext)
}

func (s *NormalizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNormalize(s)
	}
}

func (s *NormalizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNormalize(s)
	}
}

func (s *NormalizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNormalize(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonObjectContext struct {
	PrimaryExpressionContext
}

func NewJsonObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonObjectContext {
	var p = new(JsonObjectContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *JsonObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonObjectContext) JSON_OBJECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_OBJECT_, 0)
}

func (s *JsonObjectContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *JsonObjectContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *JsonObjectContext) AllJsonObjectMember() []IJsonObjectMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonObjectMemberContext); ok {
			len++
		}
	}

	tst := make([]IJsonObjectMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonObjectMemberContext); ok {
			tst[i] = t.(IJsonObjectMemberContext)
			i++
		}
	}

	return tst
}

func (s *JsonObjectContext) JsonObjectMember(i int) IJsonObjectMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonObjectMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonObjectMemberContext)
}

func (s *JsonObjectContext) RETURNING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNING_, 0)
}

func (s *JsonObjectContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *JsonObjectContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *JsonObjectContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *JsonObjectContext) AllNULL_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserNULL_)
}

func (s *JsonObjectContext) NULL_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, i)
}

func (s *JsonObjectContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *JsonObjectContext) ABSENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserABSENT_, 0)
}

func (s *JsonObjectContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *JsonObjectContext) UNIQUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNIQUE_, 0)
}

func (s *JsonObjectContext) WITHOUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITHOUT_, 0)
}

func (s *JsonObjectContext) FORMAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFORMAT_, 0)
}

func (s *JsonObjectContext) JsonRepresentation() IJsonRepresentationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonRepresentationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonRepresentationContext)
}

func (s *JsonObjectContext) KEYS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserKEYS_, 0)
}

func (s *JsonObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonObject(s)
	}
}

func (s *JsonObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonObject(s)
	}
}

func (s *JsonObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalLiteralContext struct {
	PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	PrimaryExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	PrimaryExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonArrayContext struct {
	PrimaryExpressionContext
}

func NewJsonArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonArrayContext {
	var p = new(JsonArrayContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *JsonArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonArrayContext) JSON_ARRAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_ARRAY_, 0)
}

func (s *JsonArrayContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *JsonArrayContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *JsonArrayContext) AllJsonValueExpression() []IJsonValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IJsonValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonValueExpressionContext); ok {
			tst[i] = t.(IJsonValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *JsonArrayContext) JsonValueExpression(i int) IJsonValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueExpressionContext)
}

func (s *JsonArrayContext) RETURNING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNING_, 0)
}

func (s *JsonArrayContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *JsonArrayContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *JsonArrayContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *JsonArrayContext) AllNULL_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserNULL_)
}

func (s *JsonArrayContext) NULL_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, i)
}

func (s *JsonArrayContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *JsonArrayContext) ABSENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserABSENT_, 0)
}

func (s *JsonArrayContext) FORMAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFORMAT_, 0)
}

func (s *JsonArrayContext) JsonRepresentation() IJsonRepresentationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonRepresentationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonRepresentationContext)
}

func (s *JsonArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonArray(s)
	}
}

func (s *JsonArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonArray(s)
	}
}

func (s *JsonArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	operand        IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetOperand() IExpressionContext { return s.operand }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetOperand(v IExpressionContext) { s.operand = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCASE_, 0)
}

func (s *SimpleCaseContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserELSE_, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	PrimaryExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type RowConstructorContext struct {
	PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *RowConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RowConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RowConstructorContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *RowConstructorContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *RowConstructorContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *RowConstructorContext) ROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROW_, 0)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) LSQUARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLSQUARE_, 0)
}

func (s *SubscriptContext) RSQUARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRSQUARE_, 0)
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonExistsContext struct {
	PrimaryExpressionContext
}

func NewJsonExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExistsContext {
	var p = new(JsonExistsContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *JsonExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExistsContext) JSON_EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_EXISTS_, 0)
}

func (s *JsonExistsContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *JsonExistsContext) JsonPathInvocation() IJsonPathInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathInvocationContext)
}

func (s *JsonExistsContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *JsonExistsContext) JsonExistsErrorBehavior() IJsonExistsErrorBehaviorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonExistsErrorBehaviorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonExistsErrorBehaviorContext)
}

func (s *JsonExistsContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *JsonExistsContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *JsonExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonExists(s)
	}
}

func (s *JsonExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonExists(s)
	}
}

func (s *JsonExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentPathContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentPathContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentPathContext {
	var p = new(CurrentPathContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentPathContext) GetName() antlr.Token { return s.name }

func (s *CurrentPathContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentPathContext) CURRENT_PATH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_PATH_, 0)
}

func (s *CurrentPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCurrentPath(s)
	}
}

func (s *CurrentPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCurrentPath(s)
	}
}

func (s *CurrentPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCurrentPath(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryLiteralContext struct {
	PrimaryExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) BINARY_LITERAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBINARY_LITERAL_, 0)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitBinaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_USER_, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

func (s *CurrentUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCurrentUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonQueryContext struct {
	PrimaryExpressionContext
	emptyBehavior IJsonQueryBehaviorContext
	errorBehavior IJsonQueryBehaviorContext
}

func NewJsonQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonQueryContext {
	var p = new(JsonQueryContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *JsonQueryContext) GetEmptyBehavior() IJsonQueryBehaviorContext { return s.emptyBehavior }

func (s *JsonQueryContext) GetErrorBehavior() IJsonQueryBehaviorContext { return s.errorBehavior }

func (s *JsonQueryContext) SetEmptyBehavior(v IJsonQueryBehaviorContext) { s.emptyBehavior = v }

func (s *JsonQueryContext) SetErrorBehavior(v IJsonQueryBehaviorContext) { s.errorBehavior = v }

func (s *JsonQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonQueryContext) JSON_QUERY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_QUERY_, 0)
}

func (s *JsonQueryContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *JsonQueryContext) JsonPathInvocation() IJsonPathInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonPathInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonPathInvocationContext)
}

func (s *JsonQueryContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *JsonQueryContext) RETURNING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNING_, 0)
}

func (s *JsonQueryContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *JsonQueryContext) JsonQueryWrapperBehavior() IJsonQueryWrapperBehaviorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonQueryWrapperBehaviorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonQueryWrapperBehaviorContext)
}

func (s *JsonQueryContext) WRAPPER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWRAPPER_, 0)
}

func (s *JsonQueryContext) QUOTES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUOTES_, 0)
}

func (s *JsonQueryContext) AllON_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserON_)
}

func (s *JsonQueryContext) ON_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, i)
}

func (s *JsonQueryContext) EMPTY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEMPTY_, 0)
}

func (s *JsonQueryContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *JsonQueryContext) KEEP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserKEEP_, 0)
}

func (s *JsonQueryContext) OMIT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOMIT_, 0)
}

func (s *JsonQueryContext) AllJsonQueryBehavior() []IJsonQueryBehaviorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonQueryBehaviorContext); ok {
			len++
		}
	}

	tst := make([]IJsonQueryBehaviorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonQueryBehaviorContext); ok {
			tst[i] = t.(IJsonQueryBehaviorContext)
			i++
		}
	}

	return tst
}

func (s *JsonQueryContext) JsonQueryBehavior(i int) IJsonQueryBehaviorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonQueryBehaviorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonQueryBehaviorContext)
}

func (s *JsonQueryContext) FORMAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFORMAT_, 0)
}

func (s *JsonQueryContext) JsonRepresentation() IJsonRepresentationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonRepresentationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonRepresentationContext)
}

func (s *JsonQueryContext) SCALAR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCALAR_, 0)
}

func (s *JsonQueryContext) TEXT_STRING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTEXT_STRING_, 0)
}

func (s *JsonQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonQuery(s)
	}
}

func (s *JsonQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonQuery(s)
	}
}

func (s *JsonQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type MeasureContext struct {
	PrimaryExpressionContext
}

func NewMeasureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MeasureContext {
	var p = new(MeasureContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MeasureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeasureContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MeasureContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *MeasureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterMeasure(s)
	}
}

func (s *MeasureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitMeasure(s)
	}
}

func (s *MeasureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitMeasure(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	PrimaryExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXTRACT_, 0)
}

func (s *ExtractContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFROM_, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExtract(s)
	}
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	PrimaryExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayConstructorContext struct {
	PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserARRAY_, 0)
}

func (s *ArrayConstructorContext) LSQUARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLSQUARE_, 0)
}

func (s *ArrayConstructorContext) RSQUARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRSQUARE_, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *ArrayConstructorContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
	label IIdentifierContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetLabel() IIdentifierContext { return s.label }

func (s *FunctionCallContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionCallContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *FunctionCallContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserASTERISK_, 0)
}

func (s *FunctionCallContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *FunctionCallContext) ProcessingMode() IProcessingModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcessingModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcessingModeContext)
}

func (s *FunctionCallContext) DOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOT_, 0)
}

func (s *FunctionCallContext) Filter() IFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *FunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *FunctionCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) ORDER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDER_, 0)
}

func (s *FunctionCallContext) BY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, 0)
}

func (s *FunctionCallContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *FunctionCallContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *FunctionCallContext) NullTreatment() INullTreatmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullTreatmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullTreatmentContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentSchemaContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentSchemaContext {
	var p = new(CurrentSchemaContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentSchemaContext) GetName() antlr.Token { return s.name }

func (s *CurrentSchemaContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentSchemaContext) CURRENT_SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_SCHEMA_, 0)
}

func (s *CurrentSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCurrentSchema(s)
	}
}

func (s *CurrentSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCurrentSchema(s)
	}
}

func (s *CurrentSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCurrentSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsContext struct {
	PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXISTS_, 0)
}

func (s *ExistsContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExists(s)
	}
}

func (s *ExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type PositionContext struct {
	PrimaryExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPOSITION_, 0)
}

func (s *PositionContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) IN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIN_, 0)
}

func (s *PositionContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPosition(s)
	}
}

func (s *PositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

type ListaggContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewListaggContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListaggContext {
	var p = new(ListaggContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ListaggContext) GetName() antlr.Token { return s.name }

func (s *ListaggContext) SetName(v antlr.Token) { s.name = v }

func (s *ListaggContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaggContext) AllLPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserLPAREN_)
}

func (s *ListaggContext) LPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, i)
}

func (s *ListaggContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListaggContext) AllRPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserRPAREN_)
}

func (s *ListaggContext) RPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, i)
}

func (s *ListaggContext) LISTAGG_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLISTAGG_, 0)
}

func (s *ListaggContext) WITHIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITHIN_, 0)
}

func (s *ListaggContext) GROUP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGROUP_, 0)
}

func (s *ListaggContext) ORDER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDER_, 0)
}

func (s *ListaggContext) BY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBY_, 0)
}

func (s *ListaggContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ListaggContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ListaggContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *ListaggContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *ListaggContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *ListaggContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ListaggContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *ListaggContext) OVERFLOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOVERFLOW_, 0)
}

func (s *ListaggContext) ListAggOverflowBehavior() IListAggOverflowBehaviorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListAggOverflowBehaviorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListAggOverflowBehaviorContext)
}

func (s *ListaggContext) Filter() IFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *ListaggContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterListagg(s)
	}
}

func (s *ListaggContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitListagg(s)
	}
}

func (s *ListaggContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitListagg(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCASE_, 0)
}

func (s *SearchedCaseContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserELSE_, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentCatalogContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentCatalogContext {
	var p = new(CurrentCatalogContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentCatalogContext) GetName() antlr.Token { return s.name }

func (s *CurrentCatalogContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentCatalogContext) CURRENT_CATALOG_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_CATALOG_, 0)
}

func (s *CurrentCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCurrentCatalog(s)
	}
}

func (s *CurrentCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCurrentCatalog(s)
	}
}

func (s *CurrentCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCurrentCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupingOperationContext struct {
	PrimaryExpressionContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGROUPING_, 0)
}

func (s *GroupingOperationContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *GroupingOperationContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *GroupingOperationContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *GroupingOperationContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GroupingOperationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *GroupingOperationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *TrinoParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 128
	p.EnterRecursionRule(localctx, 128, TrinoParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(2036)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2037)
			p.Interval()
		}

	case 3:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2038)
			p.Identifier()
		}
		{
			p.SetState(2039)
			p.String_()
		}

	case 4:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2041)
			p.Match(TrinoParserDOUBLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2042)
			p.Match(TrinoParserPRECISION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2043)
			p.String_()
		}

	case 5:
		localctx = NewNumericLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2044)
			p.Number()
		}

	case 6:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2045)
			p.BooleanValue()
		}

	case 7:
		localctx = NewStringLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2046)
			p.String_()
		}

	case 8:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2047)
			p.Match(TrinoParserBINARY_LITERAL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewParameterContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2048)
			p.Match(TrinoParserQUESTION_MARK_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2049)
			p.Match(TrinoParserPOSITION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2050)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2051)
			p.valueExpression(0)
		}
		{
			p.SetState(2052)
			p.Match(TrinoParserIN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2053)
			p.valueExpression(0)
		}
		{
			p.SetState(2054)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2056)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2057)
			p.Expression()
		}
		p.SetState(2060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TrinoParserCOMMA_ {
			{
				p.SetState(2058)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2059)
				p.Expression()
			}

			p.SetState(2062)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2064)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2066)
			p.Match(TrinoParserROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2067)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2068)
			p.Expression()
		}
		p.SetState(2073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2069)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2070)
				p.Expression()
			}

			p.SetState(2075)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2076)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewListaggContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2078)

			var _m = p.Match(TrinoParserLISTAGG_)

			localctx.(*ListaggContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2079)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2081)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2080)
				p.SetQuantifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2083)
			p.Expression()
		}
		p.SetState(2086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCOMMA_ {
			{
				p.SetState(2084)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2085)
				p.String_()
			}

		}
		p.SetState(2091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserON_ {
			{
				p.SetState(2088)
				p.Match(TrinoParserON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2089)
				p.Match(TrinoParserOVERFLOW_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2090)
				p.ListAggOverflowBehavior()
			}

		}
		{
			p.SetState(2093)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(2094)
			p.Match(TrinoParserWITHIN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2095)
			p.Match(TrinoParserGROUP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2097)
			p.Match(TrinoParserORDER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.Match(TrinoParserBY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2099)
			p.SortItem()
		}
		p.SetState(2104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2100)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2101)
				p.SortItem()
			}

			p.SetState(2106)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2107)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2110)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2109)
				p.Filter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(2113)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2112)
				p.ProcessingMode()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2115)
			p.QualifiedName()
		}
		{
			p.SetState(2116)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699602754) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
			{
				p.SetState(2117)

				var _x = p.Identifier()

				localctx.(*FunctionCallContext).label = _x
			}
			{
				p.SetState(2118)
				p.Match(TrinoParserDOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2122)
			p.Match(TrinoParserASTERISK_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2123)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2125)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2124)
				p.Filter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2128)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2127)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 15:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(2131)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2130)
				p.ProcessingMode()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2133)
			p.QualifiedName()
		}
		{
			p.SetState(2134)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2146)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-650779431874988354) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
			p.SetState(2136)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2135)
					p.SetQuantifier()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2138)
				p.Expression()
			}
			p.SetState(2143)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2139)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2140)
					p.Expression()
				}

				p.SetState(2145)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(2158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserORDER_ {
			{
				p.SetState(2148)
				p.Match(TrinoParserORDER_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2149)
				p.Match(TrinoParserBY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2150)
				p.SortItem()
			}
			p.SetState(2155)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2151)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2152)
					p.SortItem()
				}

				p.SetState(2157)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2160)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2162)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2161)
				p.Filter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2168)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
			p.SetState(2165)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserIGNORE_ || _la == TrinoParserRESPECT_ {
				{
					p.SetState(2164)
					p.NullTreatment()
				}

			}
			{
				p.SetState(2167)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 16:
		localctx = NewMeasureContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2170)
			p.Identifier()
		}
		{
			p.SetState(2171)
			p.Over()
		}

	case 17:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2173)
			p.Identifier()
		}
		{
			p.SetState(2174)
			p.Match(TrinoParserRARROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.Expression()
		}

	case 18:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2177)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699602754) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
			{
				p.SetState(2178)
				p.Identifier()
			}
			p.SetState(2183)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2179)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2180)
					p.Identifier()
				}

				p.SetState(2185)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2188)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2189)
			p.Match(TrinoParserRARROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2190)
			p.Expression()
		}

	case 19:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2191)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2192)
			p.Query()
		}
		{
			p.SetState(2193)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2195)
			p.Match(TrinoParserEXISTS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2196)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2197)
			p.Query()
		}
		{
			p.SetState(2198)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2200)
			p.Match(TrinoParserCASE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2201)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).operand = _x
		}
		p.SetState(2203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TrinoParserWHEN_ {
			{
				p.SetState(2202)
				p.WhenClause()
			}

			p.SetState(2205)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserELSE_ {
			{
				p.SetState(2207)
				p.Match(TrinoParserELSE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2208)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(2211)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2213)
			p.Match(TrinoParserCASE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TrinoParserWHEN_ {
			{
				p.SetState(2214)
				p.WhenClause()
			}

			p.SetState(2217)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserELSE_ {
			{
				p.SetState(2219)
				p.Match(TrinoParserELSE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2220)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(2223)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2225)
			p.Match(TrinoParserCAST_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2226)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2227)
			p.Expression()
		}
		{
			p.SetState(2228)
			p.Match(TrinoParserAS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2229)
			p.type_(0)
		}
		{
			p.SetState(2230)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2232)
			p.Match(TrinoParserTRY_CAST_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2233)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2234)
			p.Expression()
		}
		{
			p.SetState(2235)
			p.Match(TrinoParserAS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2236)
			p.type_(0)
		}
		{
			p.SetState(2237)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2239)
			p.Match(TrinoParserARRAY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2240)
			p.Match(TrinoParserLSQUARE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227633993941633) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
			{
				p.SetState(2241)
				p.Expression()
			}
			p.SetState(2246)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2242)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2243)
					p.Expression()
				}

				p.SetState(2248)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2251)
			p.Match(TrinoParserRSQUARE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2252)
			p.Identifier()
		}

	case 27:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2253)

			var _m = p.Match(TrinoParserCURRENT_DATE_)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2254)

			var _m = p.Match(TrinoParserCURRENT_TIME_)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2258)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2255)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2256)

				var _m = p.Match(TrinoParserINTEGER_VALUE_)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2257)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 29:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2260)

			var _m = p.Match(TrinoParserCURRENT_TIMESTAMP_)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2264)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2261)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2262)

				var _m = p.Match(TrinoParserINTEGER_VALUE_)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2263)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 30:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2266)

			var _m = p.Match(TrinoParserLOCALTIME_)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2270)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2267)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2268)

				var _m = p.Match(TrinoParserINTEGER_VALUE_)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2269)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 31:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2272)

			var _m = p.Match(TrinoParserLOCALTIMESTAMP_)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2276)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2273)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2274)

				var _m = p.Match(TrinoParserINTEGER_VALUE_)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2275)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 32:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2278)

			var _m = p.Match(TrinoParserCURRENT_USER_)

			localctx.(*CurrentUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		localctx = NewCurrentCatalogContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2279)

			var _m = p.Match(TrinoParserCURRENT_CATALOG_)

			localctx.(*CurrentCatalogContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		localctx = NewCurrentSchemaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2280)

			var _m = p.Match(TrinoParserCURRENT_SCHEMA_)

			localctx.(*CurrentSchemaContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		localctx = NewCurrentPathContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2281)

			var _m = p.Match(TrinoParserCURRENT_PATH_)

			localctx.(*CurrentPathContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		localctx = NewTrimContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2282)
			p.Match(TrinoParserTRIM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2283)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2291)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
			p.SetState(2285)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2284)
					p.TrimsSpecification()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(2288)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262465450302376258) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2347169330619225741) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6227771432895105) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&148830988330065375) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&1023) != 0) {
				{
					p.SetState(2287)

					var _x = p.valueExpression(0)

					localctx.(*TrimContext).trimChar = _x
				}

			}
			{
				p.SetState(2290)
				p.Match(TrinoParserFROM_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2293)

			var _x = p.valueExpression(0)

			localctx.(*TrimContext).trimSource = _x
		}
		{
			p.SetState(2294)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		localctx = NewTrimContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2296)
			p.Match(TrinoParserTRIM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2297)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2298)

			var _x = p.valueExpression(0)

			localctx.(*TrimContext).trimSource = _x
		}
		{
			p.SetState(2299)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2300)

			var _x = p.valueExpression(0)

			localctx.(*TrimContext).trimChar = _x
		}
		{
			p.SetState(2301)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2303)
			p.Match(TrinoParserSUBSTRING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2304)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2305)
			p.valueExpression(0)
		}
		{
			p.SetState(2306)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2307)
			p.valueExpression(0)
		}
		p.SetState(2310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserFOR_ {
			{
				p.SetState(2308)
				p.Match(TrinoParserFOR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2309)
				p.valueExpression(0)
			}

		}
		{
			p.SetState(2312)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		localctx = NewNormalizeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2314)
			p.Match(TrinoParserNORMALIZE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2315)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2316)
			p.valueExpression(0)
		}
		p.SetState(2319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCOMMA_ {
			{
				p.SetState(2317)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2318)
				p.NormalForm()
			}

		}
		{
			p.SetState(2321)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2323)
			p.Match(TrinoParserEXTRACT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2324)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2325)
			p.Identifier()
		}
		{
			p.SetState(2326)
			p.Match(TrinoParserFROM_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2327)
			p.valueExpression(0)
		}
		{
			p.SetState(2328)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2330)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2331)
			p.Expression()
		}
		{
			p.SetState(2332)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		localctx = NewGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2334)
			p.Match(TrinoParserGROUPING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2335)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699602754) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
			{
				p.SetState(2336)
				p.QualifiedName()
			}
			p.SetState(2341)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2337)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2338)
					p.QualifiedName()
				}

				p.SetState(2343)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2346)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		localctx = NewJsonExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2347)
			p.Match(TrinoParserJSON_EXISTS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2348)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2349)
			p.JsonPathInvocation()
		}
		p.SetState(2354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserERROR_ || _la == TrinoParserFALSE_ || _la == TrinoParserTRUE_ || _la == TrinoParserUNKNOWN_ {
			{
				p.SetState(2350)
				p.JsonExistsErrorBehavior()
			}
			{
				p.SetState(2351)
				p.Match(TrinoParserON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2352)
				p.Match(TrinoParserERROR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2356)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		localctx = NewJsonValueContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2358)
			p.Match(TrinoParserJSON_VALUE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2359)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2360)
			p.JsonPathInvocation()
		}
		p.SetState(2363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserRETURNING_ {
			{
				p.SetState(2361)
				p.Match(TrinoParserRETURNING_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2362)
				p.type_(0)
			}

		}
		p.SetState(2369)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 306, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2365)

				var _x = p.JsonValueBehavior()

				localctx.(*JsonValueContext).emptyBehavior = _x
			}
			{
				p.SetState(2366)
				p.Match(TrinoParserON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2367)
				p.Match(TrinoParserEMPTY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserDEFAULT_ || _la == TrinoParserERROR_ || _la == TrinoParserNULL_ {
			{
				p.SetState(2371)

				var _x = p.JsonValueBehavior()

				localctx.(*JsonValueContext).errorBehavior = _x
			}
			{
				p.SetState(2372)
				p.Match(TrinoParserON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2373)
				p.Match(TrinoParserERROR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2377)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 45:
		localctx = NewJsonQueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2379)
			p.Match(TrinoParserJSON_QUERY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2380)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2381)
			p.JsonPathInvocation()
		}
		p.SetState(2388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserRETURNING_ {
			{
				p.SetState(2382)
				p.Match(TrinoParserRETURNING_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2383)
				p.type_(0)
			}
			p.SetState(2386)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserFORMAT_ {
				{
					p.SetState(2384)
					p.Match(TrinoParserFORMAT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2385)
					p.JsonRepresentation()
				}

			}

		}
		p.SetState(2393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserWITH_ || _la == TrinoParserWITHOUT_ {
			{
				p.SetState(2390)
				p.JsonQueryWrapperBehavior()
			}
			{
				p.SetState(2391)
				p.Match(TrinoParserWRAPPER_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserKEEP_ || _la == TrinoParserOMIT_ {
			{
				p.SetState(2395)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserKEEP_ || _la == TrinoParserOMIT_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2396)
				p.Match(TrinoParserQUOTES_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2400)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserON_ {
				{
					p.SetState(2397)
					p.Match(TrinoParserON_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2398)
					p.Match(TrinoParserSCALAR_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2399)
					p.Match(TrinoParserTEXT_STRING_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		p.SetState(2408)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2404)

				var _x = p.JsonQueryBehavior()

				localctx.(*JsonQueryContext).emptyBehavior = _x
			}
			{
				p.SetState(2405)
				p.Match(TrinoParserON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2406)
				p.Match(TrinoParserEMPTY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserEMPTY_ || _la == TrinoParserERROR_ || _la == TrinoParserNULL_ {
			{
				p.SetState(2410)

				var _x = p.JsonQueryBehavior()

				localctx.(*JsonQueryContext).errorBehavior = _x
			}
			{
				p.SetState(2411)
				p.Match(TrinoParserON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2412)
				p.Match(TrinoParserERROR_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2416)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		localctx = NewJsonObjectContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2418)
			p.Match(TrinoParserJSON_OBJECT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2419)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2448)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2420)
				p.JsonObjectMember()
			}
			p.SetState(2425)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2421)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2422)
					p.JsonObjectMember()
				}

				p.SetState(2427)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(2434)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case TrinoParserNULL_:
				{
					p.SetState(2428)
					p.Match(TrinoParserNULL_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2429)
					p.Match(TrinoParserON_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2430)
					p.Match(TrinoParserNULL_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TrinoParserABSENT_:
				{
					p.SetState(2431)
					p.Match(TrinoParserABSENT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2432)
					p.Match(TrinoParserON_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2433)
					p.Match(TrinoParserNULL_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TrinoParserRETURNING_, TrinoParserWITH_, TrinoParserWITHOUT_, TrinoParserRPAREN_:

			default:
			}
			p.SetState(2446)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case TrinoParserWITH_:
				{
					p.SetState(2436)
					p.Match(TrinoParserWITH_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2437)
					p.Match(TrinoParserUNIQUE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2439)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TrinoParserKEYS_ {
					{
						p.SetState(2438)
						p.Match(TrinoParserKEYS_)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			case TrinoParserWITHOUT_:
				{
					p.SetState(2441)
					p.Match(TrinoParserWITHOUT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2442)
					p.Match(TrinoParserUNIQUE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2444)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TrinoParserKEYS_ {
					{
						p.SetState(2443)
						p.Match(TrinoParserKEYS_)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			case TrinoParserRETURNING_, TrinoParserRPAREN_:

			default:
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserRETURNING_ {
			{
				p.SetState(2450)
				p.Match(TrinoParserRETURNING_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2451)
				p.type_(0)
			}
			p.SetState(2454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserFORMAT_ {
				{
					p.SetState(2452)
					p.Match(TrinoParserFORMAT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2453)
					p.JsonRepresentation()
				}

			}

		}
		{
			p.SetState(2458)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		localctx = NewJsonArrayContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2459)
			p.Match(TrinoParserJSON_ARRAY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2460)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2477)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2461)
				p.JsonValueExpression()
			}
			p.SetState(2466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2462)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2463)
					p.JsonValueExpression()
				}

				p.SetState(2468)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(2475)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case TrinoParserNULL_:
				{
					p.SetState(2469)
					p.Match(TrinoParserNULL_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2470)
					p.Match(TrinoParserON_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2471)
					p.Match(TrinoParserNULL_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TrinoParserABSENT_:
				{
					p.SetState(2472)
					p.Match(TrinoParserABSENT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2473)
					p.Match(TrinoParserON_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2474)
					p.Match(TrinoParserNULL_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TrinoParserRETURNING_, TrinoParserRPAREN_:

			default:
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserRETURNING_ {
			{
				p.SetState(2479)
				p.Match(TrinoParserRETURNING_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2480)
				p.type_(0)
			}
			p.SetState(2483)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TrinoParserFORMAT_ {
				{
					p.SetState(2481)
					p.Match(TrinoParserFORMAT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2482)
					p.JsonRepresentation()
				}

			}

		}
		{
			p.SetState(2487)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2498)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_primaryExpression)
				p.SetState(2490)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(2491)
					p.Match(TrinoParserLSQUARE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2492)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(2493)
					p.Match(TrinoParserRSQUARE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base_ = _prevctx

				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_primaryExpression)
				p.SetState(2495)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(2496)
					p.Match(TrinoParserDOT_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2497)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonPathInvocationContext is an interface to support dynamic dispatch.
type IJsonPathInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path rule contexts.
	GetPath() IString_Context

	// SetPath sets the path rule contexts.
	SetPath(IString_Context)

	// Getter signatures
	JsonValueExpression() IJsonValueExpressionContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode
	String_() IString_Context
	PASSING_() antlr.TerminalNode
	AllJsonArgument() []IJsonArgumentContext
	JsonArgument(i int) IJsonArgumentContext

	// IsJsonPathInvocationContext differentiates from other interfaces.
	IsJsonPathInvocationContext()
}

type JsonPathInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	path   IString_Context
}

func NewEmptyJsonPathInvocationContext() *JsonPathInvocationContext {
	var p = new(JsonPathInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonPathInvocation
	return p
}

func InitEmptyJsonPathInvocationContext(p *JsonPathInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonPathInvocation
}

func (*JsonPathInvocationContext) IsJsonPathInvocationContext() {}

func NewJsonPathInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonPathInvocationContext {
	var p = new(JsonPathInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonPathInvocation

	return p
}

func (s *JsonPathInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonPathInvocationContext) GetPath() IString_Context { return s.path }

func (s *JsonPathInvocationContext) SetPath(v IString_Context) { s.path = v }

func (s *JsonPathInvocationContext) JsonValueExpression() IJsonValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueExpressionContext)
}

func (s *JsonPathInvocationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *JsonPathInvocationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *JsonPathInvocationContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *JsonPathInvocationContext) PASSING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPASSING_, 0)
}

func (s *JsonPathInvocationContext) AllJsonArgument() []IJsonArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonArgumentContext); ok {
			len++
		}
	}

	tst := make([]IJsonArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonArgumentContext); ok {
			tst[i] = t.(IJsonArgumentContext)
			i++
		}
	}

	return tst
}

func (s *JsonPathInvocationContext) JsonArgument(i int) IJsonArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonArgumentContext)
}

func (s *JsonPathInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonPathInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonPathInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonPathInvocation(s)
	}
}

func (s *JsonPathInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonPathInvocation(s)
	}
}

func (s *JsonPathInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonPathInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonPathInvocation() (localctx IJsonPathInvocationContext) {
	localctx = NewJsonPathInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, TrinoParserRULE_jsonPathInvocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2503)
		p.JsonValueExpression()
	}
	{
		p.SetState(2504)
		p.Match(TrinoParserCOMMA_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2505)

		var _x = p.String_()

		localctx.(*JsonPathInvocationContext).path = _x
	}
	p.SetState(2515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserPASSING_ {
		{
			p.SetState(2506)
			p.Match(TrinoParserPASSING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2507)
			p.JsonArgument()
		}
		p.SetState(2512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2508)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2509)
				p.JsonArgument()
			}

			p.SetState(2514)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonValueExpressionContext is an interface to support dynamic dispatch.
type IJsonValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	FORMAT_() antlr.TerminalNode
	JsonRepresentation() IJsonRepresentationContext

	// IsJsonValueExpressionContext differentiates from other interfaces.
	IsJsonValueExpressionContext()
}

type JsonValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonValueExpressionContext() *JsonValueExpressionContext {
	var p = new(JsonValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonValueExpression
	return p
}

func InitEmptyJsonValueExpressionContext(p *JsonValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonValueExpression
}

func (*JsonValueExpressionContext) IsJsonValueExpressionContext() {}

func NewJsonValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonValueExpressionContext {
	var p = new(JsonValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonValueExpression

	return p
}

func (s *JsonValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonValueExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JsonValueExpressionContext) FORMAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFORMAT_, 0)
}

func (s *JsonValueExpressionContext) JsonRepresentation() IJsonRepresentationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonRepresentationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonRepresentationContext)
}

func (s *JsonValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonValueExpression(s)
	}
}

func (s *JsonValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonValueExpression(s)
	}
}

func (s *JsonValueExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonValueExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonValueExpression() (localctx IJsonValueExpressionContext) {
	localctx = NewJsonValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, TrinoParserRULE_jsonValueExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2517)
		p.Expression()
	}
	p.SetState(2520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserFORMAT_ {
		{
			p.SetState(2518)
			p.Match(TrinoParserFORMAT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2519)
			p.JsonRepresentation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonRepresentationContext is an interface to support dynamic dispatch.
type IJsonRepresentationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_() antlr.TerminalNode
	ENCODING_() antlr.TerminalNode
	UTF8_() antlr.TerminalNode
	UTF16_() antlr.TerminalNode
	UTF32_() antlr.TerminalNode

	// IsJsonRepresentationContext differentiates from other interfaces.
	IsJsonRepresentationContext()
}

type JsonRepresentationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonRepresentationContext() *JsonRepresentationContext {
	var p = new(JsonRepresentationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonRepresentation
	return p
}

func InitEmptyJsonRepresentationContext(p *JsonRepresentationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonRepresentation
}

func (*JsonRepresentationContext) IsJsonRepresentationContext() {}

func NewJsonRepresentationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonRepresentationContext {
	var p = new(JsonRepresentationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonRepresentation

	return p
}

func (s *JsonRepresentationContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonRepresentationContext) JSON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_, 0)
}

func (s *JsonRepresentationContext) ENCODING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserENCODING_, 0)
}

func (s *JsonRepresentationContext) UTF8_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUTF8_, 0)
}

func (s *JsonRepresentationContext) UTF16_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUTF16_, 0)
}

func (s *JsonRepresentationContext) UTF32_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUTF32_, 0)
}

func (s *JsonRepresentationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonRepresentationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonRepresentationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonRepresentation(s)
	}
}

func (s *JsonRepresentationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonRepresentation(s)
	}
}

func (s *JsonRepresentationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonRepresentation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonRepresentation() (localctx IJsonRepresentationContext) {
	localctx = NewJsonRepresentationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, TrinoParserRULE_jsonRepresentation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2522)
		p.Match(TrinoParserJSON_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserENCODING_ {
		{
			p.SetState(2523)
			p.Match(TrinoParserENCODING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2524)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonArgumentContext is an interface to support dynamic dispatch.
type IJsonArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JsonValueExpression() IJsonValueExpressionContext
	AS_() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsJsonArgumentContext differentiates from other interfaces.
	IsJsonArgumentContext()
}

type JsonArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonArgumentContext() *JsonArgumentContext {
	var p = new(JsonArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonArgument
	return p
}

func InitEmptyJsonArgumentContext(p *JsonArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonArgument
}

func (*JsonArgumentContext) IsJsonArgumentContext() {}

func NewJsonArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonArgumentContext {
	var p = new(JsonArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonArgument

	return p
}

func (s *JsonArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonArgumentContext) JsonValueExpression() IJsonValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueExpressionContext)
}

func (s *JsonArgumentContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *JsonArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JsonArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonArgument(s)
	}
}

func (s *JsonArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonArgument(s)
	}
}

func (s *JsonArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonArgument() (localctx IJsonArgumentContext) {
	localctx = NewJsonArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, TrinoParserRULE_jsonArgument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2527)
		p.JsonValueExpression()
	}
	{
		p.SetState(2528)
		p.Match(TrinoParserAS_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2529)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonExistsErrorBehaviorContext is an interface to support dynamic dispatch.
type IJsonExistsErrorBehaviorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE_() antlr.TerminalNode
	FALSE_() antlr.TerminalNode
	UNKNOWN_() antlr.TerminalNode
	ERROR_() antlr.TerminalNode

	// IsJsonExistsErrorBehaviorContext differentiates from other interfaces.
	IsJsonExistsErrorBehaviorContext()
}

type JsonExistsErrorBehaviorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonExistsErrorBehaviorContext() *JsonExistsErrorBehaviorContext {
	var p = new(JsonExistsErrorBehaviorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonExistsErrorBehavior
	return p
}

func InitEmptyJsonExistsErrorBehaviorContext(p *JsonExistsErrorBehaviorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonExistsErrorBehavior
}

func (*JsonExistsErrorBehaviorContext) IsJsonExistsErrorBehaviorContext() {}

func NewJsonExistsErrorBehaviorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonExistsErrorBehaviorContext {
	var p = new(JsonExistsErrorBehaviorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonExistsErrorBehavior

	return p
}

func (s *JsonExistsErrorBehaviorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonExistsErrorBehaviorContext) TRUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRUE_, 0)
}

func (s *JsonExistsErrorBehaviorContext) FALSE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFALSE_, 0)
}

func (s *JsonExistsErrorBehaviorContext) UNKNOWN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNKNOWN_, 0)
}

func (s *JsonExistsErrorBehaviorContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *JsonExistsErrorBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExistsErrorBehaviorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonExistsErrorBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonExistsErrorBehavior(s)
	}
}

func (s *JsonExistsErrorBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonExistsErrorBehavior(s)
	}
}

func (s *JsonExistsErrorBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonExistsErrorBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonExistsErrorBehavior() (localctx IJsonExistsErrorBehaviorContext) {
	localctx = NewJsonExistsErrorBehaviorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, TrinoParserRULE_jsonExistsErrorBehavior)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2531)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserERROR_ || _la == TrinoParserFALSE_ || _la == TrinoParserTRUE_ || _la == TrinoParserUNKNOWN_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonValueBehaviorContext is an interface to support dynamic dispatch.
type IJsonValueBehaviorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR_() antlr.TerminalNode
	NULL_() antlr.TerminalNode
	DEFAULT_() antlr.TerminalNode
	Expression() IExpressionContext

	// IsJsonValueBehaviorContext differentiates from other interfaces.
	IsJsonValueBehaviorContext()
}

type JsonValueBehaviorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonValueBehaviorContext() *JsonValueBehaviorContext {
	var p = new(JsonValueBehaviorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonValueBehavior
	return p
}

func InitEmptyJsonValueBehaviorContext(p *JsonValueBehaviorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonValueBehavior
}

func (*JsonValueBehaviorContext) IsJsonValueBehaviorContext() {}

func NewJsonValueBehaviorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonValueBehaviorContext {
	var p = new(JsonValueBehaviorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonValueBehavior

	return p
}

func (s *JsonValueBehaviorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonValueBehaviorContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *JsonValueBehaviorContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *JsonValueBehaviorContext) DEFAULT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFAULT_, 0)
}

func (s *JsonValueBehaviorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JsonValueBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueBehaviorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonValueBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonValueBehavior(s)
	}
}

func (s *JsonValueBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonValueBehavior(s)
	}
}

func (s *JsonValueBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonValueBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonValueBehavior() (localctx IJsonValueBehaviorContext) {
	localctx = NewJsonValueBehaviorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, TrinoParserRULE_jsonValueBehavior)
	p.SetState(2537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserERROR_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2533)
			p.Match(TrinoParserERROR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserNULL_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2534)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserDEFAULT_:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2535)
			p.Match(TrinoParserDEFAULT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2536)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonQueryWrapperBehaviorContext is an interface to support dynamic dispatch.
type IJsonQueryWrapperBehaviorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITHOUT_() antlr.TerminalNode
	ARRAY_() antlr.TerminalNode
	WITH_() antlr.TerminalNode
	CONDITIONAL_() antlr.TerminalNode
	UNCONDITIONAL_() antlr.TerminalNode

	// IsJsonQueryWrapperBehaviorContext differentiates from other interfaces.
	IsJsonQueryWrapperBehaviorContext()
}

type JsonQueryWrapperBehaviorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonQueryWrapperBehaviorContext() *JsonQueryWrapperBehaviorContext {
	var p = new(JsonQueryWrapperBehaviorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonQueryWrapperBehavior
	return p
}

func InitEmptyJsonQueryWrapperBehaviorContext(p *JsonQueryWrapperBehaviorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonQueryWrapperBehavior
}

func (*JsonQueryWrapperBehaviorContext) IsJsonQueryWrapperBehaviorContext() {}

func NewJsonQueryWrapperBehaviorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonQueryWrapperBehaviorContext {
	var p = new(JsonQueryWrapperBehaviorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonQueryWrapperBehavior

	return p
}

func (s *JsonQueryWrapperBehaviorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonQueryWrapperBehaviorContext) WITHOUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITHOUT_, 0)
}

func (s *JsonQueryWrapperBehaviorContext) ARRAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserARRAY_, 0)
}

func (s *JsonQueryWrapperBehaviorContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *JsonQueryWrapperBehaviorContext) CONDITIONAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCONDITIONAL_, 0)
}

func (s *JsonQueryWrapperBehaviorContext) UNCONDITIONAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNCONDITIONAL_, 0)
}

func (s *JsonQueryWrapperBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonQueryWrapperBehaviorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonQueryWrapperBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonQueryWrapperBehavior(s)
	}
}

func (s *JsonQueryWrapperBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonQueryWrapperBehavior(s)
	}
}

func (s *JsonQueryWrapperBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonQueryWrapperBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonQueryWrapperBehavior() (localctx IJsonQueryWrapperBehaviorContext) {
	localctx = NewJsonQueryWrapperBehaviorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, TrinoParserRULE_jsonQueryWrapperBehavior)
	var _la int

	p.SetState(2550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserWITHOUT_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2539)
			p.Match(TrinoParserWITHOUT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserARRAY_ {
			{
				p.SetState(2540)
				p.Match(TrinoParserARRAY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TrinoParserWITH_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2543)
			p.Match(TrinoParserWITH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserCONDITIONAL_ || _la == TrinoParserUNCONDITIONAL_ {
			{
				p.SetState(2544)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TrinoParserCONDITIONAL_ || _la == TrinoParserUNCONDITIONAL_) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserARRAY_ {
			{
				p.SetState(2547)
				p.Match(TrinoParserARRAY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonQueryBehaviorContext is an interface to support dynamic dispatch.
type IJsonQueryBehaviorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR_() antlr.TerminalNode
	NULL_() antlr.TerminalNode
	EMPTY_() antlr.TerminalNode
	ARRAY_() antlr.TerminalNode
	OBJECT_() antlr.TerminalNode

	// IsJsonQueryBehaviorContext differentiates from other interfaces.
	IsJsonQueryBehaviorContext()
}

type JsonQueryBehaviorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonQueryBehaviorContext() *JsonQueryBehaviorContext {
	var p = new(JsonQueryBehaviorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonQueryBehavior
	return p
}

func InitEmptyJsonQueryBehaviorContext(p *JsonQueryBehaviorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonQueryBehavior
}

func (*JsonQueryBehaviorContext) IsJsonQueryBehaviorContext() {}

func NewJsonQueryBehaviorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonQueryBehaviorContext {
	var p = new(JsonQueryBehaviorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonQueryBehavior

	return p
}

func (s *JsonQueryBehaviorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonQueryBehaviorContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *JsonQueryBehaviorContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *JsonQueryBehaviorContext) EMPTY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEMPTY_, 0)
}

func (s *JsonQueryBehaviorContext) ARRAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserARRAY_, 0)
}

func (s *JsonQueryBehaviorContext) OBJECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOBJECT_, 0)
}

func (s *JsonQueryBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonQueryBehaviorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonQueryBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonQueryBehavior(s)
	}
}

func (s *JsonQueryBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonQueryBehavior(s)
	}
}

func (s *JsonQueryBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonQueryBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonQueryBehavior() (localctx IJsonQueryBehaviorContext) {
	localctx = NewJsonQueryBehaviorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, TrinoParserRULE_jsonQueryBehavior)
	var _la int

	p.SetState(2556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserERROR_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2552)
			p.Match(TrinoParserERROR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserNULL_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2553)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserEMPTY_:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2554)
			p.Match(TrinoParserEMPTY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2555)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserARRAY_ || _la == TrinoParserOBJECT_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonObjectMemberContext is an interface to support dynamic dispatch.
type IJsonObjectMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	VALUE_() antlr.TerminalNode
	JsonValueExpression() IJsonValueExpressionContext
	KEY_() antlr.TerminalNode
	COLON_() antlr.TerminalNode

	// IsJsonObjectMemberContext differentiates from other interfaces.
	IsJsonObjectMemberContext()
}

type JsonObjectMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonObjectMemberContext() *JsonObjectMemberContext {
	var p = new(JsonObjectMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonObjectMember
	return p
}

func InitEmptyJsonObjectMemberContext(p *JsonObjectMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_jsonObjectMember
}

func (*JsonObjectMemberContext) IsJsonObjectMemberContext() {}

func NewJsonObjectMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonObjectMemberContext {
	var p = new(JsonObjectMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_jsonObjectMember

	return p
}

func (s *JsonObjectMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonObjectMemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JsonObjectMemberContext) VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVALUE_, 0)
}

func (s *JsonObjectMemberContext) JsonValueExpression() IJsonValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueExpressionContext)
}

func (s *JsonObjectMemberContext) KEY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserKEY_, 0)
}

func (s *JsonObjectMemberContext) COLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLON_, 0)
}

func (s *JsonObjectMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonObjectMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonObjectMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterJsonObjectMember(s)
	}
}

func (s *JsonObjectMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitJsonObjectMember(s)
	}
}

func (s *JsonObjectMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitJsonObjectMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) JsonObjectMember() (localctx IJsonObjectMemberContext) {
	localctx = NewJsonObjectMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, TrinoParserRULE_jsonObjectMember)
	p.SetState(2569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 342, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2559)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2558)
				p.Match(TrinoParserKEY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2561)
			p.Expression()
		}
		{
			p.SetState(2562)
			p.Match(TrinoParserVALUE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2563)
			p.JsonValueExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2565)
			p.Expression()
		}
		{
			p.SetState(2566)
			p.Match(TrinoParserCOLON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2567)
			p.JsonValueExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcessingModeContext is an interface to support dynamic dispatch.
type IProcessingModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RUNNING_() antlr.TerminalNode
	FINAL_() antlr.TerminalNode

	// IsProcessingModeContext differentiates from other interfaces.
	IsProcessingModeContext()
}

type ProcessingModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcessingModeContext() *ProcessingModeContext {
	var p = new(ProcessingModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_processingMode
	return p
}

func InitEmptyProcessingModeContext(p *ProcessingModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_processingMode
}

func (*ProcessingModeContext) IsProcessingModeContext() {}

func NewProcessingModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcessingModeContext {
	var p = new(ProcessingModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_processingMode

	return p
}

func (s *ProcessingModeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcessingModeContext) RUNNING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRUNNING_, 0)
}

func (s *ProcessingModeContext) FINAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFINAL_, 0)
}

func (s *ProcessingModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcessingModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcessingModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterProcessingMode(s)
	}
}

func (s *ProcessingModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitProcessingMode(s)
	}
}

func (s *ProcessingModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitProcessingMode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ProcessingMode() (localctx IProcessingModeContext) {
	localctx = NewProcessingModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, TrinoParserRULE_processingMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2571)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserFINAL_ || _la == TrinoParserRUNNING_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullTreatmentContext is an interface to support dynamic dispatch.
type INullTreatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE_() antlr.TerminalNode
	NULLS_() antlr.TerminalNode
	RESPECT_() antlr.TerminalNode

	// IsNullTreatmentContext differentiates from other interfaces.
	IsNullTreatmentContext()
}

type NullTreatmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullTreatmentContext() *NullTreatmentContext {
	var p = new(NullTreatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_nullTreatment
	return p
}

func InitEmptyNullTreatmentContext(p *NullTreatmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_nullTreatment
}

func (*NullTreatmentContext) IsNullTreatmentContext() {}

func NewNullTreatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullTreatmentContext {
	var p = new(NullTreatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_nullTreatment

	return p
}

func (s *NullTreatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *NullTreatmentContext) IGNORE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIGNORE_, 0)
}

func (s *NullTreatmentContext) NULLS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULLS_, 0)
}

func (s *NullTreatmentContext) RESPECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESPECT_, 0)
}

func (s *NullTreatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullTreatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullTreatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNullTreatment(s)
	}
}

func (s *NullTreatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNullTreatment(s)
	}
}

func (s *NullTreatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNullTreatment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) NullTreatment() (localctx INullTreatmentContext) {
	localctx = NewNullTreatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, TrinoParserRULE_nullTreatment)
	p.SetState(2577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserIGNORE_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2573)
			p.Match(TrinoParserIGNORE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2574)
			p.Match(TrinoParserNULLS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserRESPECT_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2575)
			p.Match(TrinoParserRESPECT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2576)
			p.Match(TrinoParserNULLS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IString_Context is an interface to support dynamic dispatch.
type IString_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsString_Context differentiates from other interfaces.
	IsString_Context()
}

type String_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_Context() *String_Context {
	var p = new(String_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_string_
	return p
}

func InitEmptyString_Context(p *String_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_string_
}

func (*String_Context) IsString_Context() {}

func NewString_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_Context {
	var p = new(String_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_string_

	return p
}

func (s *String_Context) GetParser() antlr.Parser { return s.parser }

func (s *String_Context) CopyAll(ctx *String_Context) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *String_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnicodeStringLiteralContext struct {
	String_Context
}

func NewUnicodeStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnicodeStringLiteralContext {
	var p = new(UnicodeStringLiteralContext)

	InitEmptyString_Context(&p.String_Context)
	p.parser = parser
	p.CopyAll(ctx.(*String_Context))

	return p
}

func (s *UnicodeStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeStringLiteralContext) UNICODE_STRING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNICODE_STRING_, 0)
}

func (s *UnicodeStringLiteralContext) UESCAPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUESCAPE_, 0)
}

func (s *UnicodeStringLiteralContext) STRING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSTRING_, 0)
}

func (s *UnicodeStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUnicodeStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BasicStringLiteralContext struct {
	String_Context
}

func NewBasicStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BasicStringLiteralContext {
	var p = new(BasicStringLiteralContext)

	InitEmptyString_Context(&p.String_Context)
	p.parser = parser
	p.CopyAll(ctx.(*String_Context))

	return p
}

func (s *BasicStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicStringLiteralContext) STRING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSTRING_, 0)
}

func (s *BasicStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitBasicStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) String_() (localctx IString_Context) {
	localctx = NewString_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, TrinoParserRULE_string_)
	p.SetState(2585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserSTRING_:
		localctx = NewBasicStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2579)
			p.Match(TrinoParserSTRING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserUNICODE_STRING_:
		localctx = NewUnicodeStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2580)
			p.Match(TrinoParserUNICODE_STRING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2583)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2581)
				p.Match(TrinoParserUESCAPE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2582)
				p.Match(TrinoParserSTRING_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_timeZoneSpecifier
	return p
}

func InitEmptyTimeZoneSpecifierContext(p *TimeZoneSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_timeZoneSpecifier
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyAll(ctx *TimeZoneSpecifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneIntervalContext struct {
	TimeZoneSpecifierContext
}

func NewTimeZoneIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneIntervalContext {
	var p = new(TimeZoneIntervalContext)

	InitEmptyTimeZoneSpecifierContext(&p.TimeZoneSpecifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneIntervalContext) TIME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIME_, 0)
}

func (s *TimeZoneIntervalContext) ZONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserZONE_, 0)
}

func (s *TimeZoneIntervalContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *TimeZoneIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTimeZoneInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

type TimeZoneStringContext struct {
	TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	InitEmptyTimeZoneSpecifierContext(&p.TimeZoneSpecifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIME_, 0)
}

func (s *TimeZoneStringContext) ZONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserZONE_, 0)
}

func (s *TimeZoneStringContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTimeZoneString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, TrinoParserRULE_timeZoneSpecifier)
	p.SetState(2593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTimeZoneIntervalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2587)
			p.Match(TrinoParserTIME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2588)
			p.Match(TrinoParserZONE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2589)
			p.Interval()
		}

	case 2:
		localctx = NewTimeZoneStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2590)
			p.Match(TrinoParserTIME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2591)
			p.Match(TrinoParserZONE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2592)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ_() antlr.TerminalNode
	NEQ_() antlr.TerminalNode
	LT_() antlr.TerminalNode
	LTE_() antlr.TerminalNode
	GT_() antlr.TerminalNode
	GTE_() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEQ_, 0)
}

func (s *ComparisonOperatorContext) NEQ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNEQ_, 0)
}

func (s *ComparisonOperatorContext) LT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLT_, 0)
}

func (s *ComparisonOperatorContext) LTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLTE_, 0)
}

func (s *ComparisonOperatorContext) GT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGT_, 0)
}

func (s *ComparisonOperatorContext) GTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGTE_, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, TrinoParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2595)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-296)) & ^0x3f) == 0 && ((int64(1)<<(_la-296))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonQuantifierContext is an interface to support dynamic dispatch.
type IComparisonQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_() antlr.TerminalNode
	SOME_() antlr.TerminalNode
	ANY_() antlr.TerminalNode

	// IsComparisonQuantifierContext differentiates from other interfaces.
	IsComparisonQuantifierContext()
}

type ComparisonQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonQuantifierContext() *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_comparisonQuantifier
	return p
}

func InitEmptyComparisonQuantifierContext(p *ComparisonQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_comparisonQuantifier
}

func (*ComparisonQuantifierContext) IsComparisonQuantifierContext() {}

func NewComparisonQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_comparisonQuantifier

	return p
}

func (s *ComparisonQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonQuantifierContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *ComparisonQuantifierContext) SOME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSOME_, 0)
}

func (s *ComparisonQuantifierContext) ANY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserANY_, 0)
}

func (s *ComparisonQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitComparisonQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ComparisonQuantifier() (localctx IComparisonQuantifierContext) {
	localctx = NewComparisonQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, TrinoParserRULE_comparisonQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2597)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserALL_ || _la == TrinoParserANY_ || _la == TrinoParserSOME_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE_() antlr.TerminalNode
	FALSE_() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRUE_, 0)
}

func (s *BooleanValueContext) FALSE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFALSE_, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, TrinoParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2599)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserFALSE_ || _la == TrinoParserTRUE_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// Getter signatures
	INTERVAL_() antlr.TerminalNode
	String_() IString_Context
	AllIntervalField() []IIntervalFieldContext
	IntervalField(i int) IIntervalFieldContext
	TO_() antlr.TerminalNode
	PLUS_() antlr.TerminalNode
	MINUS_() antlr.TerminalNode

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	sign   antlr.Token
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetSign() antlr.Token { return s.sign }

func (s *IntervalContext) SetSign(v antlr.Token) { s.sign = v }

func (s *IntervalContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalContext) INTERVAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTERVAL_, 0)
}

func (s *IntervalContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *IntervalContext) AllIntervalField() []IIntervalFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			len++
		}
	}

	tst := make([]IIntervalFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalFieldContext); ok {
			tst[i] = t.(IIntervalFieldContext)
			i++
		}
	}

	return tst
}

func (s *IntervalContext) IntervalField(i int) IIntervalFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *IntervalContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPLUS_, 0)
}

func (s *IntervalContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUS_, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, TrinoParserRULE_interval)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2601)
		p.Match(TrinoParserINTERVAL_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserPLUS_ || _la == TrinoParserMINUS_ {
		{
			p.SetState(2602)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntervalContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserPLUS_ || _la == TrinoParserMINUS_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntervalContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2605)
		p.String_()
	}
	{
		p.SetState(2606)

		var _x = p.IntervalField()

		localctx.(*IntervalContext).from = _x
	}
	p.SetState(2609)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2607)
			p.Match(TrinoParserTO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2608)

			var _x = p.IntervalField()

			localctx.(*IntervalContext).to = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalFieldContext is an interface to support dynamic dispatch.
type IIntervalFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR_() antlr.TerminalNode
	MONTH_() antlr.TerminalNode
	DAY_() antlr.TerminalNode
	HOUR_() antlr.TerminalNode
	MINUTE_() antlr.TerminalNode
	SECOND_() antlr.TerminalNode

	// IsIntervalFieldContext differentiates from other interfaces.
	IsIntervalFieldContext()
}

type IntervalFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalFieldContext() *IntervalFieldContext {
	var p = new(IntervalFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_intervalField
	return p
}

func InitEmptyIntervalFieldContext(p *IntervalFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_intervalField
}

func (*IntervalFieldContext) IsIntervalFieldContext() {}

func NewIntervalFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalFieldContext {
	var p = new(IntervalFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_intervalField

	return p
}

func (s *IntervalFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalFieldContext) YEAR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserYEAR_, 0)
}

func (s *IntervalFieldContext) MONTH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMONTH_, 0)
}

func (s *IntervalFieldContext) DAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDAY_, 0)
}

func (s *IntervalFieldContext) HOUR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserHOUR_, 0)
}

func (s *IntervalFieldContext) MINUTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUTE_, 0)
}

func (s *IntervalFieldContext) SECOND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSECOND_, 0)
}

func (s *IntervalFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIntervalField(s)
	}
}

func (s *IntervalFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIntervalField(s)
	}
}

func (s *IntervalFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIntervalField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) IntervalField() (localctx IIntervalFieldContext) {
	localctx = NewIntervalFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, TrinoParserRULE_intervalField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2611)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserDAY_ || ((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&13510798882111489) != 0) || _la == TrinoParserSECOND_ || _la == TrinoParserYEAR_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalFormContext is an interface to support dynamic dispatch.
type INormalFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NFD_() antlr.TerminalNode
	NFC_() antlr.TerminalNode
	NFKD_() antlr.TerminalNode
	NFKC_() antlr.TerminalNode

	// IsNormalFormContext differentiates from other interfaces.
	IsNormalFormContext()
}

type NormalFormContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormContext() *NormalFormContext {
	var p = new(NormalFormContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_normalForm
	return p
}

func InitEmptyNormalFormContext(p *NormalFormContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_normalForm
}

func (*NormalFormContext) IsNormalFormContext() {}

func NewNormalFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormContext {
	var p = new(NormalFormContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_normalForm

	return p
}

func (s *NormalFormContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormContext) NFD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFD_, 0)
}

func (s *NormalFormContext) NFC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFC_, 0)
}

func (s *NormalFormContext) NFKD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFKD_, 0)
}

func (s *NormalFormContext) NFKC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFKC_, 0)
}

func (s *NormalFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNormalForm(s)
	}
}

func (s *NormalFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNormalForm(s)
	}
}

func (s *NormalFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNormalForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) NormalForm() (localctx INormalFormContext) {
	localctx = NewNormalFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, TrinoParserRULE_normalForm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2613)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-158)) & ^0x3f) == 0 && ((int64(1)<<(_la-158))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) CopyAll(ctx *TypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RowTypeContext struct {
	TypeContext
}

func NewRowTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowTypeContext {
	var p = new(RowTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *RowTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowTypeContext) ROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROW_, 0)
}

func (s *RowTypeContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *RowTypeContext) AllRowField() []IRowFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowFieldContext); ok {
			len++
		}
	}

	tst := make([]IRowFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowFieldContext); ok {
			tst[i] = t.(IRowFieldContext)
			i++
		}
	}

	return tst
}

func (s *RowTypeContext) RowField(i int) IRowFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFieldContext)
}

func (s *RowTypeContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *RowTypeContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *RowTypeContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *RowTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRowType(s)
	}
}

func (s *RowTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRowType(s)
	}
}

func (s *RowTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRowType(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalTypeContext struct {
	TypeContext
	from IIntervalFieldContext
	to   IIntervalFieldContext
}

func NewIntervalTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *IntervalTypeContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalTypeContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalTypeContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalTypeContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) INTERVAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTERVAL_, 0)
}

func (s *IntervalTypeContext) AllIntervalField() []IIntervalFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			len++
		}
	}

	tst := make([]IIntervalFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalFieldContext); ok {
			tst[i] = t.(IIntervalFieldContext)
			i++
		}
	}

	return tst
}

func (s *IntervalTypeContext) IntervalField(i int) IIntervalFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalTypeContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (s *IntervalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIntervalType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayTypeContext struct {
	TypeContext
}

func NewArrayTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) ARRAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserARRAY_, 0)
}

func (s *ArrayTypeContext) LSQUARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLSQUARE_, 0)
}

func (s *ArrayTypeContext) INTEGER_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTEGER_VALUE_, 0)
}

func (s *ArrayTypeContext) RSQUARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRSQUARE_, 0)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoublePrecisionTypeContext struct {
	TypeContext
}

func NewDoublePrecisionTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoublePrecisionTypeContext {
	var p = new(DoublePrecisionTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *DoublePrecisionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoublePrecisionTypeContext) DOUBLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOUBLE_, 0)
}

func (s *DoublePrecisionTypeContext) PRECISION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRECISION_, 0)
}

func (s *DoublePrecisionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDoublePrecisionType(s)
	}
}

func (s *DoublePrecisionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDoublePrecisionType(s)
	}
}

func (s *DoublePrecisionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDoublePrecisionType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LegacyArrayTypeContext struct {
	TypeContext
}

func NewLegacyArrayTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LegacyArrayTypeContext {
	var p = new(LegacyArrayTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *LegacyArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyArrayTypeContext) ARRAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserARRAY_, 0)
}

func (s *LegacyArrayTypeContext) LT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLT_, 0)
}

func (s *LegacyArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LegacyArrayTypeContext) GT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGT_, 0)
}

func (s *LegacyArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLegacyArrayType(s)
	}
}

func (s *LegacyArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLegacyArrayType(s)
	}
}

func (s *LegacyArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLegacyArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

type GenericTypeContext struct {
	TypeContext
}

func NewGenericTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GenericTypeContext {
	var p = new(GenericTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *GenericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GenericTypeContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *GenericTypeContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *GenericTypeContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *GenericTypeContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *GenericTypeContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *GenericTypeContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *GenericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterGenericType(s)
	}
}

func (s *GenericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitGenericType(s)
	}
}

func (s *GenericTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitGenericType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DateTimeTypeContext struct {
	TypeContext
	base_     antlr.Token
	precision ITypeParameterContext
}

func NewDateTimeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateTimeTypeContext {
	var p = new(DateTimeTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *DateTimeTypeContext) GetBase_() antlr.Token { return s.base_ }

func (s *DateTimeTypeContext) SetBase_(v antlr.Token) { s.base_ = v }

func (s *DateTimeTypeContext) GetPrecision() ITypeParameterContext { return s.precision }

func (s *DateTimeTypeContext) SetPrecision(v ITypeParameterContext) { s.precision = v }

func (s *DateTimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeTypeContext) TIMESTAMP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIMESTAMP_, 0)
}

func (s *DateTimeTypeContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *DateTimeTypeContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *DateTimeTypeContext) WITHOUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITHOUT_, 0)
}

func (s *DateTimeTypeContext) AllTIME_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserTIME_)
}

func (s *DateTimeTypeContext) TIME_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserTIME_, i)
}

func (s *DateTimeTypeContext) ZONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserZONE_, 0)
}

func (s *DateTimeTypeContext) TypeParameter() ITypeParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *DateTimeTypeContext) WITH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITH_, 0)
}

func (s *DateTimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDateTimeType(s)
	}
}

func (s *DateTimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDateTimeType(s)
	}
}

func (s *DateTimeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDateTimeType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LegacyMapTypeContext struct {
	TypeContext
	keyType   ITypeContext
	valueType ITypeContext
}

func NewLegacyMapTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LegacyMapTypeContext {
	var p = new(LegacyMapTypeContext)

	InitEmptyTypeContext(&p.TypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeContext))

	return p
}

func (s *LegacyMapTypeContext) GetKeyType() ITypeContext { return s.keyType }

func (s *LegacyMapTypeContext) GetValueType() ITypeContext { return s.valueType }

func (s *LegacyMapTypeContext) SetKeyType(v ITypeContext) { s.keyType = v }

func (s *LegacyMapTypeContext) SetValueType(v ITypeContext) { s.valueType = v }

func (s *LegacyMapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyMapTypeContext) MAP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMAP_, 0)
}

func (s *LegacyMapTypeContext) LT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLT_, 0)
}

func (s *LegacyMapTypeContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, 0)
}

func (s *LegacyMapTypeContext) GT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGT_, 0)
}

func (s *LegacyMapTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *LegacyMapTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LegacyMapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLegacyMapType(s)
	}
}

func (s *LegacyMapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLegacyMapType(s)
	}
}

func (s *LegacyMapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLegacyMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Type_() (localctx ITypeContext) {
	return p.type_(0)
}

func (p *TrinoParser) type_(_p int) (localctx ITypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 168
	p.EnterRecursionRule(localctx, 168, TrinoParserRULE_type, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRowTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(2616)
			p.Match(TrinoParserROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2617)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2618)
			p.RowField()
		}
		p.SetState(2623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2619)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2620)
				p.RowField()
			}

			p.SetState(2625)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2626)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewIntervalTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2628)
			p.Match(TrinoParserINTERVAL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2629)

			var _x = p.IntervalField()

			localctx.(*IntervalTypeContext).from = _x
		}
		p.SetState(2632)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2630)
				p.Match(TrinoParserTO_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2631)

				var _x = p.IntervalField()

				localctx.(*IntervalTypeContext).to = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2634)

			var _m = p.Match(TrinoParserTIMESTAMP_)

			localctx.(*DateTimeTypeContext).base_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2639)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2635)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2636)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(2637)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2644)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2641)
				p.Match(TrinoParserWITHOUT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2642)
				p.Match(TrinoParserTIME_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2643)
				p.Match(TrinoParserZONE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2646)

			var _m = p.Match(TrinoParserTIMESTAMP_)

			localctx.(*DateTimeTypeContext).base_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLPAREN_ {
			{
				p.SetState(2647)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2648)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(2649)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2653)
			p.Match(TrinoParserWITH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2654)
			p.Match(TrinoParserTIME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2655)
			p.Match(TrinoParserZONE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2656)

			var _m = p.Match(TrinoParserTIME_)

			localctx.(*DateTimeTypeContext).base_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2661)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2657)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2658)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(2659)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2666)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2663)
				p.Match(TrinoParserWITHOUT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2664)
				p.Match(TrinoParserTIME_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2665)
				p.Match(TrinoParserZONE_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2668)

			var _m = p.Match(TrinoParserTIME_)

			localctx.(*DateTimeTypeContext).base_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLPAREN_ {
			{
				p.SetState(2669)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2670)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(2671)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2675)
			p.Match(TrinoParserWITH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2676)
			p.Match(TrinoParserTIME_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2677)
			p.Match(TrinoParserZONE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewDoublePrecisionTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2678)
			p.Match(TrinoParserDOUBLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2679)
			p.Match(TrinoParserPRECISION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewLegacyArrayTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2680)
			p.Match(TrinoParserARRAY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2681)
			p.Match(TrinoParserLT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2682)
			p.type_(0)
		}
		{
			p.SetState(2683)
			p.Match(TrinoParserGT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewLegacyMapTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2685)
			p.Match(TrinoParserMAP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2686)
			p.Match(TrinoParserLT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2687)

			var _x = p.type_(0)

			localctx.(*LegacyMapTypeContext).keyType = _x
		}
		{
			p.SetState(2688)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2689)

			var _x = p.type_(0)

			localctx.(*LegacyMapTypeContext).valueType = _x
		}
		{
			p.SetState(2690)
			p.Match(TrinoParserGT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewGenericTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2692)
			p.Identifier()
		}
		p.SetState(2704)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2693)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2694)
				p.TypeParameter()
			}
			p.SetState(2699)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2695)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2696)
					p.TypeParameter()
				}

				p.SetState(2701)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2702)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewArrayTypeContext(p, NewTypeContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_type)
			p.SetState(2708)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(2709)
				p.Match(TrinoParserARRAY_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2713)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2710)
					p.Match(TrinoParserLSQUARE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2711)
					p.Match(TrinoParserINTEGER_VALUE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2712)
					p.Match(TrinoParserRSQUARE_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(2719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowFieldContext is an interface to support dynamic dispatch.
type IRowFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	Identifier() IIdentifierContext

	// IsRowFieldContext differentiates from other interfaces.
	IsRowFieldContext()
}

type RowFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowFieldContext() *RowFieldContext {
	var p = new(RowFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowField
	return p
}

func InitEmptyRowFieldContext(p *RowFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowField
}

func (*RowFieldContext) IsRowFieldContext() {}

func NewRowFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFieldContext {
	var p = new(RowFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_rowField

	return p
}

func (s *RowFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFieldContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *RowFieldContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RowFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRowField(s)
	}
}

func (s *RowFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRowField(s)
	}
}

func (s *RowFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRowField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RowField() (localctx IRowFieldContext) {
	localctx = NewRowFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, TrinoParserRULE_rowField)
	p.SetState(2724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2720)
			p.type_(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2721)
			p.Identifier()
		}
		{
			p.SetState(2722)
			p.type_(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE_() antlr.TerminalNode
	Type_() ITypeContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTEGER_VALUE_, 0)
}

func (s *TypeParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, TrinoParserRULE_typeParameter)
	p.SetState(2728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserINTEGER_VALUE_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2726)
			p.Match(TrinoParserINTEGER_VALUE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserABSENT_, TrinoParserADD_, TrinoParserADMIN_, TrinoParserAFTER_, TrinoParserALL_, TrinoParserANALYZE_, TrinoParserANY_, TrinoParserARRAY_, TrinoParserASC_, TrinoParserAT_, TrinoParserAUTHORIZATION_, TrinoParserBEGIN_, TrinoParserBERNOULLI_, TrinoParserBOTH_, TrinoParserCALL_, TrinoParserCALLED_, TrinoParserCASCADE_, TrinoParserCATALOG_, TrinoParserCATALOGS_, TrinoParserCOLUMN_, TrinoParserCOLUMNS_, TrinoParserCOMMENT_, TrinoParserCOMMIT_, TrinoParserCOMMITTED_, TrinoParserCONDITIONAL_, TrinoParserCOUNT_, TrinoParserCOPARTITION_, TrinoParserCURRENT_, TrinoParserDATA_, TrinoParserDATE_, TrinoParserDAY_, TrinoParserDECLARE_, TrinoParserDEFAULT_, TrinoParserDEFINE_, TrinoParserDEFINER_, TrinoParserDENY_, TrinoParserDESC_, TrinoParserDESCRIPTOR_, TrinoParserDETERMINISTIC_, TrinoParserDISTRIBUTED_, TrinoParserDO_, TrinoParserDOUBLE_, TrinoParserEMPTY_, TrinoParserELSEIF_, TrinoParserENCODING_, TrinoParserERROR_, TrinoParserEXCLUDING_, TrinoParserEXPLAIN_, TrinoParserFETCH_, TrinoParserFILTER_, TrinoParserFINAL_, TrinoParserFIRST_, TrinoParserFOLLOWING_, TrinoParserFORMAT_, TrinoParserFUNCTION_, TrinoParserFUNCTIONS_, TrinoParserGRACE_, TrinoParserGRANT_, TrinoParserGRANTED_, TrinoParserGRANTS_, TrinoParserGRAPHVIZ_, TrinoParserGROUPS_, TrinoParserHOUR_, TrinoParserIF_, TrinoParserIGNORE_, TrinoParserIMMEDIATE_, TrinoParserINCLUDING_, TrinoParserINITIAL_, TrinoParserINPUT_, TrinoParserINTERVAL_, TrinoParserINVOKER_, TrinoParserIO_, TrinoParserISOLATION_, TrinoParserITERATE_, TrinoParserJSON_, TrinoParserKEEP_, TrinoParserKEY_, TrinoParserKEYS_, TrinoParserLANGUAGE_, TrinoParserLAST_, TrinoParserLATERAL_, TrinoParserLEADING_, TrinoParserLEAVE_, TrinoParserLEVEL_, TrinoParserLIMIT_, TrinoParserLOCAL_, TrinoParserLOGICAL_, TrinoParserLOOP_, TrinoParserMAP_, TrinoParserMATCH_, TrinoParserMATCHED_, TrinoParserMATCHES_, TrinoParserMATCH_RECOGNIZE_, TrinoParserMATERIALIZED_, TrinoParserMEASURES_, TrinoParserMERGE_, TrinoParserMINUTE_, TrinoParserMONTH_, TrinoParserNESTED_, TrinoParserNEXT_, TrinoParserNFC_, TrinoParserNFD_, TrinoParserNFKC_, TrinoParserNFKD_, TrinoParserNO_, TrinoParserNONE_, TrinoParserNULLIF_, TrinoParserNULLS_, TrinoParserOBJECT_, TrinoParserOF_, TrinoParserOFFSET_, TrinoParserOMIT_, TrinoParserONE_, TrinoParserONLY_, TrinoParserOPTION_, TrinoParserORDINALITY_, TrinoParserOUTPUT_, TrinoParserOVER_, TrinoParserOVERFLOW_, TrinoParserPARTITION_, TrinoParserPARTITIONS_, TrinoParserPASSING_, TrinoParserPAST_, TrinoParserPATH_, TrinoParserPATTERN_, TrinoParserPER_, TrinoParserPERIOD_, TrinoParserPERMUTE_, TrinoParserPLAN_, TrinoParserPOSITION_, TrinoParserPRECEDING_, TrinoParserPRECISION_, TrinoParserPRIVILEGES_, TrinoParserPROPERTIES_, TrinoParserPRUNE_, TrinoParserQUOTES_, TrinoParserRANGE_, TrinoParserREAD_, TrinoParserREFRESH_, TrinoParserRENAME_, TrinoParserREPEAT_, TrinoParserREPEATABLE_, TrinoParserREPLACE_, TrinoParserRESET_, TrinoParserRESPECT_, TrinoParserRESTRICT_, TrinoParserRETURN_, TrinoParserRETURNING_, TrinoParserRETURNS_, TrinoParserREVOKE_, TrinoParserROLE_, TrinoParserROLES_, TrinoParserROLLBACK_, TrinoParserROW_, TrinoParserROWS_, TrinoParserRUNNING_, TrinoParserSCALAR_, TrinoParserSCHEMA_, TrinoParserSCHEMAS_, TrinoParserSECOND_, TrinoParserSECURITY_, TrinoParserSEEK_, TrinoParserSERIALIZABLE_, TrinoParserSESSION_, TrinoParserSET_, TrinoParserSETS_, TrinoParserSHOW_, TrinoParserSOME_, TrinoParserSTART_, TrinoParserSTATS_, TrinoParserSUBSET_, TrinoParserSUBSTRING_, TrinoParserSYSTEM_, TrinoParserTABLES_, TrinoParserTABLESAMPLE_, TrinoParserTEXT_, TrinoParserTEXT_STRING_, TrinoParserTIES_, TrinoParserTIME_, TrinoParserTIMESTAMP_, TrinoParserTO_, TrinoParserTRAILING_, TrinoParserTRANSACTION_, TrinoParserTRUNCATE_, TrinoParserTRY_CAST_, TrinoParserTYPE_, TrinoParserUNBOUNDED_, TrinoParserUNCOMMITTED_, TrinoParserUNCONDITIONAL_, TrinoParserUNIQUE_, TrinoParserUNKNOWN_, TrinoParserUNMATCHED_, TrinoParserUNTIL_, TrinoParserUPDATE_, TrinoParserUSE_, TrinoParserUSER_, TrinoParserUTF16_, TrinoParserUTF32_, TrinoParserUTF8_, TrinoParserVALIDATE_, TrinoParserVALUE_, TrinoParserVERBOSE_, TrinoParserVERSION_, TrinoParserVIEW_, TrinoParserWHILE_, TrinoParserWINDOW_, TrinoParserWITHIN_, TrinoParserWITHOUT_, TrinoParserWORK_, TrinoParserWRAPPER_, TrinoParserWRITE_, TrinoParserYEAR_, TrinoParserZONE_, TrinoParserIDENTIFIER_, TrinoParserDIGIT_IDENTIFIER_, TrinoParserQUOTED_IDENTIFIER_, TrinoParserBACKQUOTED_IDENTIFIER_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2727)
			p.type_(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN_() antlr.TerminalNode
	THEN_() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHEN_, 0)
}

func (s *WhenClauseContext) THEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTHEN_, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, TrinoParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2730)
		p.Match(TrinoParserWHEN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2731)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(2732)
		p.Match(TrinoParserTHEN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2733)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterContext is an interface to support dynamic dispatch.
type IFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILTER_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	WHERE_() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	RPAREN_() antlr.TerminalNode

	// IsFilterContext differentiates from other interfaces.
	IsFilterContext()
}

type FilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterContext() *FilterContext {
	var p = new(FilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_filter
	return p
}

func InitEmptyFilterContext(p *FilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_filter
}

func (*FilterContext) IsFilterContext() {}

func NewFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterContext {
	var p = new(FilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_filter

	return p
}

func (s *FilterContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterContext) FILTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFILTER_, 0)
}

func (s *FilterContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *FilterContext) WHERE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHERE_, 0)
}

func (s *FilterContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (s *FilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Filter() (localctx IFilterContext) {
	localctx = NewFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, TrinoParserRULE_filter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2735)
		p.Match(TrinoParserFILTER_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2736)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2737)
		p.Match(TrinoParserWHERE_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2738)
		p.booleanExpression(0)
	}
	{
		p.SetState(2739)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeCaseContext is an interface to support dynamic dispatch.
type IMergeCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMergeCaseContext differentiates from other interfaces.
	IsMergeCaseContext()
}

type MergeCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCaseContext() *MergeCaseContext {
	var p = new(MergeCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_mergeCase
	return p
}

func InitEmptyMergeCaseContext(p *MergeCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_mergeCase
}

func (*MergeCaseContext) IsMergeCaseContext() {}

func NewMergeCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCaseContext {
	var p = new(MergeCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_mergeCase

	return p
}

func (s *MergeCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCaseContext) CopyAll(ctx *MergeCaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MergeCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MergeInsertContext struct {
	MergeCaseContext
	condition   IExpressionContext
	_identifier IIdentifierContext
	targets     []IIdentifierContext
	_expression IExpressionContext
	values      []IExpressionContext
}

func NewMergeInsertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MergeInsertContext {
	var p = new(MergeInsertContext)

	InitEmptyMergeCaseContext(&p.MergeCaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*MergeCaseContext))

	return p
}

func (s *MergeInsertContext) GetCondition() IExpressionContext { return s.condition }

func (s *MergeInsertContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *MergeInsertContext) Get_expression() IExpressionContext { return s._expression }

func (s *MergeInsertContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *MergeInsertContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *MergeInsertContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *MergeInsertContext) GetTargets() []IIdentifierContext { return s.targets }

func (s *MergeInsertContext) GetValues() []IExpressionContext { return s.values }

func (s *MergeInsertContext) SetTargets(v []IIdentifierContext) { s.targets = v }

func (s *MergeInsertContext) SetValues(v []IExpressionContext) { s.values = v }

func (s *MergeInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeInsertContext) WHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHEN_, 0)
}

func (s *MergeInsertContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *MergeInsertContext) MATCHED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCHED_, 0)
}

func (s *MergeInsertContext) THEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTHEN_, 0)
}

func (s *MergeInsertContext) INSERT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINSERT_, 0)
}

func (s *MergeInsertContext) VALUES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVALUES_, 0)
}

func (s *MergeInsertContext) AllLPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserLPAREN_)
}

func (s *MergeInsertContext) LPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, i)
}

func (s *MergeInsertContext) AllRPAREN_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserRPAREN_)
}

func (s *MergeInsertContext) RPAREN_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, i)
}

func (s *MergeInsertContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MergeInsertContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeInsertContext) AND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAND_, 0)
}

func (s *MergeInsertContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *MergeInsertContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *MergeInsertContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MergeInsertContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MergeInsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterMergeInsert(s)
	}
}

func (s *MergeInsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitMergeInsert(s)
	}
}

func (s *MergeInsertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitMergeInsert(s)

	default:
		return t.VisitChildren(s)
	}
}

type MergeUpdateContext struct {
	MergeCaseContext
	condition   IExpressionContext
	_identifier IIdentifierContext
	targets     []IIdentifierContext
	_expression IExpressionContext
	values      []IExpressionContext
}

func NewMergeUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MergeUpdateContext {
	var p = new(MergeUpdateContext)

	InitEmptyMergeCaseContext(&p.MergeCaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*MergeCaseContext))

	return p
}

func (s *MergeUpdateContext) GetCondition() IExpressionContext { return s.condition }

func (s *MergeUpdateContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *MergeUpdateContext) Get_expression() IExpressionContext { return s._expression }

func (s *MergeUpdateContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *MergeUpdateContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *MergeUpdateContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *MergeUpdateContext) GetTargets() []IIdentifierContext { return s.targets }

func (s *MergeUpdateContext) GetValues() []IExpressionContext { return s.values }

func (s *MergeUpdateContext) SetTargets(v []IIdentifierContext) { s.targets = v }

func (s *MergeUpdateContext) SetValues(v []IExpressionContext) { s.values = v }

func (s *MergeUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeUpdateContext) WHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHEN_, 0)
}

func (s *MergeUpdateContext) MATCHED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCHED_, 0)
}

func (s *MergeUpdateContext) THEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTHEN_, 0)
}

func (s *MergeUpdateContext) UPDATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUPDATE_, 0)
}

func (s *MergeUpdateContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *MergeUpdateContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserEQ_)
}

func (s *MergeUpdateContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserEQ_, i)
}

func (s *MergeUpdateContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MergeUpdateContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MergeUpdateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MergeUpdateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeUpdateContext) AND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAND_, 0)
}

func (s *MergeUpdateContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *MergeUpdateContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *MergeUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterMergeUpdate(s)
	}
}

func (s *MergeUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitMergeUpdate(s)
	}
}

func (s *MergeUpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitMergeUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

type MergeDeleteContext struct {
	MergeCaseContext
	condition IExpressionContext
}

func NewMergeDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MergeDeleteContext {
	var p = new(MergeDeleteContext)

	InitEmptyMergeCaseContext(&p.MergeCaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*MergeCaseContext))

	return p
}

func (s *MergeDeleteContext) GetCondition() IExpressionContext { return s.condition }

func (s *MergeDeleteContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *MergeDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeDeleteContext) WHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHEN_, 0)
}

func (s *MergeDeleteContext) MATCHED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCHED_, 0)
}

func (s *MergeDeleteContext) THEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTHEN_, 0)
}

func (s *MergeDeleteContext) DELETE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDELETE_, 0)
}

func (s *MergeDeleteContext) AND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAND_, 0)
}

func (s *MergeDeleteContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterMergeDelete(s)
	}
}

func (s *MergeDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitMergeDelete(s)
	}
}

func (s *MergeDeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitMergeDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) MergeCase() (localctx IMergeCaseContext) {
	localctx = NewMergeCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, TrinoParserRULE_mergeCase)
	var _la int

	p.SetState(2805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 371, p.GetParserRuleContext()) {
	case 1:
		localctx = NewMergeUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2741)
			p.Match(TrinoParserWHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2742)
			p.Match(TrinoParserMATCHED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserAND_ {
			{
				p.SetState(2743)
				p.Match(TrinoParserAND_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2744)

				var _x = p.Expression()

				localctx.(*MergeUpdateContext).condition = _x
			}

		}
		{
			p.SetState(2747)
			p.Match(TrinoParserTHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2748)
			p.Match(TrinoParserUPDATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2749)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)

			var _x = p.Identifier()

			localctx.(*MergeUpdateContext)._identifier = _x
		}
		localctx.(*MergeUpdateContext).targets = append(localctx.(*MergeUpdateContext).targets, localctx.(*MergeUpdateContext)._identifier)
		{
			p.SetState(2751)
			p.Match(TrinoParserEQ_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2752)

			var _x = p.Expression()

			localctx.(*MergeUpdateContext)._expression = _x
		}
		localctx.(*MergeUpdateContext).values = append(localctx.(*MergeUpdateContext).values, localctx.(*MergeUpdateContext)._expression)
		p.SetState(2760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2753)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2754)

				var _x = p.Identifier()

				localctx.(*MergeUpdateContext)._identifier = _x
			}
			localctx.(*MergeUpdateContext).targets = append(localctx.(*MergeUpdateContext).targets, localctx.(*MergeUpdateContext)._identifier)
			{
				p.SetState(2755)
				p.Match(TrinoParserEQ_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2756)

				var _x = p.Expression()

				localctx.(*MergeUpdateContext)._expression = _x
			}
			localctx.(*MergeUpdateContext).values = append(localctx.(*MergeUpdateContext).values, localctx.(*MergeUpdateContext)._expression)

			p.SetState(2762)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewMergeDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2763)
			p.Match(TrinoParserWHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2764)
			p.Match(TrinoParserMATCHED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserAND_ {
			{
				p.SetState(2765)
				p.Match(TrinoParserAND_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2766)

				var _x = p.Expression()

				localctx.(*MergeDeleteContext).condition = _x
			}

		}
		{
			p.SetState(2769)
			p.Match(TrinoParserTHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2770)
			p.Match(TrinoParserDELETE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewMergeInsertContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2771)
			p.Match(TrinoParserWHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2772)
			p.Match(TrinoParserNOT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2773)
			p.Match(TrinoParserMATCHED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserAND_ {
			{
				p.SetState(2774)
				p.Match(TrinoParserAND_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2775)

				var _x = p.Expression()

				localctx.(*MergeInsertContext).condition = _x
			}

		}
		{
			p.SetState(2778)
			p.Match(TrinoParserTHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2779)
			p.Match(TrinoParserINSERT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserLPAREN_ {
			{
				p.SetState(2780)
				p.Match(TrinoParserLPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2781)

				var _x = p.Identifier()

				localctx.(*MergeInsertContext)._identifier = _x
			}
			localctx.(*MergeInsertContext).targets = append(localctx.(*MergeInsertContext).targets, localctx.(*MergeInsertContext)._identifier)
			p.SetState(2786)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TrinoParserCOMMA_ {
				{
					p.SetState(2782)
					p.Match(TrinoParserCOMMA_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2783)

					var _x = p.Identifier()

					localctx.(*MergeInsertContext)._identifier = _x
				}
				localctx.(*MergeInsertContext).targets = append(localctx.(*MergeInsertContext).targets, localctx.(*MergeInsertContext)._identifier)

				p.SetState(2788)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2789)
				p.Match(TrinoParserRPAREN_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2793)
			p.Match(TrinoParserVALUES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2794)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2795)

			var _x = p.Expression()

			localctx.(*MergeInsertContext)._expression = _x
		}
		localctx.(*MergeInsertContext).values = append(localctx.(*MergeInsertContext).values, localctx.(*MergeInsertContext)._expression)
		p.SetState(2800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2796)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2797)

				var _x = p.Expression()

				localctx.(*MergeInsertContext)._expression = _x
			}
			localctx.(*MergeInsertContext).values = append(localctx.(*MergeInsertContext).values, localctx.(*MergeInsertContext)._expression)

			p.SetState(2802)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2803)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWindowName returns the windowName rule contexts.
	GetWindowName() IIdentifierContext

	// SetWindowName sets the windowName rule contexts.
	SetWindowName(IIdentifierContext)

	// Getter signatures
	OVER_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	WindowSpecification() IWindowSpecificationContext
	RPAREN_() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	windowName IIdentifierContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_over
	return p
}

func InitEmptyOverContext(p *OverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_over
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) GetWindowName() IIdentifierContext { return s.windowName }

func (s *OverContext) SetWindowName(v IIdentifierContext) { s.windowName = v }

func (s *OverContext) OVER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOVER_, 0)
}

func (s *OverContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *OverContext) WindowSpecification() IWindowSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecificationContext)
}

func (s *OverContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *OverContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitOver(s)
	}
}

func (s *OverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitOver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, TrinoParserRULE_over)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2807)
		p.Match(TrinoParserOVER_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserABSENT_, TrinoParserADD_, TrinoParserADMIN_, TrinoParserAFTER_, TrinoParserALL_, TrinoParserANALYZE_, TrinoParserANY_, TrinoParserARRAY_, TrinoParserASC_, TrinoParserAT_, TrinoParserAUTHORIZATION_, TrinoParserBEGIN_, TrinoParserBERNOULLI_, TrinoParserBOTH_, TrinoParserCALL_, TrinoParserCALLED_, TrinoParserCASCADE_, TrinoParserCATALOG_, TrinoParserCATALOGS_, TrinoParserCOLUMN_, TrinoParserCOLUMNS_, TrinoParserCOMMENT_, TrinoParserCOMMIT_, TrinoParserCOMMITTED_, TrinoParserCONDITIONAL_, TrinoParserCOUNT_, TrinoParserCOPARTITION_, TrinoParserCURRENT_, TrinoParserDATA_, TrinoParserDATE_, TrinoParserDAY_, TrinoParserDECLARE_, TrinoParserDEFAULT_, TrinoParserDEFINE_, TrinoParserDEFINER_, TrinoParserDENY_, TrinoParserDESC_, TrinoParserDESCRIPTOR_, TrinoParserDETERMINISTIC_, TrinoParserDISTRIBUTED_, TrinoParserDO_, TrinoParserDOUBLE_, TrinoParserEMPTY_, TrinoParserELSEIF_, TrinoParserENCODING_, TrinoParserERROR_, TrinoParserEXCLUDING_, TrinoParserEXPLAIN_, TrinoParserFETCH_, TrinoParserFILTER_, TrinoParserFINAL_, TrinoParserFIRST_, TrinoParserFOLLOWING_, TrinoParserFORMAT_, TrinoParserFUNCTION_, TrinoParserFUNCTIONS_, TrinoParserGRACE_, TrinoParserGRANT_, TrinoParserGRANTED_, TrinoParserGRANTS_, TrinoParserGRAPHVIZ_, TrinoParserGROUPS_, TrinoParserHOUR_, TrinoParserIF_, TrinoParserIGNORE_, TrinoParserIMMEDIATE_, TrinoParserINCLUDING_, TrinoParserINITIAL_, TrinoParserINPUT_, TrinoParserINTERVAL_, TrinoParserINVOKER_, TrinoParserIO_, TrinoParserISOLATION_, TrinoParserITERATE_, TrinoParserJSON_, TrinoParserKEEP_, TrinoParserKEY_, TrinoParserKEYS_, TrinoParserLANGUAGE_, TrinoParserLAST_, TrinoParserLATERAL_, TrinoParserLEADING_, TrinoParserLEAVE_, TrinoParserLEVEL_, TrinoParserLIMIT_, TrinoParserLOCAL_, TrinoParserLOGICAL_, TrinoParserLOOP_, TrinoParserMAP_, TrinoParserMATCH_, TrinoParserMATCHED_, TrinoParserMATCHES_, TrinoParserMATCH_RECOGNIZE_, TrinoParserMATERIALIZED_, TrinoParserMEASURES_, TrinoParserMERGE_, TrinoParserMINUTE_, TrinoParserMONTH_, TrinoParserNESTED_, TrinoParserNEXT_, TrinoParserNFC_, TrinoParserNFD_, TrinoParserNFKC_, TrinoParserNFKD_, TrinoParserNO_, TrinoParserNONE_, TrinoParserNULLIF_, TrinoParserNULLS_, TrinoParserOBJECT_, TrinoParserOF_, TrinoParserOFFSET_, TrinoParserOMIT_, TrinoParserONE_, TrinoParserONLY_, TrinoParserOPTION_, TrinoParserORDINALITY_, TrinoParserOUTPUT_, TrinoParserOVER_, TrinoParserOVERFLOW_, TrinoParserPARTITION_, TrinoParserPARTITIONS_, TrinoParserPASSING_, TrinoParserPAST_, TrinoParserPATH_, TrinoParserPATTERN_, TrinoParserPER_, TrinoParserPERIOD_, TrinoParserPERMUTE_, TrinoParserPLAN_, TrinoParserPOSITION_, TrinoParserPRECEDING_, TrinoParserPRECISION_, TrinoParserPRIVILEGES_, TrinoParserPROPERTIES_, TrinoParserPRUNE_, TrinoParserQUOTES_, TrinoParserRANGE_, TrinoParserREAD_, TrinoParserREFRESH_, TrinoParserRENAME_, TrinoParserREPEAT_, TrinoParserREPEATABLE_, TrinoParserREPLACE_, TrinoParserRESET_, TrinoParserRESPECT_, TrinoParserRESTRICT_, TrinoParserRETURN_, TrinoParserRETURNING_, TrinoParserRETURNS_, TrinoParserREVOKE_, TrinoParserROLE_, TrinoParserROLES_, TrinoParserROLLBACK_, TrinoParserROW_, TrinoParserROWS_, TrinoParserRUNNING_, TrinoParserSCALAR_, TrinoParserSCHEMA_, TrinoParserSCHEMAS_, TrinoParserSECOND_, TrinoParserSECURITY_, TrinoParserSEEK_, TrinoParserSERIALIZABLE_, TrinoParserSESSION_, TrinoParserSET_, TrinoParserSETS_, TrinoParserSHOW_, TrinoParserSOME_, TrinoParserSTART_, TrinoParserSTATS_, TrinoParserSUBSET_, TrinoParserSUBSTRING_, TrinoParserSYSTEM_, TrinoParserTABLES_, TrinoParserTABLESAMPLE_, TrinoParserTEXT_, TrinoParserTEXT_STRING_, TrinoParserTIES_, TrinoParserTIME_, TrinoParserTIMESTAMP_, TrinoParserTO_, TrinoParserTRAILING_, TrinoParserTRANSACTION_, TrinoParserTRUNCATE_, TrinoParserTRY_CAST_, TrinoParserTYPE_, TrinoParserUNBOUNDED_, TrinoParserUNCOMMITTED_, TrinoParserUNCONDITIONAL_, TrinoParserUNIQUE_, TrinoParserUNKNOWN_, TrinoParserUNMATCHED_, TrinoParserUNTIL_, TrinoParserUPDATE_, TrinoParserUSE_, TrinoParserUSER_, TrinoParserUTF16_, TrinoParserUTF32_, TrinoParserUTF8_, TrinoParserVALIDATE_, TrinoParserVALUE_, TrinoParserVERBOSE_, TrinoParserVERSION_, TrinoParserVIEW_, TrinoParserWHILE_, TrinoParserWINDOW_, TrinoParserWITHIN_, TrinoParserWITHOUT_, TrinoParserWORK_, TrinoParserWRAPPER_, TrinoParserWRITE_, TrinoParserYEAR_, TrinoParserZONE_, TrinoParserIDENTIFIER_, TrinoParserDIGIT_IDENTIFIER_, TrinoParserQUOTED_IDENTIFIER_, TrinoParserBACKQUOTED_IDENTIFIER_:
		{
			p.SetState(2808)

			var _x = p.Identifier()

			localctx.(*OverContext).windowName = _x
		}

	case TrinoParserLPAREN_:
		{
			p.SetState(2809)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2810)
			p.WindowSpecification()
		}
		{
			p.SetState(2811)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameExtent() IFrameExtentContext
	MEASURES_() antlr.TerminalNode
	AllMeasureDefinition() []IMeasureDefinitionContext
	MeasureDefinition(i int) IMeasureDefinitionContext
	AFTER_() antlr.TerminalNode
	MATCH_() antlr.TerminalNode
	SkipTo() ISkipToContext
	PATTERN_() antlr.TerminalNode
	LPAREN_() antlr.TerminalNode
	RowPattern() IRowPatternContext
	RPAREN_() antlr.TerminalNode
	SUBSET_() antlr.TerminalNode
	AllSubsetDefinition() []ISubsetDefinitionContext
	SubsetDefinition(i int) ISubsetDefinitionContext
	DEFINE_() antlr.TerminalNode
	AllVariableDefinition() []IVariableDefinitionContext
	VariableDefinition(i int) IVariableDefinitionContext
	INITIAL_() antlr.TerminalNode
	SEEK_() antlr.TerminalNode
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) FrameExtent() IFrameExtentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameExtentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameExtentContext)
}

func (s *WindowFrameContext) MEASURES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMEASURES_, 0)
}

func (s *WindowFrameContext) AllMeasureDefinition() []IMeasureDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMeasureDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IMeasureDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMeasureDefinitionContext); ok {
			tst[i] = t.(IMeasureDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) MeasureDefinition(i int) IMeasureDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureDefinitionContext)
}

func (s *WindowFrameContext) AFTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAFTER_, 0)
}

func (s *WindowFrameContext) MATCH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCH_, 0)
}

func (s *WindowFrameContext) SkipTo() ISkipToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipToContext)
}

func (s *WindowFrameContext) PATTERN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPATTERN_, 0)
}

func (s *WindowFrameContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *WindowFrameContext) RowPattern() IRowPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *WindowFrameContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *WindowFrameContext) SUBSET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSUBSET_, 0)
}

func (s *WindowFrameContext) AllSubsetDefinition() []ISubsetDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubsetDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubsetDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubsetDefinitionContext); ok {
			tst[i] = t.(ISubsetDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) SubsetDefinition(i int) ISubsetDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsetDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsetDefinitionContext)
}

func (s *WindowFrameContext) DEFINE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFINE_, 0)
}

func (s *WindowFrameContext) AllVariableDefinition() []IVariableDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IVariableDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDefinitionContext); ok {
			tst[i] = t.(IVariableDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) VariableDefinition(i int) IVariableDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDefinitionContext)
}

func (s *WindowFrameContext) INITIAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINITIAL_, 0)
}

func (s *WindowFrameContext) SEEK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEEK_, 0)
}

func (s *WindowFrameContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *WindowFrameContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (s *WindowFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitWindowFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, TrinoParserRULE_windowFrame)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserMEASURES_ {
		{
			p.SetState(2815)
			p.Match(TrinoParserMEASURES_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2816)
			p.MeasureDefinition()
		}
		p.SetState(2821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2817)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2818)
				p.MeasureDefinition()
			}

			p.SetState(2823)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2826)
		p.FrameExtent()
	}
	p.SetState(2830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserAFTER_ {
		{
			p.SetState(2827)
			p.Match(TrinoParserAFTER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2828)
			p.Match(TrinoParserMATCH_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2829)
			p.SkipTo()
		}

	}
	p.SetState(2833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserINITIAL_ || _la == TrinoParserSEEK_ {
		{
			p.SetState(2832)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserINITIAL_ || _la == TrinoParserSEEK_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserPATTERN_ {
		{
			p.SetState(2835)
			p.Match(TrinoParserPATTERN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2836)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2837)
			p.rowPattern(0)
		}
		{
			p.SetState(2838)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserSUBSET_ {
		{
			p.SetState(2842)
			p.Match(TrinoParserSUBSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2843)
			p.SubsetDefinition()
		}
		p.SetState(2848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2844)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2845)
				p.SubsetDefinition()
			}

			p.SetState(2850)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserDEFINE_ {
		{
			p.SetState(2853)
			p.Match(TrinoParserDEFINE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2854)
			p.VariableDefinition()
		}
		p.SetState(2859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2855)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2856)
				p.VariableDefinition()
			}

			p.SetState(2861)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameExtentContext is an interface to support dynamic dispatch.
type IFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundContext

	// GetEnd_ returns the end_ rule contexts.
	GetEnd_() IFrameBoundContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundContext)

	// SetEnd_ sets the end_ rule contexts.
	SetEnd_(IFrameBoundContext)

	// Getter signatures
	RANGE_() antlr.TerminalNode
	AllFrameBound() []IFrameBoundContext
	FrameBound(i int) IFrameBoundContext
	ROWS_() antlr.TerminalNode
	GROUPS_() antlr.TerminalNode
	BETWEEN_() antlr.TerminalNode
	AND_() antlr.TerminalNode

	// IsFrameExtentContext differentiates from other interfaces.
	IsFrameExtentContext()
}

type FrameExtentContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start_    IFrameBoundContext
	end_      IFrameBoundContext
}

func NewEmptyFrameExtentContext() *FrameExtentContext {
	var p = new(FrameExtentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_frameExtent
	return p
}

func InitEmptyFrameExtentContext(p *FrameExtentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_frameExtent
}

func (*FrameExtentContext) IsFrameExtentContext() {}

func NewFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameExtentContext {
	var p = new(FrameExtentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_frameExtent

	return p
}

func (s *FrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameExtentContext) GetFrameType() antlr.Token { return s.frameType }

func (s *FrameExtentContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *FrameExtentContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *FrameExtentContext) GetEnd_() IFrameBoundContext { return s.end_ }

func (s *FrameExtentContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *FrameExtentContext) SetEnd_(v IFrameBoundContext) { s.end_ = v }

func (s *FrameExtentContext) RANGE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRANGE_, 0)
}

func (s *FrameExtentContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *FrameExtentContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *FrameExtentContext) ROWS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROWS_, 0)
}

func (s *FrameExtentContext) GROUPS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGROUPS_, 0)
}

func (s *FrameExtentContext) BETWEEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBETWEEN_, 0)
}

func (s *FrameExtentContext) AND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAND_, 0)
}

func (s *FrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterFrameExtent(s)
	}
}

func (s *FrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitFrameExtent(s)
	}
}

func (s *FrameExtentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitFrameExtent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) FrameExtent() (localctx IFrameExtentContext) {
	localctx = NewFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, TrinoParserRULE_frameExtent)
	p.SetState(2888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2864)

			var _m = p.Match(TrinoParserRANGE_)

			localctx.(*FrameExtentContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2865)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2866)

			var _m = p.Match(TrinoParserROWS_)

			localctx.(*FrameExtentContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2867)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).start_ = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2868)

			var _m = p.Match(TrinoParserGROUPS_)

			localctx.(*FrameExtentContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2869)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).start_ = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2870)

			var _m = p.Match(TrinoParserRANGE_)

			localctx.(*FrameExtentContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2871)
			p.Match(TrinoParserBETWEEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2872)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).start_ = _x
		}
		{
			p.SetState(2873)
			p.Match(TrinoParserAND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2874)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).end_ = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2876)

			var _m = p.Match(TrinoParserROWS_)

			localctx.(*FrameExtentContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2877)
			p.Match(TrinoParserBETWEEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2878)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).start_ = _x
		}
		{
			p.SetState(2879)
			p.Match(TrinoParserAND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2880)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).end_ = _x
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2882)

			var _m = p.Match(TrinoParserGROUPS_)

			localctx.(*FrameExtentContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2883)
			p.Match(TrinoParserBETWEEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2884)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).start_ = _x
		}
		{
			p.SetState(2885)
			p.Match(TrinoParserAND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2886)

			var _x = p.FrameBound()

			localctx.(*FrameExtentContext).end_ = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyAll(ctx *FrameBoundContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRECEDING_, 0)
}

func (s *BoundedFrameContext) FOLLOWING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOLLOWING_, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitBoundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnboundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNBOUNDED_, 0)
}

func (s *UnboundedFrameContext) PRECEDING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRECEDING_, 0)
}

func (s *UnboundedFrameContext) FOLLOWING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOLLOWING_, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUnboundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentRowBoundContext struct {
	FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_, 0)
}

func (s *CurrentRowBoundContext) ROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROW_, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCurrentRowBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, TrinoParserRULE_frameBound)
	var _la int

	p.SetState(2899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2890)
			p.Match(TrinoParserUNBOUNDED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2891)

			var _m = p.Match(TrinoParserPRECEDING_)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2892)
			p.Match(TrinoParserUNBOUNDED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2893)

			var _m = p.Match(TrinoParserFOLLOWING_)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2894)
			p.Match(TrinoParserCURRENT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2895)
			p.Match(TrinoParserROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2896)
			p.Expression()
		}
		{
			p.SetState(2897)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserFOLLOWING_ || _la == TrinoParserPRECEDING_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowPatternContext is an interface to support dynamic dispatch.
type IRowPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRowPatternContext differentiates from other interfaces.
	IsRowPatternContext()
}

type RowPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowPatternContext() *RowPatternContext {
	var p = new(RowPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowPattern
	return p
}

func InitEmptyRowPatternContext(p *RowPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rowPattern
}

func (*RowPatternContext) IsRowPatternContext() {}

func NewRowPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowPatternContext {
	var p = new(RowPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_rowPattern

	return p
}

func (s *RowPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RowPatternContext) CopyAll(ctx *RowPatternContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RowPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuantifiedPrimaryContext struct {
	RowPatternContext
}

func NewQuantifiedPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedPrimaryContext {
	var p = new(QuantifiedPrimaryContext)

	InitEmptyRowPatternContext(&p.RowPatternContext)
	p.parser = parser
	p.CopyAll(ctx.(*RowPatternContext))

	return p
}

func (s *QuantifiedPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedPrimaryContext) PatternPrimary() IPatternPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternPrimaryContext)
}

func (s *QuantifiedPrimaryContext) PatternQuantifier() IPatternQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternQuantifierContext)
}

func (s *QuantifiedPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQuantifiedPrimary(s)
	}
}

func (s *QuantifiedPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQuantifiedPrimary(s)
	}
}

func (s *QuantifiedPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQuantifiedPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type PatternConcatenationContext struct {
	RowPatternContext
}

func NewPatternConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PatternConcatenationContext {
	var p = new(PatternConcatenationContext)

	InitEmptyRowPatternContext(&p.RowPatternContext)
	p.parser = parser
	p.CopyAll(ctx.(*RowPatternContext))

	return p
}

func (s *PatternConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternConcatenationContext) AllRowPattern() []IRowPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowPatternContext); ok {
			len++
		}
	}

	tst := make([]IRowPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowPatternContext); ok {
			tst[i] = t.(IRowPatternContext)
			i++
		}
	}

	return tst
}

func (s *PatternConcatenationContext) RowPattern(i int) IRowPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *PatternConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPatternConcatenation(s)
	}
}

func (s *PatternConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPatternConcatenation(s)
	}
}

func (s *PatternConcatenationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPatternConcatenation(s)

	default:
		return t.VisitChildren(s)
	}
}

type PatternAlternationContext struct {
	RowPatternContext
}

func NewPatternAlternationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PatternAlternationContext {
	var p = new(PatternAlternationContext)

	InitEmptyRowPatternContext(&p.RowPatternContext)
	p.parser = parser
	p.CopyAll(ctx.(*RowPatternContext))

	return p
}

func (s *PatternAlternationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternAlternationContext) AllRowPattern() []IRowPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowPatternContext); ok {
			len++
		}
	}

	tst := make([]IRowPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowPatternContext); ok {
			tst[i] = t.(IRowPatternContext)
			i++
		}
	}

	return tst
}

func (s *PatternAlternationContext) RowPattern(i int) IRowPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *PatternAlternationContext) VBAR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVBAR_, 0)
}

func (s *PatternAlternationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPatternAlternation(s)
	}
}

func (s *PatternAlternationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPatternAlternation(s)
	}
}

func (s *PatternAlternationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPatternAlternation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RowPattern() (localctx IRowPatternContext) {
	return p.rowPattern(0)
}

func (p *TrinoParser) rowPattern(_p int) (localctx IRowPatternContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRowPatternContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRowPatternContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 188
	p.EnterRecursionRule(localctx, 188, TrinoParserRULE_rowPattern, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQuantifiedPrimaryContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(2902)
		p.PatternPrimary()
	}
	p.SetState(2904)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2903)
			p.PatternQuantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPatternConcatenationContext(p, NewRowPatternContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_rowPattern)
				p.SetState(2906)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2907)
					p.rowPattern(3)
				}

			case 2:
				localctx = NewPatternAlternationContext(p, NewRowPatternContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TrinoParserRULE_rowPattern)
				p.SetState(2908)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2909)
					p.Match(TrinoParserVBAR_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2910)
					p.rowPattern(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternPrimaryContext is an interface to support dynamic dispatch.
type IPatternPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPatternPrimaryContext differentiates from other interfaces.
	IsPatternPrimaryContext()
}

type PatternPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternPrimaryContext() *PatternPrimaryContext {
	var p = new(PatternPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_patternPrimary
	return p
}

func InitEmptyPatternPrimaryContext(p *PatternPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_patternPrimary
}

func (*PatternPrimaryContext) IsPatternPrimaryContext() {}

func NewPatternPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternPrimaryContext {
	var p = new(PatternPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_patternPrimary

	return p
}

func (s *PatternPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternPrimaryContext) CopyAll(ctx *PatternPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PatternPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PatternPermutationContext struct {
	PatternPrimaryContext
}

func NewPatternPermutationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PatternPermutationContext {
	var p = new(PatternPermutationContext)

	InitEmptyPatternPrimaryContext(&p.PatternPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternPrimaryContext))

	return p
}

func (s *PatternPermutationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternPermutationContext) PERMUTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPERMUTE_, 0)
}

func (s *PatternPermutationContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *PatternPermutationContext) AllRowPattern() []IRowPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowPatternContext); ok {
			len++
		}
	}

	tst := make([]IRowPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowPatternContext); ok {
			tst[i] = t.(IRowPatternContext)
			i++
		}
	}

	return tst
}

func (s *PatternPermutationContext) RowPattern(i int) IRowPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *PatternPermutationContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *PatternPermutationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *PatternPermutationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *PatternPermutationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPatternPermutation(s)
	}
}

func (s *PatternPermutationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPatternPermutation(s)
	}
}

func (s *PatternPermutationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPatternPermutation(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionEndAnchorContext struct {
	PatternPrimaryContext
}

func NewPartitionEndAnchorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionEndAnchorContext {
	var p = new(PartitionEndAnchorContext)

	InitEmptyPatternPrimaryContext(&p.PatternPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternPrimaryContext))

	return p
}

func (s *PartitionEndAnchorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionEndAnchorContext) DOLLAR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOLLAR_, 0)
}

func (s *PartitionEndAnchorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPartitionEndAnchor(s)
	}
}

func (s *PartitionEndAnchorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPartitionEndAnchor(s)
	}
}

func (s *PartitionEndAnchorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPartitionEndAnchor(s)

	default:
		return t.VisitChildren(s)
	}
}

type PatternVariableContext struct {
	PatternPrimaryContext
}

func NewPatternVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PatternVariableContext {
	var p = new(PatternVariableContext)

	InitEmptyPatternPrimaryContext(&p.PatternPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternPrimaryContext))

	return p
}

func (s *PatternVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PatternVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPatternVariable(s)
	}
}

func (s *PatternVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPatternVariable(s)
	}
}

func (s *PatternVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPatternVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExcludedPatternContext struct {
	PatternPrimaryContext
}

func NewExcludedPatternContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExcludedPatternContext {
	var p = new(ExcludedPatternContext)

	InitEmptyPatternPrimaryContext(&p.PatternPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternPrimaryContext))

	return p
}

func (s *ExcludedPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExcludedPatternContext) LCURLYHYPHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLCURLYHYPHEN_, 0)
}

func (s *ExcludedPatternContext) RowPattern() IRowPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *ExcludedPatternContext) RCURLYHYPHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRCURLYHYPHEN_, 0)
}

func (s *ExcludedPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExcludedPattern(s)
	}
}

func (s *ExcludedPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExcludedPattern(s)
	}
}

func (s *ExcludedPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExcludedPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionStartAnchorContext struct {
	PatternPrimaryContext
}

func NewPartitionStartAnchorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionStartAnchorContext {
	var p = new(PartitionStartAnchorContext)

	InitEmptyPatternPrimaryContext(&p.PatternPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternPrimaryContext))

	return p
}

func (s *PartitionStartAnchorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionStartAnchorContext) CARET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCARET_, 0)
}

func (s *PartitionStartAnchorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPartitionStartAnchor(s)
	}
}

func (s *PartitionStartAnchorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPartitionStartAnchor(s)
	}
}

func (s *PartitionStartAnchorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPartitionStartAnchor(s)

	default:
		return t.VisitChildren(s)
	}
}

type EmptyPatternContext struct {
	PatternPrimaryContext
}

func NewEmptyPatternContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EmptyPatternContext {
	var p = new(EmptyPatternContext)

	InitEmptyPatternPrimaryContext(&p.PatternPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternPrimaryContext))

	return p
}

func (s *EmptyPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyPatternContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *EmptyPatternContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *EmptyPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterEmptyPattern(s)
	}
}

func (s *EmptyPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitEmptyPattern(s)
	}
}

func (s *EmptyPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitEmptyPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupedPatternContext struct {
	PatternPrimaryContext
}

func NewGroupedPatternContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupedPatternContext {
	var p = new(GroupedPatternContext)

	InitEmptyPatternPrimaryContext(&p.PatternPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternPrimaryContext))

	return p
}

func (s *GroupedPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupedPatternContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *GroupedPatternContext) RowPattern() IRowPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowPatternContext)
}

func (s *GroupedPatternContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *GroupedPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterGroupedPattern(s)
	}
}

func (s *GroupedPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitGroupedPattern(s)
	}
}

func (s *GroupedPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitGroupedPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PatternPrimary() (localctx IPatternPrimaryContext) {
	localctx = NewPatternPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, TrinoParserRULE_patternPrimary)
	var _la int

	p.SetState(2941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPatternVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2916)
			p.Identifier()
		}

	case 2:
		localctx = NewEmptyPatternContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2917)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2918)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPatternPermutationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2919)
			p.Match(TrinoParserPERMUTE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2920)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2921)
			p.rowPattern(0)
		}
		p.SetState(2926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(2922)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2923)
				p.rowPattern(0)
			}

			p.SetState(2928)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2929)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewGroupedPatternContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2931)
			p.Match(TrinoParserLPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2932)
			p.rowPattern(0)
		}
		{
			p.SetState(2933)
			p.Match(TrinoParserRPAREN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPartitionStartAnchorContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2935)
			p.Match(TrinoParserCARET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewPartitionEndAnchorContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2936)
			p.Match(TrinoParserDOLLAR_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewExcludedPatternContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2937)
			p.Match(TrinoParserLCURLYHYPHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2938)
			p.rowPattern(0)
		}
		{
			p.SetState(2939)
			p.Match(TrinoParserRCURLYHYPHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternQuantifierContext is an interface to support dynamic dispatch.
type IPatternQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPatternQuantifierContext differentiates from other interfaces.
	IsPatternQuantifierContext()
}

type PatternQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternQuantifierContext() *PatternQuantifierContext {
	var p = new(PatternQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_patternQuantifier
	return p
}

func InitEmptyPatternQuantifierContext(p *PatternQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_patternQuantifier
}

func (*PatternQuantifierContext) IsPatternQuantifierContext() {}

func NewPatternQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternQuantifierContext {
	var p = new(PatternQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_patternQuantifier

	return p
}

func (s *PatternQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternQuantifierContext) CopyAll(ctx *PatternQuantifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PatternQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ZeroOrMoreQuantifierContext struct {
	PatternQuantifierContext
	reluctant antlr.Token
}

func NewZeroOrMoreQuantifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ZeroOrMoreQuantifierContext {
	var p = new(ZeroOrMoreQuantifierContext)

	InitEmptyPatternQuantifierContext(&p.PatternQuantifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternQuantifierContext))

	return p
}

func (s *ZeroOrMoreQuantifierContext) GetReluctant() antlr.Token { return s.reluctant }

func (s *ZeroOrMoreQuantifierContext) SetReluctant(v antlr.Token) { s.reluctant = v }

func (s *ZeroOrMoreQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ZeroOrMoreQuantifierContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserASTERISK_, 0)
}

func (s *ZeroOrMoreQuantifierContext) QUESTION_MARK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUESTION_MARK_, 0)
}

func (s *ZeroOrMoreQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterZeroOrMoreQuantifier(s)
	}
}

func (s *ZeroOrMoreQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitZeroOrMoreQuantifier(s)
	}
}

func (s *ZeroOrMoreQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitZeroOrMoreQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type OneOrMoreQuantifierContext struct {
	PatternQuantifierContext
	reluctant antlr.Token
}

func NewOneOrMoreQuantifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OneOrMoreQuantifierContext {
	var p = new(OneOrMoreQuantifierContext)

	InitEmptyPatternQuantifierContext(&p.PatternQuantifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternQuantifierContext))

	return p
}

func (s *OneOrMoreQuantifierContext) GetReluctant() antlr.Token { return s.reluctant }

func (s *OneOrMoreQuantifierContext) SetReluctant(v antlr.Token) { s.reluctant = v }

func (s *OneOrMoreQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OneOrMoreQuantifierContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPLUS_, 0)
}

func (s *OneOrMoreQuantifierContext) QUESTION_MARK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUESTION_MARK_, 0)
}

func (s *OneOrMoreQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterOneOrMoreQuantifier(s)
	}
}

func (s *OneOrMoreQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitOneOrMoreQuantifier(s)
	}
}

func (s *OneOrMoreQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitOneOrMoreQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type ZeroOrOneQuantifierContext struct {
	PatternQuantifierContext
	reluctant antlr.Token
}

func NewZeroOrOneQuantifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ZeroOrOneQuantifierContext {
	var p = new(ZeroOrOneQuantifierContext)

	InitEmptyPatternQuantifierContext(&p.PatternQuantifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternQuantifierContext))

	return p
}

func (s *ZeroOrOneQuantifierContext) GetReluctant() antlr.Token { return s.reluctant }

func (s *ZeroOrOneQuantifierContext) SetReluctant(v antlr.Token) { s.reluctant = v }

func (s *ZeroOrOneQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ZeroOrOneQuantifierContext) AllQUESTION_MARK_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserQUESTION_MARK_)
}

func (s *ZeroOrOneQuantifierContext) QUESTION_MARK_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserQUESTION_MARK_, i)
}

func (s *ZeroOrOneQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterZeroOrOneQuantifier(s)
	}
}

func (s *ZeroOrOneQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitZeroOrOneQuantifier(s)
	}
}

func (s *ZeroOrOneQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitZeroOrOneQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type RangeQuantifierContext struct {
	PatternQuantifierContext
	exactly   antlr.Token
	reluctant antlr.Token
	atLeast   antlr.Token
	atMost    antlr.Token
}

func NewRangeQuantifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RangeQuantifierContext {
	var p = new(RangeQuantifierContext)

	InitEmptyPatternQuantifierContext(&p.PatternQuantifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*PatternQuantifierContext))

	return p
}

func (s *RangeQuantifierContext) GetExactly() antlr.Token { return s.exactly }

func (s *RangeQuantifierContext) GetReluctant() antlr.Token { return s.reluctant }

func (s *RangeQuantifierContext) GetAtLeast() antlr.Token { return s.atLeast }

func (s *RangeQuantifierContext) GetAtMost() antlr.Token { return s.atMost }

func (s *RangeQuantifierContext) SetExactly(v antlr.Token) { s.exactly = v }

func (s *RangeQuantifierContext) SetReluctant(v antlr.Token) { s.reluctant = v }

func (s *RangeQuantifierContext) SetAtLeast(v antlr.Token) { s.atLeast = v }

func (s *RangeQuantifierContext) SetAtMost(v antlr.Token) { s.atMost = v }

func (s *RangeQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeQuantifierContext) LCURLY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLCURLY_, 0)
}

func (s *RangeQuantifierContext) RCURLY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRCURLY_, 0)
}

func (s *RangeQuantifierContext) AllINTEGER_VALUE_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserINTEGER_VALUE_)
}

func (s *RangeQuantifierContext) INTEGER_VALUE_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserINTEGER_VALUE_, i)
}

func (s *RangeQuantifierContext) QUESTION_MARK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUESTION_MARK_, 0)
}

func (s *RangeQuantifierContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, 0)
}

func (s *RangeQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRangeQuantifier(s)
	}
}

func (s *RangeQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRangeQuantifier(s)
	}
}

func (s *RangeQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRangeQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PatternQuantifier() (localctx IPatternQuantifierContext) {
	localctx = NewPatternQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, TrinoParserRULE_patternQuantifier)
	var _la int

	p.SetState(2973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext()) {
	case 1:
		localctx = NewZeroOrMoreQuantifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2943)
			p.Match(TrinoParserASTERISK_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2945)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2944)

				var _m = p.Match(TrinoParserQUESTION_MARK_)

				localctx.(*ZeroOrMoreQuantifierContext).reluctant = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewOneOrMoreQuantifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2947)
			p.Match(TrinoParserPLUS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2948)

				var _m = p.Match(TrinoParserQUESTION_MARK_)

				localctx.(*OneOrMoreQuantifierContext).reluctant = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewZeroOrOneQuantifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2951)
			p.Match(TrinoParserQUESTION_MARK_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2953)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 391, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2952)

				var _m = p.Match(TrinoParserQUESTION_MARK_)

				localctx.(*ZeroOrOneQuantifierContext).reluctant = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewRangeQuantifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2955)
			p.Match(TrinoParserLCURLY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2956)

			var _m = p.Match(TrinoParserINTEGER_VALUE_)

			localctx.(*RangeQuantifierContext).exactly = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2957)
			p.Match(TrinoParserRCURLY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2959)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2958)

				var _m = p.Match(TrinoParserQUESTION_MARK_)

				localctx.(*RangeQuantifierContext).reluctant = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewRangeQuantifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2961)
			p.Match(TrinoParserLCURLY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserINTEGER_VALUE_ {
			{
				p.SetState(2962)

				var _m = p.Match(TrinoParserINTEGER_VALUE_)

				localctx.(*RangeQuantifierContext).atLeast = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2965)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserINTEGER_VALUE_ {
			{
				p.SetState(2966)

				var _m = p.Match(TrinoParserINTEGER_VALUE_)

				localctx.(*RangeQuantifierContext).atMost = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2969)
			p.Match(TrinoParserRCURLY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2971)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 395, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2970)

				var _m = p.Match(TrinoParserQUESTION_MARK_)

				localctx.(*RangeQuantifierContext).reluctant = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentContext is an interface to support dynamic dispatch.
type IUpdateAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ_() antlr.TerminalNode
	Expression() IExpressionContext

	// IsUpdateAssignmentContext differentiates from other interfaces.
	IsUpdateAssignmentContext()
}

type UpdateAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateAssignmentContext() *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_updateAssignment
	return p
}

func InitEmptyUpdateAssignmentContext(p *UpdateAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_updateAssignment
}

func (*UpdateAssignmentContext) IsUpdateAssignmentContext() {}

func NewUpdateAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_updateAssignment

	return p
}

func (s *UpdateAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UpdateAssignmentContext) EQ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEQ_, 0)
}

func (s *UpdateAssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUpdateAssignment(s)
	}
}

func (s *UpdateAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUpdateAssignment(s)
	}
}

func (s *UpdateAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUpdateAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) UpdateAssignment() (localctx IUpdateAssignmentContext) {
	localctx = NewUpdateAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, TrinoParserRULE_updateAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2975)
		p.Identifier()
	}
	{
		p.SetState(2976)
		p.Match(TrinoParserEQ_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2977)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainOptionContext is an interface to support dynamic dispatch.
type IExplainOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExplainOptionContext differentiates from other interfaces.
	IsExplainOptionContext()
}

type ExplainOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainOptionContext() *ExplainOptionContext {
	var p = new(ExplainOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_explainOption
	return p
}

func InitEmptyExplainOptionContext(p *ExplainOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_explainOption
}

func (*ExplainOptionContext) IsExplainOptionContext() {}

func NewExplainOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainOptionContext {
	var p = new(ExplainOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_explainOption

	return p
}

func (s *ExplainOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainOptionContext) CopyAll(ctx *ExplainOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExplainOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainFormatContext struct {
	ExplainOptionContext
	value antlr.Token
}

func NewExplainFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainFormatContext {
	var p = new(ExplainFormatContext)

	InitEmptyExplainOptionContext(&p.ExplainOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainFormatContext) GetValue() antlr.Token { return s.value }

func (s *ExplainFormatContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainFormatContext) FORMAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFORMAT_, 0)
}

func (s *ExplainFormatContext) TEXT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTEXT_, 0)
}

func (s *ExplainFormatContext) GRAPHVIZ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRAPHVIZ_, 0)
}

func (s *ExplainFormatContext) JSON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_, 0)
}

func (s *ExplainFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExplainFormat(s)
	}
}

func (s *ExplainFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExplainFormat(s)
	}
}

func (s *ExplainFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExplainFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExplainTypeContext struct {
	ExplainOptionContext
	value antlr.Token
}

func NewExplainTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainTypeContext {
	var p = new(ExplainTypeContext)

	InitEmptyExplainOptionContext(&p.ExplainOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainTypeContext) GetValue() antlr.Token { return s.value }

func (s *ExplainTypeContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainTypeContext) TYPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTYPE_, 0)
}

func (s *ExplainTypeContext) LOGICAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLOGICAL_, 0)
}

func (s *ExplainTypeContext) DISTRIBUTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDISTRIBUTED_, 0)
}

func (s *ExplainTypeContext) VALIDATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVALIDATE_, 0)
}

func (s *ExplainTypeContext) IO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIO_, 0)
}

func (s *ExplainTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterExplainType(s)
	}
}

func (s *ExplainTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitExplainType(s)
	}
}

func (s *ExplainTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitExplainType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ExplainOption() (localctx IExplainOptionContext) {
	localctx = NewExplainOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, TrinoParserRULE_explainOption)
	var _la int

	p.SetState(2983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserFORMAT_:
		localctx = NewExplainFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2979)
			p.Match(TrinoParserFORMAT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2980)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainFormatContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserGRAPHVIZ_ || _la == TrinoParserJSON_ || _la == TrinoParserTEXT_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainFormatContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case TrinoParserTYPE_:
		localctx = NewExplainTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2981)
			p.Match(TrinoParserTYPE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2982)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainTypeContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserDISTRIBUTED_ || _la == TrinoParserIO_ || _la == TrinoParserLOGICAL_ || _la == TrinoParserVALIDATE_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainTypeContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_transactionMode
	return p
}

func InitEmptyTransactionModeContext(p *TransactionModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_transactionMode
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) CopyAll(ctx *TransactionModeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TransactionAccessModeContext struct {
	TransactionModeContext
	accessMode antlr.Token
}

func NewTransactionAccessModeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	InitEmptyTransactionModeContext(&p.TransactionModeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransactionModeContext))

	return p
}

func (s *TransactionAccessModeContext) GetAccessMode() antlr.Token { return s.accessMode }

func (s *TransactionAccessModeContext) SetAccessMode(v antlr.Token) { s.accessMode = v }

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) READ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREAD_, 0)
}

func (s *TransactionAccessModeContext) ONLY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserONLY_, 0)
}

func (s *TransactionAccessModeContext) WRITE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWRITE_, 0)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitTransactionAccessMode(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsolationLevelContext struct {
	TransactionModeContext
}

func NewIsolationLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	InitEmptyTransactionModeContext(&p.TransactionModeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransactionModeContext))

	return p
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ISOLATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserISOLATION_, 0)
}

func (s *IsolationLevelContext) LEVEL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLEVEL_, 0)
}

func (s *IsolationLevelContext) LevelOfIsolation() ILevelOfIsolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelOfIsolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelOfIsolationContext)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIsolationLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, TrinoParserRULE_transactionMode)
	var _la int

	p.SetState(2990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserISOLATION_:
		localctx = NewIsolationLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2985)
			p.Match(TrinoParserISOLATION_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2986)
			p.Match(TrinoParserLEVEL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2987)
			p.LevelOfIsolation()
		}

	case TrinoParserREAD_:
		localctx = NewTransactionAccessModeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2988)
			p.Match(TrinoParserREAD_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2989)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TransactionAccessModeContext).accessMode = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserONLY_ || _la == TrinoParserWRITE_) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TransactionAccessModeContext).accessMode = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelOfIsolationContext is an interface to support dynamic dispatch.
type ILevelOfIsolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLevelOfIsolationContext differentiates from other interfaces.
	IsLevelOfIsolationContext()
}

type LevelOfIsolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelOfIsolationContext() *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_levelOfIsolation
	return p
}

func InitEmptyLevelOfIsolationContext(p *LevelOfIsolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_levelOfIsolation
}

func (*LevelOfIsolationContext) IsLevelOfIsolationContext() {}

func NewLevelOfIsolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_levelOfIsolation

	return p
}

func (s *LevelOfIsolationContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelOfIsolationContext) CopyAll(ctx *LevelOfIsolationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LevelOfIsolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelOfIsolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReadUncommittedContext struct {
	LevelOfIsolationContext
}

func NewReadUncommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadUncommittedContext {
	var p = new(ReadUncommittedContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadUncommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadUncommittedContext) READ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREAD_, 0)
}

func (s *ReadUncommittedContext) UNCOMMITTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNCOMMITTED_, 0)
}

func (s *ReadUncommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterReadUncommitted(s)
	}
}

func (s *ReadUncommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitReadUncommitted(s)
	}
}

func (s *ReadUncommittedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitReadUncommitted(s)

	default:
		return t.VisitChildren(s)
	}
}

type SerializableContext struct {
	LevelOfIsolationContext
}

func NewSerializableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerializableContext {
	var p = new(SerializableContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *SerializableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializableContext) SERIALIZABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSERIALIZABLE_, 0)
}

func (s *SerializableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSerializable(s)
	}
}

func (s *SerializableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSerializable(s)
	}
}

func (s *SerializableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSerializable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReadCommittedContext struct {
	LevelOfIsolationContext
}

func NewReadCommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadCommittedContext {
	var p = new(ReadCommittedContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadCommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadCommittedContext) READ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREAD_, 0)
}

func (s *ReadCommittedContext) COMMITTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMITTED_, 0)
}

func (s *ReadCommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterReadCommitted(s)
	}
}

func (s *ReadCommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitReadCommitted(s)
	}
}

func (s *ReadCommittedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitReadCommitted(s)

	default:
		return t.VisitChildren(s)
	}
}

type RepeatableReadContext struct {
	LevelOfIsolationContext
}

func NewRepeatableReadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RepeatableReadContext {
	var p = new(RepeatableReadContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *RepeatableReadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatableReadContext) REPEATABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPEATABLE_, 0)
}

func (s *RepeatableReadContext) READ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREAD_, 0)
}

func (s *RepeatableReadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRepeatableRead(s)
	}
}

func (s *RepeatableReadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRepeatableRead(s)
	}
}

func (s *RepeatableReadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRepeatableRead(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) LevelOfIsolation() (localctx ILevelOfIsolationContext) {
	localctx = NewLevelOfIsolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, TrinoParserRULE_levelOfIsolation)
	p.SetState(2999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReadUncommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2992)
			p.Match(TrinoParserREAD_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2993)
			p.Match(TrinoParserUNCOMMITTED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewReadCommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2994)
			p.Match(TrinoParserREAD_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2995)
			p.Match(TrinoParserCOMMITTED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewRepeatableReadContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2996)
			p.Match(TrinoParserREPEATABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2997)
			p.Match(TrinoParserREAD_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSerializableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2998)
			p.Match(TrinoParserSERIALIZABLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallArgumentContext is an interface to support dynamic dispatch.
type ICallArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCallArgumentContext differentiates from other interfaces.
	IsCallArgumentContext()
}

type CallArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallArgumentContext() *CallArgumentContext {
	var p = new(CallArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_callArgument
	return p
}

func InitEmptyCallArgumentContext(p *CallArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_callArgument
}

func (*CallArgumentContext) IsCallArgumentContext() {}

func NewCallArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallArgumentContext {
	var p = new(CallArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_callArgument

	return p
}

func (s *CallArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallArgumentContext) CopyAll(ctx *CallArgumentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CallArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionalArgumentContext struct {
	CallArgumentContext
}

func NewPositionalArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionalArgumentContext {
	var p = new(PositionalArgumentContext)

	InitEmptyCallArgumentContext(&p.CallArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*CallArgumentContext))

	return p
}

func (s *PositionalArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionalArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionalArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPositionalArgument(s)
	}
}

func (s *PositionalArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPositionalArgument(s)
	}
}

func (s *PositionalArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPositionalArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

type NamedArgumentContext struct {
	CallArgumentContext
}

func NewNamedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	InitEmptyCallArgumentContext(&p.CallArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*CallArgumentContext))

	return p
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentContext) RDOUBLEARROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRDOUBLEARROW_, 0)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNamedArgument(s)
	}
}

func (s *NamedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNamedArgument(s)
	}
}

func (s *NamedArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNamedArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) CallArgument() (localctx ICallArgumentContext) {
	localctx = NewCallArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, TrinoParserRULE_callArgument)
	p.SetState(3006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPositionalArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3001)
			p.Expression()
		}

	case 2:
		localctx = NewNamedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3002)
			p.Identifier()
		}
		{
			p.SetState(3003)
			p.Match(TrinoParserRDOUBLEARROW_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3004)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathElementContext is an interface to support dynamic dispatch.
type IPathElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPathElementContext differentiates from other interfaces.
	IsPathElementContext()
}

type PathElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathElementContext() *PathElementContext {
	var p = new(PathElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_pathElement
	return p
}

func InitEmptyPathElementContext(p *PathElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_pathElement
}

func (*PathElementContext) IsPathElementContext() {}

func NewPathElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementContext {
	var p = new(PathElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_pathElement

	return p
}

func (s *PathElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementContext) CopyAll(ctx *PathElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PathElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QualifiedArgumentContext struct {
	PathElementContext
}

func NewQualifiedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedArgumentContext {
	var p = new(QualifiedArgumentContext)

	InitEmptyPathElementContext(&p.PathElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathElementContext))

	return p
}

func (s *QualifiedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedArgumentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedArgumentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedArgumentContext) DOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOT_, 0)
}

func (s *QualifiedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQualifiedArgument(s)
	}
}

func (s *QualifiedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQualifiedArgument(s)
	}
}

func (s *QualifiedArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQualifiedArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnqualifiedArgumentContext struct {
	PathElementContext
}

func NewUnqualifiedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnqualifiedArgumentContext {
	var p = new(UnqualifiedArgumentContext)

	InitEmptyPathElementContext(&p.PathElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathElementContext))

	return p
}

func (s *UnqualifiedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnqualifiedArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnqualifiedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUnqualifiedArgument(s)
	}
}

func (s *UnqualifiedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUnqualifiedArgument(s)
	}
}

func (s *UnqualifiedArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUnqualifiedArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PathElement() (localctx IPathElementContext) {
	localctx = NewPathElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, TrinoParserRULE_pathElement)
	p.SetState(3013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQualifiedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3008)
			p.Identifier()
		}
		{
			p.SetState(3009)
			p.Match(TrinoParserDOT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3010)
			p.Identifier()
		}

	case 2:
		localctx = NewUnqualifiedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3012)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathSpecificationContext is an interface to support dynamic dispatch.
type IPathSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPathElement() []IPathElementContext
	PathElement(i int) IPathElementContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsPathSpecificationContext differentiates from other interfaces.
	IsPathSpecificationContext()
}

type PathSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathSpecificationContext() *PathSpecificationContext {
	var p = new(PathSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_pathSpecification
	return p
}

func InitEmptyPathSpecificationContext(p *PathSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_pathSpecification
}

func (*PathSpecificationContext) IsPathSpecificationContext() {}

func NewPathSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathSpecificationContext {
	var p = new(PathSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_pathSpecification

	return p
}

func (s *PathSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *PathSpecificationContext) AllPathElement() []IPathElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathElementContext); ok {
			len++
		}
	}

	tst := make([]IPathElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathElementContext); ok {
			tst[i] = t.(IPathElementContext)
			i++
		}
	}

	return tst
}

func (s *PathSpecificationContext) PathElement(i int) IPathElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *PathSpecificationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *PathSpecificationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *PathSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPathSpecification(s)
	}
}

func (s *PathSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPathSpecification(s)
	}
}

func (s *PathSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPathSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) PathSpecification() (localctx IPathSpecificationContext) {
	localctx = NewPathSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, TrinoParserRULE_pathSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3015)
		p.PathElement()
	}
	p.SetState(3020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(3016)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3017)
			p.PathElement()
		}

		p.SetState(3022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionSpecificationContext is an interface to support dynamic dispatch.
type IFunctionSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION_() antlr.TerminalNode
	FunctionDeclaration() IFunctionDeclarationContext
	ReturnsClause() IReturnsClauseContext
	ControlStatement() IControlStatementContext
	AllRoutineCharacteristic() []IRoutineCharacteristicContext
	RoutineCharacteristic(i int) IRoutineCharacteristicContext

	// IsFunctionSpecificationContext differentiates from other interfaces.
	IsFunctionSpecificationContext()
}

type FunctionSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSpecificationContext() *FunctionSpecificationContext {
	var p = new(FunctionSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_functionSpecification
	return p
}

func InitEmptyFunctionSpecificationContext(p *FunctionSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_functionSpecification
}

func (*FunctionSpecificationContext) IsFunctionSpecificationContext() {}

func NewFunctionSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSpecificationContext {
	var p = new(FunctionSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_functionSpecification

	return p
}

func (s *FunctionSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSpecificationContext) FUNCTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFUNCTION_, 0)
}

func (s *FunctionSpecificationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *FunctionSpecificationContext) ReturnsClause() IReturnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnsClauseContext)
}

func (s *FunctionSpecificationContext) ControlStatement() IControlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStatementContext)
}

func (s *FunctionSpecificationContext) AllRoutineCharacteristic() []IRoutineCharacteristicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineCharacteristicContext); ok {
			len++
		}
	}

	tst := make([]IRoutineCharacteristicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineCharacteristicContext); ok {
			tst[i] = t.(IRoutineCharacteristicContext)
			i++
		}
	}

	return tst
}

func (s *FunctionSpecificationContext) RoutineCharacteristic(i int) IRoutineCharacteristicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineCharacteristicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineCharacteristicContext)
}

func (s *FunctionSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterFunctionSpecification(s)
	}
}

func (s *FunctionSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitFunctionSpecification(s)
	}
}

func (s *FunctionSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitFunctionSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) FunctionSpecification() (localctx IFunctionSpecificationContext) {
	localctx = NewFunctionSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, TrinoParserRULE_functionSpecification)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3023)
		p.Match(TrinoParserFUNCTION_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3024)
		p.FunctionDeclaration()
	}
	{
		p.SetState(3025)
		p.ReturnsClause()
	}
	p.SetState(3029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 403, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3026)
				p.RoutineCharacteristic()
			}

		}
		p.SetState(3031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 403, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(3032)
		p.ControlStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	LPAREN_() antlr.TerminalNode
	RPAREN_() antlr.TerminalNode
	AllParameterDeclaration() []IParameterDeclarationContext
	ParameterDeclaration(i int) IParameterDeclarationContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionDeclarationContext) LPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLPAREN_, 0)
}

func (s *FunctionDeclarationContext) RPAREN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRPAREN_, 0)
}

func (s *FunctionDeclarationContext) AllParameterDeclaration() []IParameterDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IParameterDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDeclarationContext); ok {
			tst[i] = t.(IParameterDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDeclarationContext) ParameterDeclaration(i int) IParameterDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationContext)
}

func (s *FunctionDeclarationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *FunctionDeclarationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, TrinoParserRULE_functionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3034)
		p.QualifiedName()
	}
	{
		p.SetState(3035)
		p.Match(TrinoParserLPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699602754) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
		{
			p.SetState(3036)
			p.ParameterDeclaration()
		}
		p.SetState(3041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserCOMMA_ {
			{
				p.SetState(3037)
				p.Match(TrinoParserCOMMA_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3038)
				p.ParameterDeclaration()
			}

			p.SetState(3043)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3046)
		p.Match(TrinoParserRPAREN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterDeclarationContext is an interface to support dynamic dispatch.
type IParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	Identifier() IIdentifierContext

	// IsParameterDeclarationContext differentiates from other interfaces.
	IsParameterDeclarationContext()
}

type ParameterDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationContext() *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_parameterDeclaration
	return p
}

func InitEmptyParameterDeclarationContext(p *ParameterDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_parameterDeclaration
}

func (*ParameterDeclarationContext) IsParameterDeclarationContext() {}

func NewParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_parameterDeclaration

	return p
}

func (s *ParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterParameterDeclaration(s)
	}
}

func (s *ParameterDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitParameterDeclaration(s)
	}
}

func (s *ParameterDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitParameterDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ParameterDeclaration() (localctx IParameterDeclarationContext) {
	localctx = NewParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, TrinoParserRULE_parameterDeclaration)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3049)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3048)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3051)
		p.type_(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnsClauseContext is an interface to support dynamic dispatch.
type IReturnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURNS_() antlr.TerminalNode
	Type_() ITypeContext

	// IsReturnsClauseContext differentiates from other interfaces.
	IsReturnsClauseContext()
}

type ReturnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnsClauseContext() *ReturnsClauseContext {
	var p = new(ReturnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_returnsClause
	return p
}

func InitEmptyReturnsClauseContext(p *ReturnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_returnsClause
}

func (*ReturnsClauseContext) IsReturnsClauseContext() {}

func NewReturnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnsClauseContext {
	var p = new(ReturnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_returnsClause

	return p
}

func (s *ReturnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnsClauseContext) RETURNS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNS_, 0)
}

func (s *ReturnsClauseContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ReturnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterReturnsClause(s)
	}
}

func (s *ReturnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitReturnsClause(s)
	}
}

func (s *ReturnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitReturnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ReturnsClause() (localctx IReturnsClauseContext) {
	localctx = NewReturnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, TrinoParserRULE_returnsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3053)
		p.Match(TrinoParserRETURNS_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3054)
		p.type_(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineCharacteristicContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRoutineCharacteristicContext differentiates from other interfaces.
	IsRoutineCharacteristicContext()
}

type RoutineCharacteristicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicContext() *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_routineCharacteristic
	return p
}

func InitEmptyRoutineCharacteristicContext(p *RoutineCharacteristicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_routineCharacteristic
}

func (*RoutineCharacteristicContext) IsRoutineCharacteristicContext() {}

func NewRoutineCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_routineCharacteristic

	return p
}

func (s *RoutineCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicContext) CopyAll(ctx *RoutineCharacteristicContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RoutineCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReturnsNullOnNullInputCharacteristicContext struct {
	RoutineCharacteristicContext
}

func NewReturnsNullOnNullInputCharacteristicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReturnsNullOnNullInputCharacteristicContext {
	var p = new(ReturnsNullOnNullInputCharacteristicContext)

	InitEmptyRoutineCharacteristicContext(&p.RoutineCharacteristicContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineCharacteristicContext))

	return p
}

func (s *ReturnsNullOnNullInputCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnsNullOnNullInputCharacteristicContext) RETURNS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNS_, 0)
}

func (s *ReturnsNullOnNullInputCharacteristicContext) AllNULL_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserNULL_)
}

func (s *ReturnsNullOnNullInputCharacteristicContext) NULL_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, i)
}

func (s *ReturnsNullOnNullInputCharacteristicContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *ReturnsNullOnNullInputCharacteristicContext) INPUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINPUT_, 0)
}

func (s *ReturnsNullOnNullInputCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterReturnsNullOnNullInputCharacteristic(s)
	}
}

func (s *ReturnsNullOnNullInputCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitReturnsNullOnNullInputCharacteristic(s)
	}
}

func (s *ReturnsNullOnNullInputCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitReturnsNullOnNullInputCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

type SecurityCharacteristicContext struct {
	RoutineCharacteristicContext
}

func NewSecurityCharacteristicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SecurityCharacteristicContext {
	var p = new(SecurityCharacteristicContext)

	InitEmptyRoutineCharacteristicContext(&p.RoutineCharacteristicContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineCharacteristicContext))

	return p
}

func (s *SecurityCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecurityCharacteristicContext) SECURITY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSECURITY_, 0)
}

func (s *SecurityCharacteristicContext) DEFINER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFINER_, 0)
}

func (s *SecurityCharacteristicContext) INVOKER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINVOKER_, 0)
}

func (s *SecurityCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSecurityCharacteristic(s)
	}
}

func (s *SecurityCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSecurityCharacteristic(s)
	}
}

func (s *SecurityCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSecurityCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

type CalledOnNullInputCharacteristicContext struct {
	RoutineCharacteristicContext
}

func NewCalledOnNullInputCharacteristicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CalledOnNullInputCharacteristicContext {
	var p = new(CalledOnNullInputCharacteristicContext)

	InitEmptyRoutineCharacteristicContext(&p.RoutineCharacteristicContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineCharacteristicContext))

	return p
}

func (s *CalledOnNullInputCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalledOnNullInputCharacteristicContext) CALLED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCALLED_, 0)
}

func (s *CalledOnNullInputCharacteristicContext) ON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserON_, 0)
}

func (s *CalledOnNullInputCharacteristicContext) NULL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULL_, 0)
}

func (s *CalledOnNullInputCharacteristicContext) INPUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINPUT_, 0)
}

func (s *CalledOnNullInputCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCalledOnNullInputCharacteristic(s)
	}
}

func (s *CalledOnNullInputCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCalledOnNullInputCharacteristic(s)
	}
}

func (s *CalledOnNullInputCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCalledOnNullInputCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommentCharacteristicContext struct {
	RoutineCharacteristicContext
}

func NewCommentCharacteristicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentCharacteristicContext {
	var p = new(CommentCharacteristicContext)

	InitEmptyRoutineCharacteristicContext(&p.RoutineCharacteristicContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineCharacteristicContext))

	return p
}

func (s *CommentCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentCharacteristicContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *CommentCharacteristicContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CommentCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCommentCharacteristic(s)
	}
}

func (s *CommentCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCommentCharacteristic(s)
	}
}

func (s *CommentCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCommentCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

type LanguageCharacteristicContext struct {
	RoutineCharacteristicContext
}

func NewLanguageCharacteristicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LanguageCharacteristicContext {
	var p = new(LanguageCharacteristicContext)

	InitEmptyRoutineCharacteristicContext(&p.RoutineCharacteristicContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineCharacteristicContext))

	return p
}

func (s *LanguageCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageCharacteristicContext) LANGUAGE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLANGUAGE_, 0)
}

func (s *LanguageCharacteristicContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LanguageCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLanguageCharacteristic(s)
	}
}

func (s *LanguageCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLanguageCharacteristic(s)
	}
}

func (s *LanguageCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLanguageCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeterministicCharacteristicContext struct {
	RoutineCharacteristicContext
}

func NewDeterministicCharacteristicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeterministicCharacteristicContext {
	var p = new(DeterministicCharacteristicContext)

	InitEmptyRoutineCharacteristicContext(&p.RoutineCharacteristicContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineCharacteristicContext))

	return p
}

func (s *DeterministicCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeterministicCharacteristicContext) DETERMINISTIC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDETERMINISTIC_, 0)
}

func (s *DeterministicCharacteristicContext) NOT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNOT_, 0)
}

func (s *DeterministicCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDeterministicCharacteristic(s)
	}
}

func (s *DeterministicCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDeterministicCharacteristic(s)
	}
}

func (s *DeterministicCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDeterministicCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RoutineCharacteristic() (localctx IRoutineCharacteristicContext) {
	localctx = NewRoutineCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, TrinoParserRULE_routineCharacteristic)
	var _la int

	p.SetState(3075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserLANGUAGE_:
		localctx = NewLanguageCharacteristicContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3056)
			p.Match(TrinoParserLANGUAGE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3057)
			p.Identifier()
		}

	case TrinoParserDETERMINISTIC_, TrinoParserNOT_:
		localctx = NewDeterministicCharacteristicContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserNOT_ {
			{
				p.SetState(3058)
				p.Match(TrinoParserNOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3061)
			p.Match(TrinoParserDETERMINISTIC_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserRETURNS_:
		localctx = NewReturnsNullOnNullInputCharacteristicContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3062)
			p.Match(TrinoParserRETURNS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3063)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3064)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3065)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3066)
			p.Match(TrinoParserINPUT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserCALLED_:
		localctx = NewCalledOnNullInputCharacteristicContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3067)
			p.Match(TrinoParserCALLED_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3068)
			p.Match(TrinoParserON_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3069)
			p.Match(TrinoParserNULL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3070)
			p.Match(TrinoParserINPUT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserSECURITY_:
		localctx = NewSecurityCharacteristicContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3071)
			p.Match(TrinoParserSECURITY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3072)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TrinoParserDEFINER_ || _la == TrinoParserINVOKER_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case TrinoParserCOMMENT_:
		localctx = NewCommentCharacteristicContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3073)
			p.Match(TrinoParserCOMMENT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3074)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IControlStatementContext is an interface to support dynamic dispatch.
type IControlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsControlStatementContext differentiates from other interfaces.
	IsControlStatementContext()
}

type ControlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlStatementContext() *ControlStatementContext {
	var p = new(ControlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_controlStatement
	return p
}

func InitEmptyControlStatementContext(p *ControlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_controlStatement
}

func (*ControlStatementContext) IsControlStatementContext() {}

func NewControlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ControlStatementContext {
	var p = new(ControlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_controlStatement

	return p
}

func (s *ControlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ControlStatementContext) CopyAll(ctx *ControlStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ControlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ControlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WhileStatementContext struct {
	ControlStatementContext
	label IIdentifierContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *WhileStatementContext) GetLabel() IIdentifierContext { return s.label }

func (s *WhileStatementContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) AllWHILE_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserWHILE_)
}

func (s *WhileStatementContext) WHILE_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserWHILE_, i)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDO_, 0)
}

func (s *WhileStatementContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *WhileStatementContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *WhileStatementContext) COLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLON_, 0)
}

func (s *WhileStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseStatementContext struct {
	ControlStatementContext
}

func NewSimpleCaseStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseStatementContext {
	var p = new(SimpleCaseStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *SimpleCaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseStatementContext) AllCASE_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCASE_)
}

func (s *SimpleCaseStatementContext) CASE_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCASE_, i)
}

func (s *SimpleCaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseStatementContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *SimpleCaseStatementContext) AllCaseStatementWhenClause() []ICaseStatementWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseStatementWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseStatementWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseStatementWhenClauseContext); ok {
			tst[i] = t.(ICaseStatementWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseStatementContext) CaseStatementWhenClause(i int) ICaseStatementWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementWhenClauseContext)
}

func (s *SimpleCaseStatementContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *SimpleCaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSimpleCaseStatement(s)
	}
}

func (s *SimpleCaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSimpleCaseStatement(s)
	}
}

func (s *SimpleCaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSimpleCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type RepeatStatementContext struct {
	ControlStatementContext
	label IIdentifierContext
}

func NewRepeatStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *RepeatStatementContext) GetLabel() IIdentifierContext { return s.label }

func (s *RepeatStatementContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) AllREPEAT_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserREPEAT_)
}

func (s *RepeatStatementContext) REPEAT_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserREPEAT_, i)
}

func (s *RepeatStatementContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *RepeatStatementContext) UNTIL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNTIL_, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *RepeatStatementContext) COLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLON_, 0)
}

func (s *RepeatStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentStatementContext struct {
	ControlStatementContext
}

func NewAssignmentStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *AssignmentStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignmentStatementContext) EQ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEQ_, 0)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type LeaveStatementContext struct {
	ControlStatementContext
}

func NewLeaveStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LeaveStatementContext {
	var p = new(LeaveStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *LeaveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeaveStatementContext) LEAVE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLEAVE_, 0)
}

func (s *LeaveStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LeaveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLeaveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type CompoundStatementContext struct {
	ControlStatementContext
}

func NewCompoundStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) BEGIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBEGIN_, 0)
}

func (s *CompoundStatementContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *CompoundStatementContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *CompoundStatementContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *CompoundStatementContext) AllSEMICOLON_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserSEMICOLON_)
}

func (s *CompoundStatementContext) SEMICOLON_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, i)
}

func (s *CompoundStatementContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type IterateStatementContext struct {
	ControlStatementContext
}

func NewIterateStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IterateStatementContext {
	var p = new(IterateStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *IterateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateStatementContext) ITERATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserITERATE_, 0)
}

func (s *IterateStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IterateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIterateStatement(s)
	}
}

func (s *IterateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIterateStatement(s)
	}
}

func (s *IterateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIterateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type LoopStatementContext struct {
	ControlStatementContext
	label IIdentifierContext
}

func NewLoopStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoopStatementContext {
	var p = new(LoopStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *LoopStatementContext) GetLabel() IIdentifierContext { return s.label }

func (s *LoopStatementContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) AllLOOP_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserLOOP_)
}

func (s *LoopStatementContext) LOOP_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserLOOP_, i)
}

func (s *LoopStatementContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *LoopStatementContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *LoopStatementContext) COLON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLON_, 0)
}

func (s *LoopStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReturnStatementContext struct {
	ControlStatementContext
}

func NewReturnStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) RETURN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURN_, 0)
}

func (s *ReturnStatementContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type IfStatementContext struct {
	ControlStatementContext
}

func NewIfStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IfStatementContext {
	var p = new(IfStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) AllIF_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserIF_)
}

func (s *IfStatementContext) IF_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, i)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTHEN_, 0)
}

func (s *IfStatementContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *IfStatementContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *IfStatementContext) AllElseIfClause() []IElseIfClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseIfClauseContext); ok {
			len++
		}
	}

	tst := make([]IElseIfClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseIfClauseContext); ok {
			tst[i] = t.(IElseIfClauseContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfClause(i int) IElseIfClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseIfClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseIfClauseContext)
}

func (s *IfStatementContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseStatementContext struct {
	ControlStatementContext
}

func NewSearchedCaseStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseStatementContext {
	var p = new(SearchedCaseStatementContext)

	InitEmptyControlStatementContext(&p.ControlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ControlStatementContext))

	return p
}

func (s *SearchedCaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseStatementContext) AllCASE_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCASE_)
}

func (s *SearchedCaseStatementContext) CASE_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCASE_, i)
}

func (s *SearchedCaseStatementContext) END_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEND_, 0)
}

func (s *SearchedCaseStatementContext) AllCaseStatementWhenClause() []ICaseStatementWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseStatementWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseStatementWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseStatementWhenClauseContext); ok {
			tst[i] = t.(ICaseStatementWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseStatementContext) CaseStatementWhenClause(i int) ICaseStatementWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementWhenClauseContext)
}

func (s *SearchedCaseStatementContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *SearchedCaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSearchedCaseStatement(s)
	}
}

func (s *SearchedCaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSearchedCaseStatement(s)
	}
}

func (s *SearchedCaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSearchedCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ControlStatement() (localctx IControlStatementContext) {
	localctx = NewControlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, TrinoParserRULE_controlStatement)
	var _la int

	var _alt int

	p.SetState(3176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReturnStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3077)
			p.Match(TrinoParserRETURN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3078)
			p.valueExpression(0)
		}

	case 2:
		localctx = NewAssignmentStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3079)
			p.Match(TrinoParserSET_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3080)
			p.Identifier()
		}
		{
			p.SetState(3081)
			p.Match(TrinoParserEQ_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3082)
			p.Expression()
		}

	case 3:
		localctx = NewSimpleCaseStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3084)
			p.Match(TrinoParserCASE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3085)
			p.Expression()
		}
		p.SetState(3087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TrinoParserWHEN_ {
			{
				p.SetState(3086)
				p.CaseStatementWhenClause()
			}

			p.SetState(3089)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserELSE_ {
			{
				p.SetState(3091)
				p.ElseClause()
			}

		}
		{
			p.SetState(3094)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3095)
			p.Match(TrinoParserCASE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSearchedCaseStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3097)
			p.Match(TrinoParserCASE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TrinoParserWHEN_ {
			{
				p.SetState(3098)
				p.CaseStatementWhenClause()
			}

			p.SetState(3101)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserELSE_ {
			{
				p.SetState(3103)
				p.ElseClause()
			}

		}
		{
			p.SetState(3106)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3107)
			p.Match(TrinoParserCASE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewIfStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3109)
			p.Match(TrinoParserIF_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3110)
			p.Expression()
		}
		{
			p.SetState(3111)
			p.Match(TrinoParserTHEN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3112)
			p.SqlStatementList()
		}
		p.SetState(3116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TrinoParserELSEIF_ {
			{
				p.SetState(3113)
				p.ElseIfClause()
			}

			p.SetState(3118)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserELSE_ {
			{
				p.SetState(3119)
				p.ElseClause()
			}

		}
		{
			p.SetState(3122)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3123)
			p.Match(TrinoParserIF_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewIterateStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3125)
			p.Match(TrinoParserITERATE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3126)
			p.Identifier()
		}

	case 7:
		localctx = NewLeaveStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3127)
			p.Match(TrinoParserLEAVE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3128)
			p.Identifier()
		}

	case 8:
		localctx = NewCompoundStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3129)
			p.Match(TrinoParserBEGIN_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3130)
					p.VariableDeclaration()
				}
				{
					p.SetState(3131)
					p.Match(TrinoParserSEMICOLON_)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029691214146) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&15) != 0) {
			{
				p.SetState(3138)
				p.SqlStatementList()
			}

		}
		{
			p.SetState(3141)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewLoopStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		p.SetState(3145)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 417, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3142)

				var _x = p.Identifier()

				localctx.(*LoopStatementContext).label = _x
			}
			{
				p.SetState(3143)
				p.Match(TrinoParserCOLON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3147)
			p.Match(TrinoParserLOOP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3148)
			p.SqlStatementList()
		}
		{
			p.SetState(3149)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3150)
			p.Match(TrinoParserLOOP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(3155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 418, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3152)

				var _x = p.Identifier()

				localctx.(*WhileStatementContext).label = _x
			}
			{
				p.SetState(3153)
				p.Match(TrinoParserCOLON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3157)
			p.Match(TrinoParserWHILE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3158)
			p.Expression()
		}
		{
			p.SetState(3159)
			p.Match(TrinoParserDO_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3160)
			p.SqlStatementList()
		}
		{
			p.SetState(3161)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3162)
			p.Match(TrinoParserWHILE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewRepeatStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		p.SetState(3167)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3164)

				var _x = p.Identifier()

				localctx.(*RepeatStatementContext).label = _x
			}
			{
				p.SetState(3165)
				p.Match(TrinoParserCOLON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3169)
			p.Match(TrinoParserREPEAT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3170)
			p.SqlStatementList()
		}
		{
			p.SetState(3171)
			p.Match(TrinoParserUNTIL_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3172)
			p.Expression()
		}
		{
			p.SetState(3173)
			p.Match(TrinoParserEND_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3174)
			p.Match(TrinoParserREPEAT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementWhenClauseContext is an interface to support dynamic dispatch.
type ICaseStatementWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN_() antlr.TerminalNode
	Expression() IExpressionContext
	THEN_() antlr.TerminalNode
	SqlStatementList() ISqlStatementListContext

	// IsCaseStatementWhenClauseContext differentiates from other interfaces.
	IsCaseStatementWhenClauseContext()
}

type CaseStatementWhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementWhenClauseContext() *CaseStatementWhenClauseContext {
	var p = new(CaseStatementWhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_caseStatementWhenClause
	return p
}

func InitEmptyCaseStatementWhenClauseContext(p *CaseStatementWhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_caseStatementWhenClause
}

func (*CaseStatementWhenClauseContext) IsCaseStatementWhenClauseContext() {}

func NewCaseStatementWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementWhenClauseContext {
	var p = new(CaseStatementWhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_caseStatementWhenClause

	return p
}

func (s *CaseStatementWhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementWhenClauseContext) WHEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHEN_, 0)
}

func (s *CaseStatementWhenClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementWhenClauseContext) THEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTHEN_, 0)
}

func (s *CaseStatementWhenClauseContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *CaseStatementWhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementWhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementWhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCaseStatementWhenClause(s)
	}
}

func (s *CaseStatementWhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCaseStatementWhenClause(s)
	}
}

func (s *CaseStatementWhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCaseStatementWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) CaseStatementWhenClause() (localctx ICaseStatementWhenClauseContext) {
	localctx = NewCaseStatementWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, TrinoParserRULE_caseStatementWhenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3178)
		p.Match(TrinoParserWHEN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3179)
		p.Expression()
	}
	{
		p.SetState(3180)
		p.Match(TrinoParserTHEN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3181)
		p.SqlStatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseIfClauseContext is an interface to support dynamic dispatch.
type IElseIfClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSEIF_() antlr.TerminalNode
	Expression() IExpressionContext
	THEN_() antlr.TerminalNode
	SqlStatementList() ISqlStatementListContext

	// IsElseIfClauseContext differentiates from other interfaces.
	IsElseIfClauseContext()
}

type ElseIfClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfClauseContext() *ElseIfClauseContext {
	var p = new(ElseIfClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_elseIfClause
	return p
}

func InitEmptyElseIfClauseContext(p *ElseIfClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_elseIfClause
}

func (*ElseIfClauseContext) IsElseIfClauseContext() {}

func NewElseIfClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfClauseContext {
	var p = new(ElseIfClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_elseIfClause

	return p
}

func (s *ElseIfClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfClauseContext) ELSEIF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserELSEIF_, 0)
}

func (s *ElseIfClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElseIfClauseContext) THEN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTHEN_, 0)
}

func (s *ElseIfClauseContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *ElseIfClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterElseIfClause(s)
	}
}

func (s *ElseIfClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitElseIfClause(s)
	}
}

func (s *ElseIfClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitElseIfClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ElseIfClause() (localctx IElseIfClauseContext) {
	localctx = NewElseIfClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, TrinoParserRULE_elseIfClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3183)
		p.Match(TrinoParserELSEIF_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3184)
		p.Expression()
	}
	{
		p.SetState(3185)
		p.Match(TrinoParserTHEN_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3186)
		p.SqlStatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseClauseContext is an interface to support dynamic dispatch.
type IElseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE_() antlr.TerminalNode
	SqlStatementList() ISqlStatementListContext

	// IsElseClauseContext differentiates from other interfaces.
	IsElseClauseContext()
}

type ElseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseClauseContext() *ElseClauseContext {
	var p = new(ElseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_elseClause
	return p
}

func InitEmptyElseClauseContext(p *ElseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_elseClause
}

func (*ElseClauseContext) IsElseClauseContext() {}

func NewElseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseClauseContext {
	var p = new(ElseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_elseClause

	return p
}

func (s *ElseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseClauseContext) ELSE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserELSE_, 0)
}

func (s *ElseClauseContext) SqlStatementList() ISqlStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementListContext)
}

func (s *ElseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterElseClause(s)
	}
}

func (s *ElseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitElseClause(s)
	}
}

func (s *ElseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitElseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) ElseClause() (localctx IElseClauseContext) {
	localctx = NewElseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, TrinoParserRULE_elseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3188)
		p.Match(TrinoParserELSE_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3189)
		p.SqlStatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE_() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Type_() ITypeContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode
	DEFAULT_() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) DECLARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDECLARE_, 0)
}

func (s *VariableDeclarationContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *VariableDeclarationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *VariableDeclarationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *VariableDeclarationContext) DEFAULT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFAULT_, 0)
}

func (s *VariableDeclarationContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, TrinoParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3191)
		p.Match(TrinoParserDECLARE_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3192)
		p.Identifier()
	}
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(3193)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3194)
			p.Identifier()
		}

		p.SetState(3199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3200)
		p.type_(0)
	}
	p.SetState(3203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TrinoParserDEFAULT_ {
		{
			p.SetState(3201)
			p.Match(TrinoParserDEFAULT_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3202)
			p.valueExpression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementListContext is an interface to support dynamic dispatch.
type ISqlStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllControlStatement() []IControlStatementContext
	ControlStatement(i int) IControlStatementContext
	AllSEMICOLON_() []antlr.TerminalNode
	SEMICOLON_(i int) antlr.TerminalNode

	// IsSqlStatementListContext differentiates from other interfaces.
	IsSqlStatementListContext()
}

type SqlStatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementListContext() *SqlStatementListContext {
	var p = new(SqlStatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sqlStatementList
	return p
}

func InitEmptySqlStatementListContext(p *SqlStatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_sqlStatementList
}

func (*SqlStatementListContext) IsSqlStatementListContext() {}

func NewSqlStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementListContext {
	var p = new(SqlStatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_sqlStatementList

	return p
}

func (s *SqlStatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementListContext) AllControlStatement() []IControlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IControlStatementContext); ok {
			len++
		}
	}

	tst := make([]IControlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IControlStatementContext); ok {
			tst[i] = t.(IControlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementListContext) ControlStatement(i int) IControlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStatementContext)
}

func (s *SqlStatementListContext) AllSEMICOLON_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserSEMICOLON_)
}

func (s *SqlStatementListContext) SEMICOLON_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserSEMICOLON_, i)
}

func (s *SqlStatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSqlStatementList(s)
	}
}

func (s *SqlStatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSqlStatementList(s)
	}
}

func (s *SqlStatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSqlStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) SqlStatementList() (localctx ISqlStatementListContext) {
	localctx = NewSqlStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, TrinoParserRULE_sqlStatementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3205)
				p.ControlStatement()
			}
			{
				p.SetState(3206)
				p.Match(TrinoParserSEMICOLON_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE_() antlr.TerminalNode
	SELECT_() antlr.TerminalNode
	DELETE_() antlr.TerminalNode
	INSERT_() antlr.TerminalNode
	UPDATE_() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) CREATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCREATE_, 0)
}

func (s *PrivilegeContext) SELECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSELECT_, 0)
}

func (s *PrivilegeContext) DELETE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDELETE_, 0)
}

func (s *PrivilegeContext) INSERT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINSERT_, 0)
}

func (s *PrivilegeContext) UPDATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUPDATE_, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, TrinoParserRULE_privilege)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3212)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserCREATE_ || _la == TrinoParserDELETE_ || _la == TrinoParserINSERT_ || _la == TrinoParserSELECT_ || _la == TrinoParserUPDATE_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT_() []antlr.TerminalNode
	DOT_(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserDOT_)
}

func (s *QualifiedNameContext) DOT_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserDOT_, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, TrinoParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3214)
		p.Identifier()
	}
	p.SetState(3219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3215)
				p.Match(TrinoParserDOT_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3216)
				p.Identifier()
			}

		}
		p.SetState(3221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPeriodContext is an interface to support dynamic dispatch.
type IQueryPeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnd returns the end rule contexts.
	GetEnd() IValueExpressionContext

	// SetEnd sets the end rule contexts.
	SetEnd(IValueExpressionContext)

	// Getter signatures
	FOR_() antlr.TerminalNode
	RangeType() IRangeTypeContext
	AS_() antlr.TerminalNode
	OF_() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsQueryPeriodContext differentiates from other interfaces.
	IsQueryPeriodContext()
}

type QueryPeriodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	end    IValueExpressionContext
}

func NewEmptyQueryPeriodContext() *QueryPeriodContext {
	var p = new(QueryPeriodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryPeriod
	return p
}

func InitEmptyQueryPeriodContext(p *QueryPeriodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_queryPeriod
}

func (*QueryPeriodContext) IsQueryPeriodContext() {}

func NewQueryPeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPeriodContext {
	var p = new(QueryPeriodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_queryPeriod

	return p
}

func (s *QueryPeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPeriodContext) GetEnd() IValueExpressionContext { return s.end }

func (s *QueryPeriodContext) SetEnd(v IValueExpressionContext) { s.end = v }

func (s *QueryPeriodContext) FOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOR_, 0)
}

func (s *QueryPeriodContext) RangeType() IRangeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeTypeContext)
}

func (s *QueryPeriodContext) AS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAS_, 0)
}

func (s *QueryPeriodContext) OF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOF_, 0)
}

func (s *QueryPeriodContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *QueryPeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryPeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQueryPeriod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) QueryPeriod() (localctx IQueryPeriodContext) {
	localctx = NewQueryPeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, TrinoParserRULE_queryPeriod)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3222)
		p.Match(TrinoParserFOR_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3223)
		p.RangeType()
	}
	{
		p.SetState(3224)
		p.Match(TrinoParserAS_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3225)
		p.Match(TrinoParserOF_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3226)

		var _x = p.valueExpression(0)

		localctx.(*QueryPeriodContext).end = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeTypeContext is an interface to support dynamic dispatch.
type IRangeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TIMESTAMP_() antlr.TerminalNode
	VERSION_() antlr.TerminalNode

	// IsRangeTypeContext differentiates from other interfaces.
	IsRangeTypeContext()
}

type RangeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeTypeContext() *RangeTypeContext {
	var p = new(RangeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rangeType
	return p
}

func InitEmptyRangeTypeContext(p *RangeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_rangeType
}

func (*RangeTypeContext) IsRangeTypeContext() {}

func NewRangeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeTypeContext {
	var p = new(RangeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_rangeType

	return p
}

func (s *RangeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeTypeContext) TIMESTAMP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIMESTAMP_, 0)
}

func (s *RangeTypeContext) VERSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVERSION_, 0)
}

func (s *RangeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRangeType(s)
	}
}

func (s *RangeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRangeType(s)
	}
}

func (s *RangeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRangeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) RangeType() (localctx IRangeTypeContext) {
	localctx = NewRangeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, TrinoParserRULE_rangeType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3228)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TrinoParserTIMESTAMP_ || _la == TrinoParserVERSION_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantorContext is an interface to support dynamic dispatch.
type IGrantorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantorContext differentiates from other interfaces.
	IsGrantorContext()
}

type GrantorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantorContext() *GrantorContext {
	var p = new(GrantorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_grantor
	return p
}

func InitEmptyGrantorContext(p *GrantorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_grantor
}

func (*GrantorContext) IsGrantorContext() {}

func NewGrantorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantorContext {
	var p = new(GrantorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_grantor

	return p
}

func (s *GrantorContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantorContext) CopyAll(ctx *GrantorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CurrentUserGrantorContext struct {
	GrantorContext
}

func NewCurrentUserGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserGrantorContext {
	var p = new(CurrentUserGrantorContext)

	InitEmptyGrantorContext(&p.GrantorContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantorContext))

	return p
}

func (s *CurrentUserGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserGrantorContext) CURRENT_USER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_USER_, 0)
}

func (s *CurrentUserGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCurrentUserGrantor(s)
	}
}

func (s *CurrentUserGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCurrentUserGrantor(s)
	}
}

func (s *CurrentUserGrantorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCurrentUserGrantor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecifiedPrincipalContext struct {
	GrantorContext
}

func NewSpecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecifiedPrincipalContext {
	var p = new(SpecifiedPrincipalContext)

	InitEmptyGrantorContext(&p.GrantorContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantorContext))

	return p
}

func (s *SpecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPrincipalContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *SpecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterSpecifiedPrincipal(s)
	}
}

func (s *SpecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitSpecifiedPrincipal(s)
	}
}

func (s *SpecifiedPrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitSpecifiedPrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentRoleGrantorContext struct {
	GrantorContext
}

func NewCurrentRoleGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRoleGrantorContext {
	var p = new(CurrentRoleGrantorContext)

	InitEmptyGrantorContext(&p.GrantorContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantorContext))

	return p
}

func (s *CurrentRoleGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRoleGrantorContext) CURRENT_ROLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_ROLE_, 0)
}

func (s *CurrentRoleGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterCurrentRoleGrantor(s)
	}
}

func (s *CurrentRoleGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitCurrentRoleGrantor(s)
	}
}

func (s *CurrentRoleGrantorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitCurrentRoleGrantor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Grantor() (localctx IGrantorContext) {
	localctx = NewGrantorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, TrinoParserRULE_grantor)
	p.SetState(3233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserABSENT_, TrinoParserADD_, TrinoParserADMIN_, TrinoParserAFTER_, TrinoParserALL_, TrinoParserANALYZE_, TrinoParserANY_, TrinoParserARRAY_, TrinoParserASC_, TrinoParserAT_, TrinoParserAUTHORIZATION_, TrinoParserBEGIN_, TrinoParserBERNOULLI_, TrinoParserBOTH_, TrinoParserCALL_, TrinoParserCALLED_, TrinoParserCASCADE_, TrinoParserCATALOG_, TrinoParserCATALOGS_, TrinoParserCOLUMN_, TrinoParserCOLUMNS_, TrinoParserCOMMENT_, TrinoParserCOMMIT_, TrinoParserCOMMITTED_, TrinoParserCONDITIONAL_, TrinoParserCOUNT_, TrinoParserCOPARTITION_, TrinoParserCURRENT_, TrinoParserDATA_, TrinoParserDATE_, TrinoParserDAY_, TrinoParserDECLARE_, TrinoParserDEFAULT_, TrinoParserDEFINE_, TrinoParserDEFINER_, TrinoParserDENY_, TrinoParserDESC_, TrinoParserDESCRIPTOR_, TrinoParserDETERMINISTIC_, TrinoParserDISTRIBUTED_, TrinoParserDO_, TrinoParserDOUBLE_, TrinoParserEMPTY_, TrinoParserELSEIF_, TrinoParserENCODING_, TrinoParserERROR_, TrinoParserEXCLUDING_, TrinoParserEXPLAIN_, TrinoParserFETCH_, TrinoParserFILTER_, TrinoParserFINAL_, TrinoParserFIRST_, TrinoParserFOLLOWING_, TrinoParserFORMAT_, TrinoParserFUNCTION_, TrinoParserFUNCTIONS_, TrinoParserGRACE_, TrinoParserGRANT_, TrinoParserGRANTED_, TrinoParserGRANTS_, TrinoParserGRAPHVIZ_, TrinoParserGROUPS_, TrinoParserHOUR_, TrinoParserIF_, TrinoParserIGNORE_, TrinoParserIMMEDIATE_, TrinoParserINCLUDING_, TrinoParserINITIAL_, TrinoParserINPUT_, TrinoParserINTERVAL_, TrinoParserINVOKER_, TrinoParserIO_, TrinoParserISOLATION_, TrinoParserITERATE_, TrinoParserJSON_, TrinoParserKEEP_, TrinoParserKEY_, TrinoParserKEYS_, TrinoParserLANGUAGE_, TrinoParserLAST_, TrinoParserLATERAL_, TrinoParserLEADING_, TrinoParserLEAVE_, TrinoParserLEVEL_, TrinoParserLIMIT_, TrinoParserLOCAL_, TrinoParserLOGICAL_, TrinoParserLOOP_, TrinoParserMAP_, TrinoParserMATCH_, TrinoParserMATCHED_, TrinoParserMATCHES_, TrinoParserMATCH_RECOGNIZE_, TrinoParserMATERIALIZED_, TrinoParserMEASURES_, TrinoParserMERGE_, TrinoParserMINUTE_, TrinoParserMONTH_, TrinoParserNESTED_, TrinoParserNEXT_, TrinoParserNFC_, TrinoParserNFD_, TrinoParserNFKC_, TrinoParserNFKD_, TrinoParserNO_, TrinoParserNONE_, TrinoParserNULLIF_, TrinoParserNULLS_, TrinoParserOBJECT_, TrinoParserOF_, TrinoParserOFFSET_, TrinoParserOMIT_, TrinoParserONE_, TrinoParserONLY_, TrinoParserOPTION_, TrinoParserORDINALITY_, TrinoParserOUTPUT_, TrinoParserOVER_, TrinoParserOVERFLOW_, TrinoParserPARTITION_, TrinoParserPARTITIONS_, TrinoParserPASSING_, TrinoParserPAST_, TrinoParserPATH_, TrinoParserPATTERN_, TrinoParserPER_, TrinoParserPERIOD_, TrinoParserPERMUTE_, TrinoParserPLAN_, TrinoParserPOSITION_, TrinoParserPRECEDING_, TrinoParserPRECISION_, TrinoParserPRIVILEGES_, TrinoParserPROPERTIES_, TrinoParserPRUNE_, TrinoParserQUOTES_, TrinoParserRANGE_, TrinoParserREAD_, TrinoParserREFRESH_, TrinoParserRENAME_, TrinoParserREPEAT_, TrinoParserREPEATABLE_, TrinoParserREPLACE_, TrinoParserRESET_, TrinoParserRESPECT_, TrinoParserRESTRICT_, TrinoParserRETURN_, TrinoParserRETURNING_, TrinoParserRETURNS_, TrinoParserREVOKE_, TrinoParserROLE_, TrinoParserROLES_, TrinoParserROLLBACK_, TrinoParserROW_, TrinoParserROWS_, TrinoParserRUNNING_, TrinoParserSCALAR_, TrinoParserSCHEMA_, TrinoParserSCHEMAS_, TrinoParserSECOND_, TrinoParserSECURITY_, TrinoParserSEEK_, TrinoParserSERIALIZABLE_, TrinoParserSESSION_, TrinoParserSET_, TrinoParserSETS_, TrinoParserSHOW_, TrinoParserSOME_, TrinoParserSTART_, TrinoParserSTATS_, TrinoParserSUBSET_, TrinoParserSUBSTRING_, TrinoParserSYSTEM_, TrinoParserTABLES_, TrinoParserTABLESAMPLE_, TrinoParserTEXT_, TrinoParserTEXT_STRING_, TrinoParserTIES_, TrinoParserTIME_, TrinoParserTIMESTAMP_, TrinoParserTO_, TrinoParserTRAILING_, TrinoParserTRANSACTION_, TrinoParserTRUNCATE_, TrinoParserTRY_CAST_, TrinoParserTYPE_, TrinoParserUNBOUNDED_, TrinoParserUNCOMMITTED_, TrinoParserUNCONDITIONAL_, TrinoParserUNIQUE_, TrinoParserUNKNOWN_, TrinoParserUNMATCHED_, TrinoParserUNTIL_, TrinoParserUPDATE_, TrinoParserUSE_, TrinoParserUSER_, TrinoParserUTF16_, TrinoParserUTF32_, TrinoParserUTF8_, TrinoParserVALIDATE_, TrinoParserVALUE_, TrinoParserVERBOSE_, TrinoParserVERSION_, TrinoParserVIEW_, TrinoParserWHILE_, TrinoParserWINDOW_, TrinoParserWITHIN_, TrinoParserWITHOUT_, TrinoParserWORK_, TrinoParserWRAPPER_, TrinoParserWRITE_, TrinoParserYEAR_, TrinoParserZONE_, TrinoParserIDENTIFIER_, TrinoParserDIGIT_IDENTIFIER_, TrinoParserQUOTED_IDENTIFIER_, TrinoParserBACKQUOTED_IDENTIFIER_:
		localctx = NewSpecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3230)
			p.Principal()
		}

	case TrinoParserCURRENT_USER_:
		localctx = NewCurrentUserGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3231)
			p.Match(TrinoParserCURRENT_USER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserCURRENT_ROLE_:
		localctx = NewCurrentRoleGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3232)
			p.Match(TrinoParserCURRENT_ROLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrincipalContext is an interface to support dynamic dispatch.
type IPrincipalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrincipalContext differentiates from other interfaces.
	IsPrincipalContext()
}

type PrincipalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipalContext() *PrincipalContext {
	var p = new(PrincipalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_principal
	return p
}

func InitEmptyPrincipalContext(p *PrincipalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_principal
}

func (*PrincipalContext) IsPrincipalContext() {}

func NewPrincipalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrincipalContext {
	var p = new(PrincipalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_principal

	return p
}

func (s *PrincipalContext) GetParser() antlr.Parser { return s.parser }

func (s *PrincipalContext) CopyAll(ctx *PrincipalContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrincipalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnspecifiedPrincipalContext struct {
	PrincipalContext
}

func NewUnspecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnspecifiedPrincipalContext {
	var p = new(UnspecifiedPrincipalContext)

	InitEmptyPrincipalContext(&p.PrincipalContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrincipalContext))

	return p
}

func (s *UnspecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnspecifiedPrincipalContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnspecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUnspecifiedPrincipal(s)
	}
}

func (s *UnspecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUnspecifiedPrincipal(s)
	}
}

func (s *UnspecifiedPrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUnspecifiedPrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserPrincipalContext struct {
	PrincipalContext
}

func NewUserPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserPrincipalContext {
	var p = new(UserPrincipalContext)

	InitEmptyPrincipalContext(&p.PrincipalContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrincipalContext))

	return p
}

func (s *UserPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPrincipalContext) USER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSER_, 0)
}

func (s *UserPrincipalContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUserPrincipal(s)
	}
}

func (s *UserPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUserPrincipal(s)
	}
}

func (s *UserPrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUserPrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

type RolePrincipalContext struct {
	PrincipalContext
}

func NewRolePrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RolePrincipalContext {
	var p = new(RolePrincipalContext)

	InitEmptyPrincipalContext(&p.PrincipalContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrincipalContext))

	return p
}

func (s *RolePrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolePrincipalContext) ROLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLE_, 0)
}

func (s *RolePrincipalContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolePrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRolePrincipal(s)
	}
}

func (s *RolePrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRolePrincipal(s)
	}
}

func (s *RolePrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRolePrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Principal() (localctx IPrincipalContext) {
	localctx = NewPrincipalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, TrinoParserRULE_principal)
	p.SetState(3240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnspecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3235)
			p.Identifier()
		}

	case 2:
		localctx = NewUserPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3236)
			p.Match(TrinoParserUSER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3237)
			p.Identifier()
		}

	case 3:
		localctx = NewRolePrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3238)
			p.Match(TrinoParserROLE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3239)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRolesContext is an interface to support dynamic dispatch.
type IRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA_() []antlr.TerminalNode
	COMMA_(i int) antlr.TerminalNode

	// IsRolesContext differentiates from other interfaces.
	IsRolesContext()
}

type RolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRolesContext() *RolesContext {
	var p = new(RolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_roles
	return p
}

func InitEmptyRolesContext(p *RolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_roles
}

func (*RolesContext) IsRolesContext() {}

func NewRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RolesContext {
	var p = new(RolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_roles

	return p
}

func (s *RolesContext) GetParser() antlr.Parser { return s.parser }

func (s *RolesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RolesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(TrinoParserCOMMA_)
}

func (s *RolesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMA_, i)
}

func (s *RolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterRoles(s)
	}
}

func (s *RolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitRoles(s)
	}
}

func (s *RolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Roles() (localctx IRolesContext) {
	localctx = NewRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, TrinoParserRULE_roles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3242)
		p.Identifier()
	}
	p.SetState(3247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TrinoParserCOMMA_ {
		{
			p.SetState(3243)
			p.Match(TrinoParserCOMMA_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3244)
			p.Identifier()
		}

		p.SetState(3249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBACKQUOTED_IDENTIFIER_, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitBackQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuotedIdentifierContext struct {
	IdentifierContext
}

func NewQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) QUOTED_IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUOTED_IDENTIFIER_, 0)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type DigitIdentifierContext struct {
	IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDIGIT_IDENTIFIER_, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDigitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIDENTIFIER_, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, TrinoParserRULE_identifier)
	p.SetState(3255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserIDENTIFIER_:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3250)
			p.Match(TrinoParserIDENTIFIER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserQUOTED_IDENTIFIER_:
		localctx = NewQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3251)
			p.Match(TrinoParserQUOTED_IDENTIFIER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserABSENT_, TrinoParserADD_, TrinoParserADMIN_, TrinoParserAFTER_, TrinoParserALL_, TrinoParserANALYZE_, TrinoParserANY_, TrinoParserARRAY_, TrinoParserASC_, TrinoParserAT_, TrinoParserAUTHORIZATION_, TrinoParserBEGIN_, TrinoParserBERNOULLI_, TrinoParserBOTH_, TrinoParserCALL_, TrinoParserCALLED_, TrinoParserCASCADE_, TrinoParserCATALOG_, TrinoParserCATALOGS_, TrinoParserCOLUMN_, TrinoParserCOLUMNS_, TrinoParserCOMMENT_, TrinoParserCOMMIT_, TrinoParserCOMMITTED_, TrinoParserCONDITIONAL_, TrinoParserCOUNT_, TrinoParserCOPARTITION_, TrinoParserCURRENT_, TrinoParserDATA_, TrinoParserDATE_, TrinoParserDAY_, TrinoParserDECLARE_, TrinoParserDEFAULT_, TrinoParserDEFINE_, TrinoParserDEFINER_, TrinoParserDENY_, TrinoParserDESC_, TrinoParserDESCRIPTOR_, TrinoParserDETERMINISTIC_, TrinoParserDISTRIBUTED_, TrinoParserDO_, TrinoParserDOUBLE_, TrinoParserEMPTY_, TrinoParserELSEIF_, TrinoParserENCODING_, TrinoParserERROR_, TrinoParserEXCLUDING_, TrinoParserEXPLAIN_, TrinoParserFETCH_, TrinoParserFILTER_, TrinoParserFINAL_, TrinoParserFIRST_, TrinoParserFOLLOWING_, TrinoParserFORMAT_, TrinoParserFUNCTION_, TrinoParserFUNCTIONS_, TrinoParserGRACE_, TrinoParserGRANT_, TrinoParserGRANTED_, TrinoParserGRANTS_, TrinoParserGRAPHVIZ_, TrinoParserGROUPS_, TrinoParserHOUR_, TrinoParserIF_, TrinoParserIGNORE_, TrinoParserIMMEDIATE_, TrinoParserINCLUDING_, TrinoParserINITIAL_, TrinoParserINPUT_, TrinoParserINTERVAL_, TrinoParserINVOKER_, TrinoParserIO_, TrinoParserISOLATION_, TrinoParserITERATE_, TrinoParserJSON_, TrinoParserKEEP_, TrinoParserKEY_, TrinoParserKEYS_, TrinoParserLANGUAGE_, TrinoParserLAST_, TrinoParserLATERAL_, TrinoParserLEADING_, TrinoParserLEAVE_, TrinoParserLEVEL_, TrinoParserLIMIT_, TrinoParserLOCAL_, TrinoParserLOGICAL_, TrinoParserLOOP_, TrinoParserMAP_, TrinoParserMATCH_, TrinoParserMATCHED_, TrinoParserMATCHES_, TrinoParserMATCH_RECOGNIZE_, TrinoParserMATERIALIZED_, TrinoParserMEASURES_, TrinoParserMERGE_, TrinoParserMINUTE_, TrinoParserMONTH_, TrinoParserNESTED_, TrinoParserNEXT_, TrinoParserNFC_, TrinoParserNFD_, TrinoParserNFKC_, TrinoParserNFKD_, TrinoParserNO_, TrinoParserNONE_, TrinoParserNULLIF_, TrinoParserNULLS_, TrinoParserOBJECT_, TrinoParserOF_, TrinoParserOFFSET_, TrinoParserOMIT_, TrinoParserONE_, TrinoParserONLY_, TrinoParserOPTION_, TrinoParserORDINALITY_, TrinoParserOUTPUT_, TrinoParserOVER_, TrinoParserOVERFLOW_, TrinoParserPARTITION_, TrinoParserPARTITIONS_, TrinoParserPASSING_, TrinoParserPAST_, TrinoParserPATH_, TrinoParserPATTERN_, TrinoParserPER_, TrinoParserPERIOD_, TrinoParserPERMUTE_, TrinoParserPLAN_, TrinoParserPOSITION_, TrinoParserPRECEDING_, TrinoParserPRECISION_, TrinoParserPRIVILEGES_, TrinoParserPROPERTIES_, TrinoParserPRUNE_, TrinoParserQUOTES_, TrinoParserRANGE_, TrinoParserREAD_, TrinoParserREFRESH_, TrinoParserRENAME_, TrinoParserREPEAT_, TrinoParserREPEATABLE_, TrinoParserREPLACE_, TrinoParserRESET_, TrinoParserRESPECT_, TrinoParserRESTRICT_, TrinoParserRETURN_, TrinoParserRETURNING_, TrinoParserRETURNS_, TrinoParserREVOKE_, TrinoParserROLE_, TrinoParserROLES_, TrinoParserROLLBACK_, TrinoParserROW_, TrinoParserROWS_, TrinoParserRUNNING_, TrinoParserSCALAR_, TrinoParserSCHEMA_, TrinoParserSCHEMAS_, TrinoParserSECOND_, TrinoParserSECURITY_, TrinoParserSEEK_, TrinoParserSERIALIZABLE_, TrinoParserSESSION_, TrinoParserSET_, TrinoParserSETS_, TrinoParserSHOW_, TrinoParserSOME_, TrinoParserSTART_, TrinoParserSTATS_, TrinoParserSUBSET_, TrinoParserSUBSTRING_, TrinoParserSYSTEM_, TrinoParserTABLES_, TrinoParserTABLESAMPLE_, TrinoParserTEXT_, TrinoParserTEXT_STRING_, TrinoParserTIES_, TrinoParserTIME_, TrinoParserTIMESTAMP_, TrinoParserTO_, TrinoParserTRAILING_, TrinoParserTRANSACTION_, TrinoParserTRUNCATE_, TrinoParserTRY_CAST_, TrinoParserTYPE_, TrinoParserUNBOUNDED_, TrinoParserUNCOMMITTED_, TrinoParserUNCONDITIONAL_, TrinoParserUNIQUE_, TrinoParserUNKNOWN_, TrinoParserUNMATCHED_, TrinoParserUNTIL_, TrinoParserUPDATE_, TrinoParserUSE_, TrinoParserUSER_, TrinoParserUTF16_, TrinoParserUTF32_, TrinoParserUTF8_, TrinoParserVALIDATE_, TrinoParserVALUE_, TrinoParserVERBOSE_, TrinoParserVERSION_, TrinoParserVIEW_, TrinoParserWHILE_, TrinoParserWINDOW_, TrinoParserWITHIN_, TrinoParserWITHOUT_, TrinoParserWORK_, TrinoParserWRAPPER_, TrinoParserWRITE_, TrinoParserYEAR_, TrinoParserZONE_:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3252)
			p.NonReserved()
		}

	case TrinoParserBACKQUOTED_IDENTIFIER_:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3253)
			p.Match(TrinoParserBACKQUOTED_IDENTIFIER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TrinoParserDIGIT_IDENTIFIER_:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3254)
			p.Match(TrinoParserDIGIT_IDENTIFIER_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDECIMAL_VALUE_, 0)
}

func (s *DecimalLiteralContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUS_, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoubleLiteralContext struct {
	NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOUBLE_VALUE_, 0)
}

func (s *DoubleLiteralContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUS_, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitDoubleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTEGER_VALUE_, 0)
}

func (s *IntegerLiteralContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUS_, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, TrinoParserRULE_number)
	var _la int

	p.SetState(3269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserMINUS_ {
			{
				p.SetState(3257)
				p.Match(TrinoParserMINUS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3260)
			p.Match(TrinoParserDECIMAL_VALUE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserMINUS_ {
			{
				p.SetState(3261)
				p.Match(TrinoParserMINUS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3264)
			p.Match(TrinoParserDOUBLE_VALUE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TrinoParserMINUS_ {
			{
				p.SetState(3265)
				p.Match(TrinoParserMINUS_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3268)
			p.Match(TrinoParserINTEGER_VALUE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthorizationUserContext is an interface to support dynamic dispatch.
type IAuthorizationUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthorizationUserContext differentiates from other interfaces.
	IsAuthorizationUserContext()
}

type AuthorizationUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthorizationUserContext() *AuthorizationUserContext {
	var p = new(AuthorizationUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_authorizationUser
	return p
}

func InitEmptyAuthorizationUserContext(p *AuthorizationUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_authorizationUser
}

func (*AuthorizationUserContext) IsAuthorizationUserContext() {}

func NewAuthorizationUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthorizationUserContext {
	var p = new(AuthorizationUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_authorizationUser

	return p
}

func (s *AuthorizationUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthorizationUserContext) CopyAll(ctx *AuthorizationUserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthorizationUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthorizationUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringUserContext struct {
	AuthorizationUserContext
}

func NewStringUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringUserContext {
	var p = new(StringUserContext)

	InitEmptyAuthorizationUserContext(&p.AuthorizationUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthorizationUserContext))

	return p
}

func (s *StringUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringUserContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *StringUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterStringUser(s)
	}
}

func (s *StringUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitStringUser(s)
	}
}

func (s *StringUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitStringUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierUserContext struct {
	AuthorizationUserContext
}

func NewIdentifierUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierUserContext {
	var p = new(IdentifierUserContext)

	InitEmptyAuthorizationUserContext(&p.AuthorizationUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthorizationUserContext))

	return p
}

func (s *IdentifierUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierUserContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterIdentifierUser(s)
	}
}

func (s *IdentifierUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitIdentifierUser(s)
	}
}

func (s *IdentifierUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitIdentifierUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) AuthorizationUser() (localctx IAuthorizationUserContext) {
	localctx = NewAuthorizationUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, TrinoParserRULE_authorizationUser)
	p.SetState(3273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TrinoParserABSENT_, TrinoParserADD_, TrinoParserADMIN_, TrinoParserAFTER_, TrinoParserALL_, TrinoParserANALYZE_, TrinoParserANY_, TrinoParserARRAY_, TrinoParserASC_, TrinoParserAT_, TrinoParserAUTHORIZATION_, TrinoParserBEGIN_, TrinoParserBERNOULLI_, TrinoParserBOTH_, TrinoParserCALL_, TrinoParserCALLED_, TrinoParserCASCADE_, TrinoParserCATALOG_, TrinoParserCATALOGS_, TrinoParserCOLUMN_, TrinoParserCOLUMNS_, TrinoParserCOMMENT_, TrinoParserCOMMIT_, TrinoParserCOMMITTED_, TrinoParserCONDITIONAL_, TrinoParserCOUNT_, TrinoParserCOPARTITION_, TrinoParserCURRENT_, TrinoParserDATA_, TrinoParserDATE_, TrinoParserDAY_, TrinoParserDECLARE_, TrinoParserDEFAULT_, TrinoParserDEFINE_, TrinoParserDEFINER_, TrinoParserDENY_, TrinoParserDESC_, TrinoParserDESCRIPTOR_, TrinoParserDETERMINISTIC_, TrinoParserDISTRIBUTED_, TrinoParserDO_, TrinoParserDOUBLE_, TrinoParserEMPTY_, TrinoParserELSEIF_, TrinoParserENCODING_, TrinoParserERROR_, TrinoParserEXCLUDING_, TrinoParserEXPLAIN_, TrinoParserFETCH_, TrinoParserFILTER_, TrinoParserFINAL_, TrinoParserFIRST_, TrinoParserFOLLOWING_, TrinoParserFORMAT_, TrinoParserFUNCTION_, TrinoParserFUNCTIONS_, TrinoParserGRACE_, TrinoParserGRANT_, TrinoParserGRANTED_, TrinoParserGRANTS_, TrinoParserGRAPHVIZ_, TrinoParserGROUPS_, TrinoParserHOUR_, TrinoParserIF_, TrinoParserIGNORE_, TrinoParserIMMEDIATE_, TrinoParserINCLUDING_, TrinoParserINITIAL_, TrinoParserINPUT_, TrinoParserINTERVAL_, TrinoParserINVOKER_, TrinoParserIO_, TrinoParserISOLATION_, TrinoParserITERATE_, TrinoParserJSON_, TrinoParserKEEP_, TrinoParserKEY_, TrinoParserKEYS_, TrinoParserLANGUAGE_, TrinoParserLAST_, TrinoParserLATERAL_, TrinoParserLEADING_, TrinoParserLEAVE_, TrinoParserLEVEL_, TrinoParserLIMIT_, TrinoParserLOCAL_, TrinoParserLOGICAL_, TrinoParserLOOP_, TrinoParserMAP_, TrinoParserMATCH_, TrinoParserMATCHED_, TrinoParserMATCHES_, TrinoParserMATCH_RECOGNIZE_, TrinoParserMATERIALIZED_, TrinoParserMEASURES_, TrinoParserMERGE_, TrinoParserMINUTE_, TrinoParserMONTH_, TrinoParserNESTED_, TrinoParserNEXT_, TrinoParserNFC_, TrinoParserNFD_, TrinoParserNFKC_, TrinoParserNFKD_, TrinoParserNO_, TrinoParserNONE_, TrinoParserNULLIF_, TrinoParserNULLS_, TrinoParserOBJECT_, TrinoParserOF_, TrinoParserOFFSET_, TrinoParserOMIT_, TrinoParserONE_, TrinoParserONLY_, TrinoParserOPTION_, TrinoParserORDINALITY_, TrinoParserOUTPUT_, TrinoParserOVER_, TrinoParserOVERFLOW_, TrinoParserPARTITION_, TrinoParserPARTITIONS_, TrinoParserPASSING_, TrinoParserPAST_, TrinoParserPATH_, TrinoParserPATTERN_, TrinoParserPER_, TrinoParserPERIOD_, TrinoParserPERMUTE_, TrinoParserPLAN_, TrinoParserPOSITION_, TrinoParserPRECEDING_, TrinoParserPRECISION_, TrinoParserPRIVILEGES_, TrinoParserPROPERTIES_, TrinoParserPRUNE_, TrinoParserQUOTES_, TrinoParserRANGE_, TrinoParserREAD_, TrinoParserREFRESH_, TrinoParserRENAME_, TrinoParserREPEAT_, TrinoParserREPEATABLE_, TrinoParserREPLACE_, TrinoParserRESET_, TrinoParserRESPECT_, TrinoParserRESTRICT_, TrinoParserRETURN_, TrinoParserRETURNING_, TrinoParserRETURNS_, TrinoParserREVOKE_, TrinoParserROLE_, TrinoParserROLES_, TrinoParserROLLBACK_, TrinoParserROW_, TrinoParserROWS_, TrinoParserRUNNING_, TrinoParserSCALAR_, TrinoParserSCHEMA_, TrinoParserSCHEMAS_, TrinoParserSECOND_, TrinoParserSECURITY_, TrinoParserSEEK_, TrinoParserSERIALIZABLE_, TrinoParserSESSION_, TrinoParserSET_, TrinoParserSETS_, TrinoParserSHOW_, TrinoParserSOME_, TrinoParserSTART_, TrinoParserSTATS_, TrinoParserSUBSET_, TrinoParserSUBSTRING_, TrinoParserSYSTEM_, TrinoParserTABLES_, TrinoParserTABLESAMPLE_, TrinoParserTEXT_, TrinoParserTEXT_STRING_, TrinoParserTIES_, TrinoParserTIME_, TrinoParserTIMESTAMP_, TrinoParserTO_, TrinoParserTRAILING_, TrinoParserTRANSACTION_, TrinoParserTRUNCATE_, TrinoParserTRY_CAST_, TrinoParserTYPE_, TrinoParserUNBOUNDED_, TrinoParserUNCOMMITTED_, TrinoParserUNCONDITIONAL_, TrinoParserUNIQUE_, TrinoParserUNKNOWN_, TrinoParserUNMATCHED_, TrinoParserUNTIL_, TrinoParserUPDATE_, TrinoParserUSE_, TrinoParserUSER_, TrinoParserUTF16_, TrinoParserUTF32_, TrinoParserUTF8_, TrinoParserVALIDATE_, TrinoParserVALUE_, TrinoParserVERBOSE_, TrinoParserVERSION_, TrinoParserVIEW_, TrinoParserWHILE_, TrinoParserWINDOW_, TrinoParserWITHIN_, TrinoParserWITHOUT_, TrinoParserWORK_, TrinoParserWRAPPER_, TrinoParserWRITE_, TrinoParserYEAR_, TrinoParserZONE_, TrinoParserIDENTIFIER_, TrinoParserDIGIT_IDENTIFIER_, TrinoParserQUOTED_IDENTIFIER_, TrinoParserBACKQUOTED_IDENTIFIER_:
		localctx = NewIdentifierUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3271)
			p.Identifier()
		}

	case TrinoParserSTRING_, TrinoParserUNICODE_STRING_:
		localctx = NewStringUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3272)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSENT_() antlr.TerminalNode
	ADD_() antlr.TerminalNode
	ADMIN_() antlr.TerminalNode
	AFTER_() antlr.TerminalNode
	ALL_() antlr.TerminalNode
	ANALYZE_() antlr.TerminalNode
	ANY_() antlr.TerminalNode
	ARRAY_() antlr.TerminalNode
	ASC_() antlr.TerminalNode
	AT_() antlr.TerminalNode
	AUTHORIZATION_() antlr.TerminalNode
	BEGIN_() antlr.TerminalNode
	BERNOULLI_() antlr.TerminalNode
	BOTH_() antlr.TerminalNode
	CALL_() antlr.TerminalNode
	CALLED_() antlr.TerminalNode
	CASCADE_() antlr.TerminalNode
	CATALOG_() antlr.TerminalNode
	CATALOGS_() antlr.TerminalNode
	COLUMN_() antlr.TerminalNode
	COLUMNS_() antlr.TerminalNode
	COMMENT_() antlr.TerminalNode
	COMMIT_() antlr.TerminalNode
	COMMITTED_() antlr.TerminalNode
	CONDITIONAL_() antlr.TerminalNode
	COPARTITION_() antlr.TerminalNode
	COUNT_() antlr.TerminalNode
	CURRENT_() antlr.TerminalNode
	DATA_() antlr.TerminalNode
	DATE_() antlr.TerminalNode
	DAY_() antlr.TerminalNode
	DECLARE_() antlr.TerminalNode
	DEFAULT_() antlr.TerminalNode
	DEFINE_() antlr.TerminalNode
	DEFINER_() antlr.TerminalNode
	DENY_() antlr.TerminalNode
	DESC_() antlr.TerminalNode
	DESCRIPTOR_() antlr.TerminalNode
	DETERMINISTIC_() antlr.TerminalNode
	DISTRIBUTED_() antlr.TerminalNode
	DO_() antlr.TerminalNode
	DOUBLE_() antlr.TerminalNode
	ELSEIF_() antlr.TerminalNode
	EMPTY_() antlr.TerminalNode
	ENCODING_() antlr.TerminalNode
	ERROR_() antlr.TerminalNode
	EXCLUDING_() antlr.TerminalNode
	EXPLAIN_() antlr.TerminalNode
	FETCH_() antlr.TerminalNode
	FILTER_() antlr.TerminalNode
	FINAL_() antlr.TerminalNode
	FIRST_() antlr.TerminalNode
	FOLLOWING_() antlr.TerminalNode
	FORMAT_() antlr.TerminalNode
	FUNCTION_() antlr.TerminalNode
	FUNCTIONS_() antlr.TerminalNode
	GRACE_() antlr.TerminalNode
	GRANT_() antlr.TerminalNode
	GRANTED_() antlr.TerminalNode
	GRANTS_() antlr.TerminalNode
	GRAPHVIZ_() antlr.TerminalNode
	GROUPS_() antlr.TerminalNode
	HOUR_() antlr.TerminalNode
	IF_() antlr.TerminalNode
	IGNORE_() antlr.TerminalNode
	IMMEDIATE_() antlr.TerminalNode
	INCLUDING_() antlr.TerminalNode
	INITIAL_() antlr.TerminalNode
	INPUT_() antlr.TerminalNode
	INTERVAL_() antlr.TerminalNode
	INVOKER_() antlr.TerminalNode
	IO_() antlr.TerminalNode
	ITERATE_() antlr.TerminalNode
	ISOLATION_() antlr.TerminalNode
	JSON_() antlr.TerminalNode
	KEEP_() antlr.TerminalNode
	KEY_() antlr.TerminalNode
	KEYS_() antlr.TerminalNode
	LANGUAGE_() antlr.TerminalNode
	LAST_() antlr.TerminalNode
	LATERAL_() antlr.TerminalNode
	LEADING_() antlr.TerminalNode
	LEAVE_() antlr.TerminalNode
	LEVEL_() antlr.TerminalNode
	LIMIT_() antlr.TerminalNode
	LOCAL_() antlr.TerminalNode
	LOGICAL_() antlr.TerminalNode
	LOOP_() antlr.TerminalNode
	MAP_() antlr.TerminalNode
	MATCH_() antlr.TerminalNode
	MATCHED_() antlr.TerminalNode
	MATCHES_() antlr.TerminalNode
	MATCH_RECOGNIZE_() antlr.TerminalNode
	MATERIALIZED_() antlr.TerminalNode
	MEASURES_() antlr.TerminalNode
	MERGE_() antlr.TerminalNode
	MINUTE_() antlr.TerminalNode
	MONTH_() antlr.TerminalNode
	NESTED_() antlr.TerminalNode
	NEXT_() antlr.TerminalNode
	NFC_() antlr.TerminalNode
	NFD_() antlr.TerminalNode
	NFKC_() antlr.TerminalNode
	NFKD_() antlr.TerminalNode
	NO_() antlr.TerminalNode
	NONE_() antlr.TerminalNode
	NULLIF_() antlr.TerminalNode
	NULLS_() antlr.TerminalNode
	OBJECT_() antlr.TerminalNode
	OF_() antlr.TerminalNode
	OFFSET_() antlr.TerminalNode
	OMIT_() antlr.TerminalNode
	ONE_() antlr.TerminalNode
	ONLY_() antlr.TerminalNode
	OPTION_() antlr.TerminalNode
	ORDINALITY_() antlr.TerminalNode
	OUTPUT_() antlr.TerminalNode
	OVER_() antlr.TerminalNode
	OVERFLOW_() antlr.TerminalNode
	PARTITION_() antlr.TerminalNode
	PARTITIONS_() antlr.TerminalNode
	PASSING_() antlr.TerminalNode
	PAST_() antlr.TerminalNode
	PATH_() antlr.TerminalNode
	PATTERN_() antlr.TerminalNode
	PER_() antlr.TerminalNode
	PERIOD_() antlr.TerminalNode
	PERMUTE_() antlr.TerminalNode
	PLAN_() antlr.TerminalNode
	POSITION_() antlr.TerminalNode
	PRECEDING_() antlr.TerminalNode
	PRECISION_() antlr.TerminalNode
	PRIVILEGES_() antlr.TerminalNode
	PROPERTIES_() antlr.TerminalNode
	PRUNE_() antlr.TerminalNode
	QUOTES_() antlr.TerminalNode
	RANGE_() antlr.TerminalNode
	READ_() antlr.TerminalNode
	REFRESH_() antlr.TerminalNode
	RENAME_() antlr.TerminalNode
	REPEAT_() antlr.TerminalNode
	REPEATABLE_() antlr.TerminalNode
	REPLACE_() antlr.TerminalNode
	RESET_() antlr.TerminalNode
	RESPECT_() antlr.TerminalNode
	RESTRICT_() antlr.TerminalNode
	RETURN_() antlr.TerminalNode
	RETURNING_() antlr.TerminalNode
	RETURNS_() antlr.TerminalNode
	REVOKE_() antlr.TerminalNode
	ROLE_() antlr.TerminalNode
	ROLES_() antlr.TerminalNode
	ROLLBACK_() antlr.TerminalNode
	ROW_() antlr.TerminalNode
	ROWS_() antlr.TerminalNode
	RUNNING_() antlr.TerminalNode
	SCALAR_() antlr.TerminalNode
	SCHEMA_() antlr.TerminalNode
	SCHEMAS_() antlr.TerminalNode
	SECOND_() antlr.TerminalNode
	SECURITY_() antlr.TerminalNode
	SEEK_() antlr.TerminalNode
	SERIALIZABLE_() antlr.TerminalNode
	SESSION_() antlr.TerminalNode
	SET_() antlr.TerminalNode
	SETS_() antlr.TerminalNode
	SHOW_() antlr.TerminalNode
	SOME_() antlr.TerminalNode
	START_() antlr.TerminalNode
	STATS_() antlr.TerminalNode
	SUBSET_() antlr.TerminalNode
	SUBSTRING_() antlr.TerminalNode
	SYSTEM_() antlr.TerminalNode
	TABLES_() antlr.TerminalNode
	TABLESAMPLE_() antlr.TerminalNode
	TEXT_() antlr.TerminalNode
	TEXT_STRING_() antlr.TerminalNode
	TIES_() antlr.TerminalNode
	TIME_() antlr.TerminalNode
	TIMESTAMP_() antlr.TerminalNode
	TO_() antlr.TerminalNode
	TRAILING_() antlr.TerminalNode
	TRANSACTION_() antlr.TerminalNode
	TRUNCATE_() antlr.TerminalNode
	TRY_CAST_() antlr.TerminalNode
	TYPE_() antlr.TerminalNode
	UNBOUNDED_() antlr.TerminalNode
	UNCOMMITTED_() antlr.TerminalNode
	UNCONDITIONAL_() antlr.TerminalNode
	UNIQUE_() antlr.TerminalNode
	UNKNOWN_() antlr.TerminalNode
	UNMATCHED_() antlr.TerminalNode
	UNTIL_() antlr.TerminalNode
	UPDATE_() antlr.TerminalNode
	USE_() antlr.TerminalNode
	USER_() antlr.TerminalNode
	UTF16_() antlr.TerminalNode
	UTF32_() antlr.TerminalNode
	UTF8_() antlr.TerminalNode
	VALIDATE_() antlr.TerminalNode
	VALUE_() antlr.TerminalNode
	VERBOSE_() antlr.TerminalNode
	VERSION_() antlr.TerminalNode
	VIEW_() antlr.TerminalNode
	WHILE_() antlr.TerminalNode
	WINDOW_() antlr.TerminalNode
	WITHIN_() antlr.TerminalNode
	WITHOUT_() antlr.TerminalNode
	WORK_() antlr.TerminalNode
	WRAPPER_() antlr.TerminalNode
	WRITE_() antlr.TerminalNode
	YEAR_() antlr.TerminalNode
	ZONE_() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TrinoParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TrinoParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ABSENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserABSENT_, 0)
}

func (s *NonReservedContext) ADD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserADD_, 0)
}

func (s *NonReservedContext) ADMIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserADMIN_, 0)
}

func (s *NonReservedContext) AFTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAFTER_, 0)
}

func (s *NonReservedContext) ALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserALL_, 0)
}

func (s *NonReservedContext) ANALYZE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserANALYZE_, 0)
}

func (s *NonReservedContext) ANY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserANY_, 0)
}

func (s *NonReservedContext) ARRAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserARRAY_, 0)
}

func (s *NonReservedContext) ASC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserASC_, 0)
}

func (s *NonReservedContext) AT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAT_, 0)
}

func (s *NonReservedContext) AUTHORIZATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserAUTHORIZATION_, 0)
}

func (s *NonReservedContext) BEGIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBEGIN_, 0)
}

func (s *NonReservedContext) BERNOULLI_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBERNOULLI_, 0)
}

func (s *NonReservedContext) BOTH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserBOTH_, 0)
}

func (s *NonReservedContext) CALL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCALL_, 0)
}

func (s *NonReservedContext) CALLED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCALLED_, 0)
}

func (s *NonReservedContext) CASCADE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCASCADE_, 0)
}

func (s *NonReservedContext) CATALOG_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCATALOG_, 0)
}

func (s *NonReservedContext) CATALOGS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCATALOGS_, 0)
}

func (s *NonReservedContext) COLUMN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMN_, 0)
}

func (s *NonReservedContext) COLUMNS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOLUMNS_, 0)
}

func (s *NonReservedContext) COMMENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMENT_, 0)
}

func (s *NonReservedContext) COMMIT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMIT_, 0)
}

func (s *NonReservedContext) COMMITTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOMMITTED_, 0)
}

func (s *NonReservedContext) CONDITIONAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCONDITIONAL_, 0)
}

func (s *NonReservedContext) COPARTITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOPARTITION_, 0)
}

func (s *NonReservedContext) COUNT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCOUNT_, 0)
}

func (s *NonReservedContext) CURRENT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserCURRENT_, 0)
}

func (s *NonReservedContext) DATA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDATA_, 0)
}

func (s *NonReservedContext) DATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDATE_, 0)
}

func (s *NonReservedContext) DAY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDAY_, 0)
}

func (s *NonReservedContext) DECLARE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDECLARE_, 0)
}

func (s *NonReservedContext) DEFAULT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFAULT_, 0)
}

func (s *NonReservedContext) DEFINE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFINE_, 0)
}

func (s *NonReservedContext) DEFINER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDEFINER_, 0)
}

func (s *NonReservedContext) DENY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDENY_, 0)
}

func (s *NonReservedContext) DESC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESC_, 0)
}

func (s *NonReservedContext) DESCRIPTOR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDESCRIPTOR_, 0)
}

func (s *NonReservedContext) DETERMINISTIC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDETERMINISTIC_, 0)
}

func (s *NonReservedContext) DISTRIBUTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDISTRIBUTED_, 0)
}

func (s *NonReservedContext) DO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDO_, 0)
}

func (s *NonReservedContext) DOUBLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserDOUBLE_, 0)
}

func (s *NonReservedContext) ELSEIF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserELSEIF_, 0)
}

func (s *NonReservedContext) EMPTY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEMPTY_, 0)
}

func (s *NonReservedContext) ENCODING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserENCODING_, 0)
}

func (s *NonReservedContext) ERROR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserERROR_, 0)
}

func (s *NonReservedContext) EXCLUDING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXCLUDING_, 0)
}

func (s *NonReservedContext) EXPLAIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserEXPLAIN_, 0)
}

func (s *NonReservedContext) FETCH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFETCH_, 0)
}

func (s *NonReservedContext) FILTER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFILTER_, 0)
}

func (s *NonReservedContext) FINAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFINAL_, 0)
}

func (s *NonReservedContext) FIRST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFIRST_, 0)
}

func (s *NonReservedContext) FOLLOWING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFOLLOWING_, 0)
}

func (s *NonReservedContext) FORMAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFORMAT_, 0)
}

func (s *NonReservedContext) FUNCTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFUNCTION_, 0)
}

func (s *NonReservedContext) FUNCTIONS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserFUNCTIONS_, 0)
}

func (s *NonReservedContext) GRACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRACE_, 0)
}

func (s *NonReservedContext) GRANT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANT_, 0)
}

func (s *NonReservedContext) GRANTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANTED_, 0)
}

func (s *NonReservedContext) GRANTS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRANTS_, 0)
}

func (s *NonReservedContext) GRAPHVIZ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGRAPHVIZ_, 0)
}

func (s *NonReservedContext) GROUPS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserGROUPS_, 0)
}

func (s *NonReservedContext) HOUR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserHOUR_, 0)
}

func (s *NonReservedContext) IF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIF_, 0)
}

func (s *NonReservedContext) IGNORE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIGNORE_, 0)
}

func (s *NonReservedContext) IMMEDIATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIMMEDIATE_, 0)
}

func (s *NonReservedContext) INCLUDING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINCLUDING_, 0)
}

func (s *NonReservedContext) INITIAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINITIAL_, 0)
}

func (s *NonReservedContext) INPUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINPUT_, 0)
}

func (s *NonReservedContext) INTERVAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINTERVAL_, 0)
}

func (s *NonReservedContext) INVOKER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserINVOKER_, 0)
}

func (s *NonReservedContext) IO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserIO_, 0)
}

func (s *NonReservedContext) ITERATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserITERATE_, 0)
}

func (s *NonReservedContext) ISOLATION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserISOLATION_, 0)
}

func (s *NonReservedContext) JSON_() antlr.TerminalNode {
	return s.GetToken(TrinoParserJSON_, 0)
}

func (s *NonReservedContext) KEEP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserKEEP_, 0)
}

func (s *NonReservedContext) KEY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserKEY_, 0)
}

func (s *NonReservedContext) KEYS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserKEYS_, 0)
}

func (s *NonReservedContext) LANGUAGE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLANGUAGE_, 0)
}

func (s *NonReservedContext) LAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLAST_, 0)
}

func (s *NonReservedContext) LATERAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLATERAL_, 0)
}

func (s *NonReservedContext) LEADING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLEADING_, 0)
}

func (s *NonReservedContext) LEAVE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLEAVE_, 0)
}

func (s *NonReservedContext) LEVEL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLEVEL_, 0)
}

func (s *NonReservedContext) LIMIT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLIMIT_, 0)
}

func (s *NonReservedContext) LOCAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLOCAL_, 0)
}

func (s *NonReservedContext) LOGICAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLOGICAL_, 0)
}

func (s *NonReservedContext) LOOP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserLOOP_, 0)
}

func (s *NonReservedContext) MAP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMAP_, 0)
}

func (s *NonReservedContext) MATCH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCH_, 0)
}

func (s *NonReservedContext) MATCHED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCHED_, 0)
}

func (s *NonReservedContext) MATCHES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCHES_, 0)
}

func (s *NonReservedContext) MATCH_RECOGNIZE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATCH_RECOGNIZE_, 0)
}

func (s *NonReservedContext) MATERIALIZED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMATERIALIZED_, 0)
}

func (s *NonReservedContext) MEASURES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMEASURES_, 0)
}

func (s *NonReservedContext) MERGE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMERGE_, 0)
}

func (s *NonReservedContext) MINUTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMINUTE_, 0)
}

func (s *NonReservedContext) MONTH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserMONTH_, 0)
}

func (s *NonReservedContext) NESTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNESTED_, 0)
}

func (s *NonReservedContext) NEXT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNEXT_, 0)
}

func (s *NonReservedContext) NFC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFC_, 0)
}

func (s *NonReservedContext) NFD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFD_, 0)
}

func (s *NonReservedContext) NFKC_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFKC_, 0)
}

func (s *NonReservedContext) NFKD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNFKD_, 0)
}

func (s *NonReservedContext) NO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNO_, 0)
}

func (s *NonReservedContext) NONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNONE_, 0)
}

func (s *NonReservedContext) NULLIF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULLIF_, 0)
}

func (s *NonReservedContext) NULLS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserNULLS_, 0)
}

func (s *NonReservedContext) OBJECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOBJECT_, 0)
}

func (s *NonReservedContext) OF_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOF_, 0)
}

func (s *NonReservedContext) OFFSET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOFFSET_, 0)
}

func (s *NonReservedContext) OMIT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOMIT_, 0)
}

func (s *NonReservedContext) ONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserONE_, 0)
}

func (s *NonReservedContext) ONLY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserONLY_, 0)
}

func (s *NonReservedContext) OPTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOPTION_, 0)
}

func (s *NonReservedContext) ORDINALITY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserORDINALITY_, 0)
}

func (s *NonReservedContext) OUTPUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOUTPUT_, 0)
}

func (s *NonReservedContext) OVER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOVER_, 0)
}

func (s *NonReservedContext) OVERFLOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserOVERFLOW_, 0)
}

func (s *NonReservedContext) PARTITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPARTITION_, 0)
}

func (s *NonReservedContext) PARTITIONS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPARTITIONS_, 0)
}

func (s *NonReservedContext) PASSING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPASSING_, 0)
}

func (s *NonReservedContext) PAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPAST_, 0)
}

func (s *NonReservedContext) PATH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPATH_, 0)
}

func (s *NonReservedContext) PATTERN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPATTERN_, 0)
}

func (s *NonReservedContext) PER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPER_, 0)
}

func (s *NonReservedContext) PERIOD_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPERIOD_, 0)
}

func (s *NonReservedContext) PERMUTE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPERMUTE_, 0)
}

func (s *NonReservedContext) PLAN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPLAN_, 0)
}

func (s *NonReservedContext) POSITION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPOSITION_, 0)
}

func (s *NonReservedContext) PRECEDING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRECEDING_, 0)
}

func (s *NonReservedContext) PRECISION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRECISION_, 0)
}

func (s *NonReservedContext) PRIVILEGES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRIVILEGES_, 0)
}

func (s *NonReservedContext) PROPERTIES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPROPERTIES_, 0)
}

func (s *NonReservedContext) PRUNE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserPRUNE_, 0)
}

func (s *NonReservedContext) QUOTES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserQUOTES_, 0)
}

func (s *NonReservedContext) RANGE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRANGE_, 0)
}

func (s *NonReservedContext) READ_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREAD_, 0)
}

func (s *NonReservedContext) REFRESH_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREFRESH_, 0)
}

func (s *NonReservedContext) RENAME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRENAME_, 0)
}

func (s *NonReservedContext) REPEAT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPEAT_, 0)
}

func (s *NonReservedContext) REPEATABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPEATABLE_, 0)
}

func (s *NonReservedContext) REPLACE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREPLACE_, 0)
}

func (s *NonReservedContext) RESET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESET_, 0)
}

func (s *NonReservedContext) RESPECT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESPECT_, 0)
}

func (s *NonReservedContext) RESTRICT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRESTRICT_, 0)
}

func (s *NonReservedContext) RETURN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURN_, 0)
}

func (s *NonReservedContext) RETURNING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNING_, 0)
}

func (s *NonReservedContext) RETURNS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRETURNS_, 0)
}

func (s *NonReservedContext) REVOKE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserREVOKE_, 0)
}

func (s *NonReservedContext) ROLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLE_, 0)
}

func (s *NonReservedContext) ROLES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLES_, 0)
}

func (s *NonReservedContext) ROLLBACK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROLLBACK_, 0)
}

func (s *NonReservedContext) ROW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROW_, 0)
}

func (s *NonReservedContext) ROWS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserROWS_, 0)
}

func (s *NonReservedContext) RUNNING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserRUNNING_, 0)
}

func (s *NonReservedContext) SCALAR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCALAR_, 0)
}

func (s *NonReservedContext) SCHEMA_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMA_, 0)
}

func (s *NonReservedContext) SCHEMAS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSCHEMAS_, 0)
}

func (s *NonReservedContext) SECOND_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSECOND_, 0)
}

func (s *NonReservedContext) SECURITY_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSECURITY_, 0)
}

func (s *NonReservedContext) SEEK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSEEK_, 0)
}

func (s *NonReservedContext) SERIALIZABLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSERIALIZABLE_, 0)
}

func (s *NonReservedContext) SESSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSESSION_, 0)
}

func (s *NonReservedContext) SET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSET_, 0)
}

func (s *NonReservedContext) SETS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSETS_, 0)
}

func (s *NonReservedContext) SHOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSHOW_, 0)
}

func (s *NonReservedContext) SOME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSOME_, 0)
}

func (s *NonReservedContext) START_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSTART_, 0)
}

func (s *NonReservedContext) STATS_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSTATS_, 0)
}

func (s *NonReservedContext) SUBSET_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSUBSET_, 0)
}

func (s *NonReservedContext) SUBSTRING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSUBSTRING_, 0)
}

func (s *NonReservedContext) SYSTEM_() antlr.TerminalNode {
	return s.GetToken(TrinoParserSYSTEM_, 0)
}

func (s *NonReservedContext) TABLES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLES_, 0)
}

func (s *NonReservedContext) TABLESAMPLE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTABLESAMPLE_, 0)
}

func (s *NonReservedContext) TEXT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTEXT_, 0)
}

func (s *NonReservedContext) TEXT_STRING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTEXT_STRING_, 0)
}

func (s *NonReservedContext) TIES_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIES_, 0)
}

func (s *NonReservedContext) TIME_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIME_, 0)
}

func (s *NonReservedContext) TIMESTAMP_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTIMESTAMP_, 0)
}

func (s *NonReservedContext) TO_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTO_, 0)
}

func (s *NonReservedContext) TRAILING_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRAILING_, 0)
}

func (s *NonReservedContext) TRANSACTION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRANSACTION_, 0)
}

func (s *NonReservedContext) TRUNCATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRUNCATE_, 0)
}

func (s *NonReservedContext) TRY_CAST_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTRY_CAST_, 0)
}

func (s *NonReservedContext) TYPE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserTYPE_, 0)
}

func (s *NonReservedContext) UNBOUNDED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNBOUNDED_, 0)
}

func (s *NonReservedContext) UNCOMMITTED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNCOMMITTED_, 0)
}

func (s *NonReservedContext) UNCONDITIONAL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNCONDITIONAL_, 0)
}

func (s *NonReservedContext) UNIQUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNIQUE_, 0)
}

func (s *NonReservedContext) UNKNOWN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNKNOWN_, 0)
}

func (s *NonReservedContext) UNMATCHED_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNMATCHED_, 0)
}

func (s *NonReservedContext) UNTIL_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUNTIL_, 0)
}

func (s *NonReservedContext) UPDATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUPDATE_, 0)
}

func (s *NonReservedContext) USE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSE_, 0)
}

func (s *NonReservedContext) USER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUSER_, 0)
}

func (s *NonReservedContext) UTF16_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUTF16_, 0)
}

func (s *NonReservedContext) UTF32_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUTF32_, 0)
}

func (s *NonReservedContext) UTF8_() antlr.TerminalNode {
	return s.GetToken(TrinoParserUTF8_, 0)
}

func (s *NonReservedContext) VALIDATE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVALIDATE_, 0)
}

func (s *NonReservedContext) VALUE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVALUE_, 0)
}

func (s *NonReservedContext) VERBOSE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVERBOSE_, 0)
}

func (s *NonReservedContext) VERSION_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVERSION_, 0)
}

func (s *NonReservedContext) VIEW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserVIEW_, 0)
}

func (s *NonReservedContext) WHILE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWHILE_, 0)
}

func (s *NonReservedContext) WINDOW_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWINDOW_, 0)
}

func (s *NonReservedContext) WITHIN_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITHIN_, 0)
}

func (s *NonReservedContext) WITHOUT_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWITHOUT_, 0)
}

func (s *NonReservedContext) WORK_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWORK_, 0)
}

func (s *NonReservedContext) WRAPPER_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWRAPPER_, 0)
}

func (s *NonReservedContext) WRITE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserWRITE_, 0)
}

func (s *NonReservedContext) YEAR_() antlr.TerminalNode {
	return s.GetToken(TrinoParserYEAR_, 0)
}

func (s *NonReservedContext) ZONE_() antlr.TerminalNode {
	return s.GetToken(TrinoParserZONE_, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TrinoParserListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TrinoParserVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TrinoParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, TrinoParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3275)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5262737029699602754) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-9120583187364427405) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-6228115030305409) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-148654522401558561) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&273598576503) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *TrinoParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 23:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 35:
		var t *RelationContext = nil
		if localctx != nil {
			t = localctx.(*RelationContext)
		}
		return p.Relation_Sempred(t, predIndex)

	case 61:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 63:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 64:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 84:
		var t *TypeContext = nil
		if localctx != nil {
			t = localctx.(*TypeContext)
		}
		return p.Type__Sempred(t, predIndex)

	case 94:
		var t *RowPatternContext = nil
		if localctx != nil {
			t = localctx.(*RowPatternContext)
		}
		return p.RowPattern_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *TrinoParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TrinoParser) Relation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TrinoParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TrinoParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TrinoParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 22)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TrinoParser) Type__Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TrinoParser) RowPattern_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
